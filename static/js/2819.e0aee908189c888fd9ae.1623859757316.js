(self.webpackChunktemp=self.webpackChunktemp||[]).push([[2819],{2819:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZP\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony exports MultiDrag, Sortable, Swap */\n/**!\n * Sortable 1.13.0\n * @author\tRubaXa   <trash@rubaxa.org>\n * @author\towenm    <owen23355@gmail.com>\n * @license MIT\n */\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar version = \"1.13.0\";\n\nfunction userAgent(pattern) {\n  if (typeof window !== 'undefined' && window.navigator) {\n    return !! /*@__PURE__*/navigator.userAgent.match(pattern);\n  }\n}\n\nvar IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\\.|msie|iemobile|Windows Phone)/i);\nvar Edge = userAgent(/Edge/i);\nvar FireFox = userAgent(/firefox/i);\nvar Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);\nvar IOS = userAgent(/iP(ad|od|hone)/i);\nvar ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);\nvar captureMode = {\n  capture: false,\n  passive: false\n};\n\nfunction on(el, event, fn) {\n  el.addEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction off(el, event, fn) {\n  el.removeEventListener(event, fn, !IE11OrLess && captureMode);\n}\n\nfunction matches(\n/**HTMLElement*/\nel,\n/**String*/\nselector) {\n  if (!selector) return;\n  selector[0] === '>' && (selector = selector.substring(1));\n\n  if (el) {\n    try {\n      if (el.matches) {\n        return el.matches(selector);\n      } else if (el.msMatchesSelector) {\n        return el.msMatchesSelector(selector);\n      } else if (el.webkitMatchesSelector) {\n        return el.webkitMatchesSelector(selector);\n      }\n    } catch (_) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction getParentOrHost(el) {\n  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;\n}\n\nfunction closest(\n/**HTMLElement*/\nel,\n/**String*/\nselector,\n/**HTMLElement*/\nctx, includeCTX) {\n  if (el) {\n    ctx = ctx || document;\n\n    do {\n      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {\n        return el;\n      }\n\n      if (el === ctx) break;\n      /* jshint boss:true */\n    } while (el = getParentOrHost(el));\n  }\n\n  return null;\n}\n\nvar R_SPACE = /\\s+/g;\n\nfunction toggleClass(el, name, state) {\n  if (el && name) {\n    if (el.classList) {\n      el.classList[state ? 'add' : 'remove'](name);\n    } else {\n      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');\n      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');\n    }\n  }\n}\n\nfunction css(el, prop, val) {\n  var style = el && el.style;\n\n  if (style) {\n    if (val === void 0) {\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        val = document.defaultView.getComputedStyle(el, '');\n      } else if (el.currentStyle) {\n        val = el.currentStyle;\n      }\n\n      return prop === void 0 ? val : val[prop];\n    } else {\n      if (!(prop in style) && prop.indexOf('webkit') === -1) {\n        prop = '-webkit-' + prop;\n      }\n\n      style[prop] = val + (typeof val === 'string' ? '' : 'px');\n    }\n  }\n}\n\nfunction matrix(el, selfOnly) {\n  var appliedTransforms = '';\n\n  if (typeof el === 'string') {\n    appliedTransforms = el;\n  } else {\n    do {\n      var transform = css(el, 'transform');\n\n      if (transform && transform !== 'none') {\n        appliedTransforms = transform + ' ' + appliedTransforms;\n      }\n      /* jshint boss:true */\n\n    } while (!selfOnly && (el = el.parentNode));\n  }\n\n  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  /*jshint -W056 */\n\n  return matrixFn && new matrixFn(appliedTransforms);\n}\n\nfunction find(ctx, tagName, iterator) {\n  if (ctx) {\n    var list = ctx.getElementsByTagName(tagName),\n        i = 0,\n        n = list.length;\n\n    if (iterator) {\n      for (; i < n; i++) {\n        iterator(list[i], i);\n      }\n    }\n\n    return list;\n  }\n\n  return [];\n}\n\nfunction getWindowScrollingElement() {\n  var scrollingElement = document.scrollingElement;\n\n  if (scrollingElement) {\n    return scrollingElement;\n  } else {\n    return document.documentElement;\n  }\n}\n/**\n * Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments\n */\n\n\nfunction getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n  if (!el.getBoundingClientRect && el !== window) return;\n  var elRect, top, left, bottom, right, height, width;\n\n  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n    elRect = el.getBoundingClientRect();\n    top = elRect.top;\n    left = elRect.left;\n    bottom = elRect.bottom;\n    right = elRect.right;\n    height = elRect.height;\n    width = elRect.width;\n  } else {\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n    height = window.innerHeight;\n    width = window.innerWidth;\n  }\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    // Adjust for translate()\n    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)\n    // Not needed on <= IE11\n\n    if (!IE11OrLess) {\n      do {\n        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {\n          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container\n\n          top -= containerRect.top + parseInt(css(container, 'border-top-width'));\n          left -= containerRect.left + parseInt(css(container, 'border-left-width'));\n          bottom = top + elRect.height;\n          right = left + elRect.width;\n          break;\n        }\n        /* jshint boss:true */\n\n      } while (container = container.parentNode);\n    }\n  }\n\n  if (undoScale && el !== window) {\n    // Adjust for scale()\n    var elMatrix = matrix(container || el),\n        scaleX = elMatrix && elMatrix.a,\n        scaleY = elMatrix && elMatrix.d;\n\n    if (elMatrix) {\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    width: width,\n    height: height\n  };\n}\n/**\n * Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element\n */\n\n\nfunction isScrolledPast(el, elSide, parentSide) {\n  var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n  /* jshint boss:true */\n\n  while (parent) {\n    var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n\n    if (parentSide === 'top' || parentSide === 'left') {\n      visible = elSideVal >= parentSideVal;\n    } else {\n      visible = elSideVal <= parentSideVal;\n    }\n\n    if (!visible) return parent;\n    if (parent === getWindowScrollingElement()) break;\n    parent = getParentAutoScrollElement(parent, false);\n  }\n\n  return false;\n}\n/**\n * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found\n */\n\n\nfunction getChild(el, childNum, options) {\n  var currentChild = 0,\n      i = 0,\n      children = el.children;\n\n  while (i < children.length) {\n    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && children[i] !== Sortable.dragged && closest(children[i], options.draggable, el, false)) {\n      if (currentChild === childNum) {\n        return children[i];\n      }\n\n      currentChild++;\n    }\n\n    i++;\n  }\n\n  return null;\n}\n/**\n * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl\n */\n\n\nfunction lastChild(el, selector) {\n  var last = el.lastElementChild;\n\n  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n    last = last.previousElementSibling;\n  }\n\n  return last || null;\n}\n/**\n * Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}\n */\n\n\nfunction index(el, selector) {\n  var index = 0;\n\n  if (!el || !el.parentNode) {\n    return -1;\n  }\n  /* jshint boss:true */\n\n\n  while (el = el.previousElementSibling) {\n    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {\n      index++;\n    }\n  }\n\n  return index;\n}\n/**\n * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]\n */\n\n\nfunction getRelativeScrollOffset(el) {\n  var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n\n  if (el) {\n    do {\n      var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n      offsetLeft += el.scrollLeft * scaleX;\n      offsetTop += el.scrollTop * scaleY;\n    } while (el !== winScroller && (el = el.parentNode));\n  }\n\n  return [offsetLeft, offsetTop];\n}\n/**\n * Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1\n */\n\n\nfunction indexOfObject(arr, obj) {\n  for (var i in arr) {\n    if (!arr.hasOwnProperty(i)) continue;\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n    }\n  }\n\n  return -1;\n}\n\nfunction getParentAutoScrollElement(el, includeSelf) {\n  // skip to window\n  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();\n  var elem = el;\n  var gotSelf = false;\n\n  do {\n    // we don't need to get elem css if it isn't even overflowing in the first place (performance)\n    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {\n      var elemCSS = css(elem);\n\n      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {\n        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();\n        if (gotSelf || includeSelf) return elem;\n        gotSelf = true;\n      }\n    }\n    /* jshint boss:true */\n\n  } while (elem = elem.parentNode);\n\n  return getWindowScrollingElement();\n}\n\nfunction extend(dst, src) {\n  if (dst && src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction isRectEqual(rect1, rect2) {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n}\n\nvar _throttleTimeout;\n\nfunction throttle(callback, ms) {\n  return function () {\n    if (!_throttleTimeout) {\n      var args = arguments,\n          _this = this;\n\n      if (args.length === 1) {\n        callback.call(_this, args[0]);\n      } else {\n        callback.apply(_this, args);\n      }\n\n      _throttleTimeout = setTimeout(function () {\n        _throttleTimeout = void 0;\n      }, ms);\n    }\n  };\n}\n\nfunction cancelThrottle() {\n  clearTimeout(_throttleTimeout);\n  _throttleTimeout = void 0;\n}\n\nfunction scrollBy(el, x, y) {\n  el.scrollLeft += x;\n  el.scrollTop += y;\n}\n\nfunction clone(el) {\n  var Polymer = window.Polymer;\n  var $ = window.jQuery || window.Zepto;\n\n  if (Polymer && Polymer.dom) {\n    return Polymer.dom(el).cloneNode(true);\n  } else if ($) {\n    return $(el).clone(true)[0];\n  } else {\n    return el.cloneNode(true);\n  }\n}\n\nfunction setRect(el, rect) {\n  css(el, 'position', 'absolute');\n  css(el, 'top', rect.top);\n  css(el, 'left', rect.left);\n  css(el, 'width', rect.width);\n  css(el, 'height', rect.height);\n}\n\nfunction unsetRect(el) {\n  css(el, 'position', '');\n  css(el, 'top', '');\n  css(el, 'left', '');\n  css(el, 'width', '');\n  css(el, 'height', '');\n}\n\nvar expando = 'Sortable' + new Date().getTime();\n\nfunction AnimationStateManager() {\n  var animationStates = [],\n      animationCallbackId;\n  return {\n    captureAnimationState: function captureAnimationState() {\n      animationStates = [];\n      if (!this.options.animation) return;\n      var children = [].slice.call(this.el.children);\n      children.forEach(function (child) {\n        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;\n        animationStates.push({\n          target: child,\n          rect: getRect(child)\n        });\n\n        var fromRect = _objectSpread({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation\n\n\n        if (child.thisAnimationDuration) {\n          var childMatrix = matrix(child, true);\n\n          if (childMatrix) {\n            fromRect.top -= childMatrix.f;\n            fromRect.left -= childMatrix.e;\n          }\n        }\n\n        child.fromRect = fromRect;\n      });\n    },\n    addAnimationState: function addAnimationState(state) {\n      animationStates.push(state);\n    },\n    removeAnimationState: function removeAnimationState(target) {\n      animationStates.splice(indexOfObject(animationStates, {\n        target: target\n      }), 1);\n    },\n    animateAll: function animateAll(callback) {\n      var _this = this;\n\n      if (!this.options.animation) {\n        clearTimeout(animationCallbackId);\n        if (typeof callback === 'function') callback();\n        return;\n      }\n\n      var animating = false,\n          animationTime = 0;\n      animationStates.forEach(function (state) {\n        var time = 0,\n            target = state.target,\n            fromRect = target.fromRect,\n            toRect = getRect(target),\n            prevFromRect = target.prevFromRect,\n            prevToRect = target.prevToRect,\n            animatingRect = state.rect,\n            targetMatrix = matrix(target, true);\n\n        if (targetMatrix) {\n          // Compensate for current animation\n          toRect.top -= targetMatrix.f;\n          toRect.left -= targetMatrix.e;\n        }\n\n        target.toRect = toRect;\n\n        if (target.thisAnimationDuration) {\n          // Could also check if animatingRect is between fromRect and toRect\n          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect\n          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {\n            // If returning to same place as started from animation and on same axis\n            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);\n          }\n        } // if fromRect != toRect: animate\n\n\n        if (!isRectEqual(toRect, fromRect)) {\n          target.prevFromRect = fromRect;\n          target.prevToRect = toRect;\n\n          if (!time) {\n            time = _this.options.animation;\n          }\n\n          _this.animate(target, animatingRect, toRect, time);\n        }\n\n        if (time) {\n          animating = true;\n          animationTime = Math.max(animationTime, time);\n          clearTimeout(target.animationResetTimer);\n          target.animationResetTimer = setTimeout(function () {\n            target.animationTime = 0;\n            target.prevFromRect = null;\n            target.fromRect = null;\n            target.prevToRect = null;\n            target.thisAnimationDuration = null;\n          }, time);\n          target.thisAnimationDuration = time;\n        }\n      });\n      clearTimeout(animationCallbackId);\n\n      if (!animating) {\n        if (typeof callback === 'function') callback();\n      } else {\n        animationCallbackId = setTimeout(function () {\n          if (typeof callback === 'function') callback();\n        }, animationTime);\n      }\n\n      animationStates = [];\n    },\n    animate: function animate(target, currentRect, toRect, duration) {\n      if (duration) {\n        css(target, 'transition', '');\n        css(target, 'transform', '');\n        var elMatrix = matrix(this.el),\n            scaleX = elMatrix && elMatrix.a,\n            scaleY = elMatrix && elMatrix.d,\n            translateX = (currentRect.left - toRect.left) / (scaleX || 1),\n            translateY = (currentRect.top - toRect.top) / (scaleY || 1);\n        target.animatingX = !!translateX;\n        target.animatingY = !!translateY;\n        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');\n        this.forRepaintDummy = repaint(target); // repaint\n\n        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));\n        css(target, 'transform', 'translate3d(0,0,0)');\n        typeof target.animated === 'number' && clearTimeout(target.animated);\n        target.animated = setTimeout(function () {\n          css(target, 'transition', '');\n          css(target, 'transform', '');\n          target.animated = false;\n          target.animatingX = false;\n          target.animatingY = false;\n        }, duration);\n      }\n    }\n  };\n}\n\nfunction repaint(target) {\n  return target.offsetWidth;\n}\n\nfunction calculateRealTime(animatingRect, fromRect, toRect, options) {\n  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;\n}\n\nvar plugins = [];\nvar defaults = {\n  initializeByDefault: true\n};\nvar PluginManager = {\n  mount: function mount(plugin) {\n    // Set default static properties\n    for (var option in defaults) {\n      if (defaults.hasOwnProperty(option) && !(option in plugin)) {\n        plugin[option] = defaults[option];\n      }\n    }\n\n    plugins.forEach(function (p) {\n      if (p.pluginName === plugin.pluginName) {\n        throw \"Sortable: Cannot mount plugin \".concat(plugin.pluginName, \" more than once\");\n      }\n    });\n    plugins.push(plugin);\n  },\n  pluginEvent: function pluginEvent(eventName, sortable, evt) {\n    var _this = this;\n\n    this.eventCanceled = false;\n\n    evt.cancel = function () {\n      _this.eventCanceled = true;\n    };\n\n    var eventNameGlobal = eventName + 'Global';\n    plugins.forEach(function (plugin) {\n      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable\n\n      if (sortable[plugin.pluginName][eventNameGlobal]) {\n        sortable[plugin.pluginName][eventNameGlobal](_objectSpread({\n          sortable: sortable\n        }, evt));\n      } // Only fire plugin event if plugin is enabled in this sortable,\n      // and plugin has event defined\n\n\n      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {\n        sortable[plugin.pluginName][eventName](_objectSpread({\n          sortable: sortable\n        }, evt));\n      }\n    });\n  },\n  initializePlugins: function initializePlugins(sortable, el, defaults, options) {\n    plugins.forEach(function (plugin) {\n      var pluginName = plugin.pluginName;\n      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;\n      var initialized = new plugin(sortable, el, sortable.options);\n      initialized.sortable = sortable;\n      initialized.options = sortable.options;\n      sortable[pluginName] = initialized; // Add default options from plugin\n\n      _extends(defaults, initialized.defaults);\n    });\n\n    for (var option in sortable.options) {\n      if (!sortable.options.hasOwnProperty(option)) continue;\n      var modified = this.modifyOption(sortable, option, sortable.options[option]);\n\n      if (typeof modified !== 'undefined') {\n        sortable.options[option] = modified;\n      }\n    }\n  },\n  getEventProperties: function getEventProperties(name, sortable) {\n    var eventProperties = {};\n    plugins.forEach(function (plugin) {\n      if (typeof plugin.eventProperties !== 'function') return;\n\n      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));\n    });\n    return eventProperties;\n  },\n  modifyOption: function modifyOption(sortable, name, value) {\n    var modifiedValue;\n    plugins.forEach(function (plugin) {\n      // Plugin must exist on the Sortable\n      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin\n\n      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {\n        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);\n      }\n    });\n    return modifiedValue;\n  }\n};\n\nfunction dispatchEvent(_ref) {\n  var sortable = _ref.sortable,\n      rootEl = _ref.rootEl,\n      name = _ref.name,\n      targetEl = _ref.targetEl,\n      cloneEl = _ref.cloneEl,\n      toEl = _ref.toEl,\n      fromEl = _ref.fromEl,\n      oldIndex = _ref.oldIndex,\n      newIndex = _ref.newIndex,\n      oldDraggableIndex = _ref.oldDraggableIndex,\n      newDraggableIndex = _ref.newDraggableIndex,\n      originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      extraEventProperties = _ref.extraEventProperties;\n  sortable = sortable || rootEl && rootEl[expando];\n  if (!sortable) return;\n  var evt,\n      options = sortable.options,\n      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n  }\n\n  evt.to = toEl || rootEl;\n  evt.from = fromEl || rootEl;\n  evt.item = targetEl || rootEl;\n  evt.clone = cloneEl;\n  evt.oldIndex = oldIndex;\n  evt.newIndex = newIndex;\n  evt.oldDraggableIndex = oldDraggableIndex;\n  evt.newDraggableIndex = newDraggableIndex;\n  evt.originalEvent = originalEvent;\n  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;\n\n  var allEventProperties = _objectSpread({}, extraEventProperties, PluginManager.getEventProperties(name, sortable));\n\n  for (var option in allEventProperties) {\n    evt[option] = allEventProperties[option];\n  }\n\n  if (rootEl) {\n    rootEl.dispatchEvent(evt);\n  }\n\n  if (options[onName]) {\n    options[onName].call(sortable, evt);\n  }\n}\n\nvar pluginEvent = function pluginEvent(eventName, sortable) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      originalEvent = _ref.evt,\n      data = _objectWithoutProperties(_ref, [\"evt\"]);\n\n  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread({\n    dragEl: dragEl,\n    parentEl: parentEl,\n    ghostEl: ghostEl,\n    rootEl: rootEl,\n    nextEl: nextEl,\n    lastDownEl: lastDownEl,\n    cloneEl: cloneEl,\n    cloneHidden: cloneHidden,\n    dragStarted: moved,\n    putSortable: putSortable,\n    activeSortable: Sortable.active,\n    originalEvent: originalEvent,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex,\n    hideGhostForTarget: _hideGhostForTarget,\n    unhideGhostForTarget: _unhideGhostForTarget,\n    cloneNowHidden: function cloneNowHidden() {\n      cloneHidden = true;\n    },\n    cloneNowShown: function cloneNowShown() {\n      cloneHidden = false;\n    },\n    dispatchSortableEvent: function dispatchSortableEvent(name) {\n      _dispatchEvent({\n        sortable: sortable,\n        name: name,\n        originalEvent: originalEvent\n      });\n    }\n  }, data));\n};\n\nfunction _dispatchEvent(info) {\n  dispatchEvent(_objectSpread({\n    putSortable: putSortable,\n    cloneEl: cloneEl,\n    targetEl: dragEl,\n    rootEl: rootEl,\n    oldIndex: oldIndex,\n    oldDraggableIndex: oldDraggableIndex,\n    newIndex: newIndex,\n    newDraggableIndex: newDraggableIndex\n  }, info));\n}\n\nvar dragEl,\n    parentEl,\n    ghostEl,\n    rootEl,\n    nextEl,\n    lastDownEl,\n    cloneEl,\n    cloneHidden,\n    oldIndex,\n    newIndex,\n    oldDraggableIndex,\n    newDraggableIndex,\n    activeGroup,\n    putSortable,\n    awaitingDragStarted = false,\n    ignoreNextClick = false,\n    sortables = [],\n    tapEvt,\n    touchEvt,\n    lastDx,\n    lastDy,\n    tapDistanceLeft,\n    tapDistanceTop,\n    moved,\n    lastTarget,\n    lastDirection,\n    pastFirstInvertThresh = false,\n    isCircumstantialInvert = false,\n    targetMoveDistance,\n    // For positioning ghost absolutely\nghostRelativeParent,\n    ghostRelativeParentInitialScroll = [],\n    // (left, top)\n_silent = false,\n    savedInputChecked = [];\n/** @const */\n\nvar documentExists = typeof document !== 'undefined',\n    PositionGhostAbsolutely = IOS,\n    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',\n    // This will not pass for IE9, because IE9 DnD only works on anchors\nsupportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),\n    supportCssPointerEvents = function () {\n  if (!documentExists) return; // false when <= IE11\n\n  if (IE11OrLess) {\n    return false;\n  }\n\n  var el = document.createElement('x');\n  el.style.cssText = 'pointer-events:auto';\n  return el.style.pointerEvents === 'auto';\n}(),\n    _detectDirection = function _detectDirection(el, options) {\n  var elCSS = css(el),\n      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),\n      child1 = getChild(el, 0, options),\n      child2 = getChild(el, 1, options),\n      firstChildCSS = child1 && css(child1),\n      secondChildCSS = child2 && css(child2),\n      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,\n      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;\n\n  if (elCSS.display === 'flex') {\n    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';\n  }\n\n  if (elCSS.display === 'grid') {\n    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';\n  }\n\n  if (child1 && firstChildCSS[\"float\"] && firstChildCSS[\"float\"] !== 'none') {\n    var touchingSideChild2 = firstChildCSS[\"float\"] === 'left' ? 'left' : 'right';\n    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';\n  }\n\n  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';\n},\n    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {\n  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,\n      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,\n      dragElOppLength = vertical ? dragRect.width : dragRect.height,\n      targetS1Opp = vertical ? targetRect.left : targetRect.top,\n      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,\n      targetOppLength = vertical ? targetRect.width : targetRect.height;\n  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;\n},\n\n/**\n * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n * @param  {Number} x      X position\n * @param  {Number} y      Y position\n * @return {HTMLElement}   Element of the first found nearest Sortable\n */\n_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {\n  var ret;\n  sortables.some(function (sortable) {\n    if (lastChild(sortable)) return;\n    var rect = getRect(sortable),\n        threshold = sortable[expando].options.emptyInsertThreshold,\n        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n\n    if (threshold && insideHorizontally && insideVertically) {\n      return ret = sortable;\n    }\n  });\n  return ret;\n},\n    _prepareGroup = function _prepareGroup(options) {\n  function toFn(value, pull) {\n    return function (to, from, dragEl, evt) {\n      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;\n\n      if (value == null && (pull || sameGroup)) {\n        // Default pull value\n        // Default pull and put value if same group\n        return true;\n      } else if (value == null || value === false) {\n        return false;\n      } else if (pull && value === 'clone') {\n        return value;\n      } else if (typeof value === 'function') {\n        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);\n      } else {\n        var otherGroup = (pull ? to : from).options.group.name;\n        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;\n      }\n    };\n  }\n\n  var group = {};\n  var originalGroup = options.group;\n\n  if (!originalGroup || _typeof(originalGroup) != 'object') {\n    originalGroup = {\n      name: originalGroup\n    };\n  }\n\n  group.name = originalGroup.name;\n  group.checkPull = toFn(originalGroup.pull, true);\n  group.checkPut = toFn(originalGroup.put);\n  group.revertClone = originalGroup.revertClone;\n  options.group = group;\n},\n    _hideGhostForTarget = function _hideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', 'none');\n  }\n},\n    _unhideGhostForTarget = function _unhideGhostForTarget() {\n  if (!supportCssPointerEvents && ghostEl) {\n    css(ghostEl, 'display', '');\n  }\n}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position\n\n\nif (documentExists) {\n  document.addEventListener('click', function (evt) {\n    if (ignoreNextClick) {\n      evt.preventDefault();\n      evt.stopPropagation && evt.stopPropagation();\n      evt.stopImmediatePropagation && evt.stopImmediatePropagation();\n      ignoreNextClick = false;\n      return false;\n    }\n  }, true);\n}\n\nvar nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {\n  if (dragEl) {\n    evt = evt.touches ? evt.touches[0] : evt;\n\n    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);\n\n    if (nearest) {\n      // Create imitation event\n      var event = {};\n\n      for (var i in evt) {\n        if (evt.hasOwnProperty(i)) {\n          event[i] = evt[i];\n        }\n      }\n\n      event.target = event.rootEl = nearest;\n      event.preventDefault = void 0;\n      event.stopPropagation = void 0;\n\n      nearest[expando]._onDragOver(event);\n    }\n  }\n};\n\nvar _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {\n  if (dragEl) {\n    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);\n  }\n};\n/**\n * @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]\n */\n\n\nfunction Sortable(el, options) {\n  if (!(el && el.nodeType && el.nodeType === 1)) {\n    throw \"Sortable: `el` must be an HTMLElement, not \".concat({}.toString.call(el));\n  }\n\n  this.el = el; // root element\n\n  this.options = options = _extends({}, options); // Export instance\n\n  el[expando] = this;\n  var defaults = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',\n    swapThreshold: 1,\n    // percentage; 0 <= x <= 1\n    invertSwap: false,\n    // invert always\n    invertedSwapThreshold: null,\n    // will be set to same as swapThreshold if default\n    removeCloneOnHide: true,\n    direction: function direction() {\n      return _detectDirection(el, this.options);\n    },\n    ghostClass: 'sortable-ghost',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function setData(dataTransfer, dragEl) {\n      dataTransfer.setData('Text', dragEl.textContent);\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    delayOnTouchOnly: false,\n    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: {\n      x: 0,\n      y: 0\n    },\n    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,\n    emptyInsertThreshold: 5\n  };\n  PluginManager.initializePlugins(this, el, defaults); // Set default options\n\n  for (var name in defaults) {\n    !(name in options) && (options[name] = defaults[name]);\n  }\n\n  _prepareGroup(options); // Bind all private methods\n\n\n  for (var fn in this) {\n    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n      this[fn] = this[fn].bind(this);\n    }\n  } // Setup drag mode\n\n\n  this.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n  if (this.nativeDraggable) {\n    // Touch start threshold cannot be greater than the native dragstart threshold\n    this.options.touchStartThreshold = 1;\n  } // Bind events\n\n\n  if (options.supportPointer) {\n    on(el, 'pointerdown', this._onTapStart);\n  } else {\n    on(el, 'mousedown', this._onTapStart);\n    on(el, 'touchstart', this._onTapStart);\n  }\n\n  if (this.nativeDraggable) {\n    on(el, 'dragover', this);\n    on(el, 'dragenter', this);\n  }\n\n  sortables.push(this.el); // Restore sorting\n\n  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager\n\n  _extends(this, AnimationStateManager());\n}\n\nSortable.prototype =\n/** @lends Sortable.prototype */\n{\n  constructor: Sortable,\n  _isOutsideThisEl: function _isOutsideThisEl(target) {\n    if (!this.el.contains(target) && target !== this.el) {\n      lastTarget = null;\n    }\n  },\n  _getDirection: function _getDirection(evt, target) {\n    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;\n  },\n  _onTapStart: function _onTapStart(\n  /** Event|TouchEvent */\n  evt) {\n    if (!evt.cancelable) return;\n\n    var _this = this,\n        el = this.el,\n        options = this.options,\n        preventOnFilter = options.preventOnFilter,\n        type = evt.type,\n        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,\n        target = (touch || evt).target,\n        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,\n        filter = options.filter;\n\n    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\n\n\n    if (dragEl) {\n      return;\n    }\n\n    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {\n      return; // only left button and enabled\n    } // cancel dnd if original target is content editable\n\n\n    if (originalTarget.isContentEditable) {\n      return;\n    } // Safari ignores further event handling after mousedown\n\n\n    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {\n      return;\n    }\n\n    target = closest(target, options.draggable, el, false);\n\n    if (target && target.animated) {\n      return;\n    }\n\n    if (lastDownEl === target) {\n      // Ignoring duplicate `down`\n      return;\n    } // Get the index of the dragged element within its parent\n\n\n    oldIndex = index(target);\n    oldDraggableIndex = index(target, options.draggable); // Check filter\n\n    if (typeof filter === 'function') {\n      if (filter.call(this, evt, target, this)) {\n        _dispatchEvent({\n          sortable: _this,\n          rootEl: originalTarget,\n          name: 'filter',\n          targetEl: target,\n          toEl: el,\n          fromEl: el\n        });\n\n        pluginEvent('filter', _this, {\n          evt: evt\n        });\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    } else if (filter) {\n      filter = filter.split(',').some(function (criteria) {\n        criteria = closest(originalTarget, criteria.trim(), el, false);\n\n        if (criteria) {\n          _dispatchEvent({\n            sortable: _this,\n            rootEl: criteria,\n            name: 'filter',\n            targetEl: target,\n            fromEl: el,\n            toEl: el\n          });\n\n          pluginEvent('filter', _this, {\n            evt: evt\n          });\n          return true;\n        }\n      });\n\n      if (filter) {\n        preventOnFilter && evt.cancelable && evt.preventDefault();\n        return; // cancel dnd\n      }\n    }\n\n    if (options.handle && !closest(originalTarget, options.handle, el, false)) {\n      return;\n    } // Prepare `dragstart`\n\n\n    this._prepareDragStart(evt, touch, target);\n  },\n  _prepareDragStart: function _prepareDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch,\n  /** HTMLElement */\n  target) {\n    var _this = this,\n        el = _this.el,\n        options = _this.options,\n        ownerDocument = el.ownerDocument,\n        dragStartFn;\n\n    if (target && !dragEl && target.parentNode === el) {\n      var dragRect = getRect(target);\n      rootEl = el;\n      dragEl = target;\n      parentEl = dragEl.parentNode;\n      nextEl = dragEl.nextSibling;\n      lastDownEl = target;\n      activeGroup = options.group;\n      Sortable.dragged = dragEl;\n      tapEvt = {\n        target: dragEl,\n        clientX: (touch || evt).clientX,\n        clientY: (touch || evt).clientY\n      };\n      tapDistanceLeft = tapEvt.clientX - dragRect.left;\n      tapDistanceTop = tapEvt.clientY - dragRect.top;\n      this._lastX = (touch || evt).clientX;\n      this._lastY = (touch || evt).clientY;\n      dragEl.style['will-change'] = 'all';\n\n      dragStartFn = function dragStartFn() {\n        pluginEvent('delayEnded', _this, {\n          evt: evt\n        });\n\n        if (Sortable.eventCanceled) {\n          _this._onDrop();\n\n          return;\n        } // Delayed drag has been triggered\n        // we can re-enable the events: touchmove/mousemove\n\n\n        _this._disableDelayedDragEvents();\n\n        if (!FireFox && _this.nativeDraggable) {\n          dragEl.draggable = true;\n        } // Bind the events: dragstart/dragend\n\n\n        _this._triggerDragStart(evt, touch); // Drag start event\n\n\n        _dispatchEvent({\n          sortable: _this,\n          name: 'choose',\n          originalEvent: evt\n        }); // Chosen item\n\n\n        toggleClass(dragEl, options.chosenClass, true);\n      }; // Disable \"draggable\"\n\n\n      options.ignore.split(',').forEach(function (criteria) {\n        find(dragEl, criteria.trim(), _disableDraggable);\n      });\n      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\n      on(ownerDocument, 'mouseup', _this._onDrop);\n      on(ownerDocument, 'touchend', _this._onDrop);\n      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)\n\n      if (FireFox && this.nativeDraggable) {\n        this.options.touchStartThreshold = 4;\n        dragEl.draggable = true;\n      }\n\n      pluginEvent('delayStart', this, {\n        evt: evt\n      }); // Delay is impossible for native DnD in Edge or IE\n\n      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {\n        if (Sortable.eventCanceled) {\n          this._onDrop();\n\n          return;\n        } // If the user moves the pointer or let go the click or touch\n        // before the delay has been reached:\n        // disable the delayed drag\n\n\n        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);\n        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);\n        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);\n        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n      } else {\n        dragStartFn();\n      }\n    }\n  },\n  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(\n  /** TouchEvent|PointerEvent **/\n  e) {\n    var touch = e.touches ? e.touches[0] : e;\n\n    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {\n      this._disableDelayedDrag();\n    }\n  },\n  _disableDelayedDrag: function _disableDelayedDrag() {\n    dragEl && _disableDraggable(dragEl);\n    clearTimeout(this._dragStartTimer);\n\n    this._disableDelayedDragEvents();\n  },\n  _disableDelayedDragEvents: function _disableDelayedDragEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n    off(ownerDocument, 'touchend', this._disableDelayedDrag);\n    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);\n    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);\n  },\n  _triggerDragStart: function _triggerDragStart(\n  /** Event */\n  evt,\n  /** Touch */\n  touch) {\n    touch = touch || evt.pointerType == 'touch' && evt;\n\n    if (!this.nativeDraggable || touch) {\n      if (this.options.supportPointer) {\n        on(document, 'pointermove', this._onTouchMove);\n      } else if (touch) {\n        on(document, 'touchmove', this._onTouchMove);\n      } else {\n        on(document, 'mousemove', this._onTouchMove);\n      }\n    } else {\n      on(dragEl, 'dragend', this);\n      on(rootEl, 'dragstart', this._onDragStart);\n    }\n\n    try {\n      if (document.selection) {\n        // Timeout neccessary for IE9\n        _nextTick(function () {\n          document.selection.empty();\n        });\n      } else {\n        window.getSelection().removeAllRanges();\n      }\n    } catch (err) {}\n  },\n  _dragStarted: function _dragStarted(fallback, evt) {\n    awaitingDragStarted = false;\n\n    if (rootEl && dragEl) {\n      pluginEvent('dragStarted', this, {\n        evt: evt\n      });\n\n      if (this.nativeDraggable) {\n        on(document, 'dragover', _checkOutsideTargetEl);\n      }\n\n      var options = this.options; // Apply effect\n\n      !fallback && toggleClass(dragEl, options.dragClass, false);\n      toggleClass(dragEl, options.ghostClass, true);\n      Sortable.active = this;\n      fallback && this._appendGhost(); // Drag start event\n\n      _dispatchEvent({\n        sortable: this,\n        name: 'start',\n        originalEvent: evt\n      });\n    } else {\n      this._nulling();\n    }\n  },\n  _emulateDragOver: function _emulateDragOver() {\n    if (touchEvt) {\n      this._lastX = touchEvt.clientX;\n      this._lastY = touchEvt.clientY;\n\n      _hideGhostForTarget();\n\n      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n      var parent = target;\n\n      while (target && target.shadowRoot) {\n        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n        if (target === parent) break;\n        parent = target;\n      }\n\n      dragEl.parentNode[expando]._isOutsideThisEl(target);\n\n      if (parent) {\n        do {\n          if (parent[expando]) {\n            var inserted = void 0;\n            inserted = parent[expando]._onDragOver({\n              clientX: touchEvt.clientX,\n              clientY: touchEvt.clientY,\n              target: target,\n              rootEl: parent\n            });\n\n            if (inserted && !this.options.dragoverBubble) {\n              break;\n            }\n          }\n\n          target = parent; // store last element\n        }\n        /* jshint boss:true */\n        while (parent = parent.parentNode);\n      }\n\n      _unhideGhostForTarget();\n    }\n  },\n  _onTouchMove: function _onTouchMove(\n  /**TouchEvent*/\n  evt) {\n    if (tapEvt) {\n      var options = this.options,\n          fallbackTolerance = options.fallbackTolerance,\n          fallbackOffset = options.fallbackOffset,\n          touch = evt.touches ? evt.touches[0] : evt,\n          ghostMatrix = ghostEl && matrix(ghostEl, true),\n          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,\n          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,\n          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),\n          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),\n          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging\n\n      if (!Sortable.active && !awaitingDragStarted) {\n        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {\n          return;\n        }\n\n        this._onDragStart(evt, true);\n      }\n\n      if (ghostEl) {\n        if (ghostMatrix) {\n          ghostMatrix.e += dx - (lastDx || 0);\n          ghostMatrix.f += dy - (lastDy || 0);\n        } else {\n          ghostMatrix = {\n            a: 1,\n            b: 0,\n            c: 0,\n            d: 1,\n            e: dx,\n            f: dy\n          };\n        }\n\n        var cssMatrix = \"matrix(\".concat(ghostMatrix.a, \",\").concat(ghostMatrix.b, \",\").concat(ghostMatrix.c, \",\").concat(ghostMatrix.d, \",\").concat(ghostMatrix.e, \",\").concat(ghostMatrix.f, \")\");\n        css(ghostEl, 'webkitTransform', cssMatrix);\n        css(ghostEl, 'mozTransform', cssMatrix);\n        css(ghostEl, 'msTransform', cssMatrix);\n        css(ghostEl, 'transform', cssMatrix);\n        lastDx = dx;\n        lastDy = dy;\n        touchEvt = touch;\n      }\n\n      evt.cancelable && evt.preventDefault();\n    }\n  },\n  _appendGhost: function _appendGhost() {\n    // Bug if using scale(): https://stackoverflow.com/questions/2637058\n    // Not being adjusted for\n    if (!ghostEl) {\n      var container = this.options.fallbackOnBody ? document.body : rootEl,\n          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),\n          options = this.options; // Position absolutely\n\n      if (PositionGhostAbsolutely) {\n        // Get relatively positioned parent\n        ghostRelativeParent = container;\n\n        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {\n          ghostRelativeParent = ghostRelativeParent.parentNode;\n        }\n\n        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();\n          rect.top += ghostRelativeParent.scrollTop;\n          rect.left += ghostRelativeParent.scrollLeft;\n        } else {\n          ghostRelativeParent = getWindowScrollingElement();\n        }\n\n        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);\n      }\n\n      ghostEl = dragEl.cloneNode(true);\n      toggleClass(ghostEl, options.ghostClass, false);\n      toggleClass(ghostEl, options.fallbackClass, true);\n      toggleClass(ghostEl, options.dragClass, true);\n      css(ghostEl, 'transition', '');\n      css(ghostEl, 'transform', '');\n      css(ghostEl, 'box-sizing', 'border-box');\n      css(ghostEl, 'margin', 0);\n      css(ghostEl, 'top', rect.top);\n      css(ghostEl, 'left', rect.left);\n      css(ghostEl, 'width', rect.width);\n      css(ghostEl, 'height', rect.height);\n      css(ghostEl, 'opacity', '0.8');\n      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');\n      css(ghostEl, 'zIndex', '100000');\n      css(ghostEl, 'pointerEvents', 'none');\n      Sortable.ghost = ghostEl;\n      container.appendChild(ghostEl); // Set transform-origin\n\n      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');\n    }\n  },\n  _onDragStart: function _onDragStart(\n  /**Event*/\n  evt,\n  /**boolean*/\n  fallback) {\n    var _this = this;\n\n    var dataTransfer = evt.dataTransfer;\n    var options = _this.options;\n    pluginEvent('dragStart', this, {\n      evt: evt\n    });\n\n    if (Sortable.eventCanceled) {\n      this._onDrop();\n\n      return;\n    }\n\n    pluginEvent('setupClone', this);\n\n    if (!Sortable.eventCanceled) {\n      cloneEl = clone(dragEl);\n      cloneEl.draggable = false;\n      cloneEl.style['will-change'] = '';\n\n      this._hideClone();\n\n      toggleClass(cloneEl, this.options.chosenClass, false);\n      Sortable.clone = cloneEl;\n    } // #1143: IFrame support workaround\n\n\n    _this.cloneId = _nextTick(function () {\n      pluginEvent('clone', _this);\n      if (Sortable.eventCanceled) return;\n\n      if (!_this.options.removeCloneOnHide) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      }\n\n      _this._hideClone();\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'clone'\n      });\n    });\n    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events\n\n    if (fallback) {\n      ignoreNextClick = true;\n      _this._loopId = setInterval(_this._emulateDragOver, 50);\n    } else {\n      // Undo what was set in _prepareDragStart before drag started\n      off(document, 'mouseup', _this._onDrop);\n      off(document, 'touchend', _this._onDrop);\n      off(document, 'touchcancel', _this._onDrop);\n\n      if (dataTransfer) {\n        dataTransfer.effectAllowed = 'move';\n        options.setData && options.setData.call(_this, dataTransfer, dragEl);\n      }\n\n      on(document, 'drop', _this); // #1276 fix:\n\n      css(dragEl, 'transform', 'translateZ(0)');\n    }\n\n    awaitingDragStarted = true;\n    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));\n    on(document, 'selectstart', _this);\n    moved = true;\n\n    if (Safari) {\n      css(document.body, 'user-select', 'none');\n    }\n  },\n  // Returns true - if no further action is needed (either inserted or another condition)\n  _onDragOver: function _onDragOver(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        target = evt.target,\n        dragRect,\n        targetRect,\n        revert,\n        options = this.options,\n        group = options.group,\n        activeSortable = Sortable.active,\n        isOwner = activeGroup === group,\n        canSort = options.sort,\n        fromSortable = putSortable || activeSortable,\n        vertical,\n        _this = this,\n        completedFired = false;\n\n    if (_silent) return;\n\n    function dragOverEvent(name, extra) {\n      pluginEvent(name, _this, _objectSpread({\n        evt: evt,\n        isOwner: isOwner,\n        axis: vertical ? 'vertical' : 'horizontal',\n        revert: revert,\n        dragRect: dragRect,\n        targetRect: targetRect,\n        canSort: canSort,\n        fromSortable: fromSortable,\n        target: target,\n        completed: completed,\n        onMove: function onMove(target, after) {\n          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);\n        },\n        changed: changed\n      }, extra));\n    } // Capture animation state\n\n\n    function capture() {\n      dragOverEvent('dragOverAnimationCapture');\n\n      _this.captureAnimationState();\n\n      if (_this !== fromSortable) {\n        fromSortable.captureAnimationState();\n      }\n    } // Return invocation when dragEl is inserted (or completed)\n\n\n    function completed(insertion) {\n      dragOverEvent('dragOverCompleted', {\n        insertion: insertion\n      });\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        } else {\n          activeSortable._showClone(_this);\n        }\n\n        if (_this !== fromSortable) {\n          // Set ghost class to new sortable's ghost class\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\n          toggleClass(dragEl, options.ghostClass, true);\n        }\n\n        if (putSortable !== _this && _this !== Sortable.active) {\n          putSortable = _this;\n        } else if (_this === Sortable.active && putSortable) {\n          putSortable = null;\n        } // Animation\n\n\n        if (fromSortable === _this) {\n          _this._ignoreWhileAnimating = target;\n        }\n\n        _this.animateAll(function () {\n          dragOverEvent('dragOverAnimationComplete');\n          _this._ignoreWhileAnimating = null;\n        });\n\n        if (_this !== fromSortable) {\n          fromSortable.animateAll();\n          fromSortable._ignoreWhileAnimating = null;\n        }\n      } // Null lastTarget if it is not inside a previously swapped element\n\n\n      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {\n        lastTarget = null;\n      } // no bubbling and not fallback\n\n\n      if (!options.dragoverBubble && !evt.rootEl && target !== document) {\n        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted\n\n\n        !insertion && nearestEmptyInsertDetectEvent(evt);\n      }\n\n      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\n      return completedFired = true;\n    } // Call when dragEl has been inserted\n\n\n    function changed() {\n      newIndex = index(dragEl);\n      newDraggableIndex = index(dragEl, options.draggable);\n\n      _dispatchEvent({\n        sortable: _this,\n        name: 'change',\n        toEl: el,\n        newIndex: newIndex,\n        newDraggableIndex: newDraggableIndex,\n        originalEvent: evt\n      });\n    }\n\n    if (evt.preventDefault !== void 0) {\n      evt.cancelable && evt.preventDefault();\n    }\n\n    target = closest(target, options.draggable, el, true);\n    dragOverEvent('dragOver');\n    if (Sortable.eventCanceled) return completedFired;\n\n    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {\n      return completed(false);\n    }\n\n    ignoreNextClick = false;\n\n    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {\n      vertical = this._getDirection(evt, target) === 'vertical';\n      dragRect = getRect(dragEl);\n      dragOverEvent('dragOverValid');\n      if (Sortable.eventCanceled) return completedFired;\n\n      if (revert) {\n        parentEl = rootEl; // actualization\n\n        capture();\n\n        this._hideClone();\n\n        dragOverEvent('revert');\n\n        if (!Sortable.eventCanceled) {\n          if (nextEl) {\n            rootEl.insertBefore(dragEl, nextEl);\n          } else {\n            rootEl.appendChild(dragEl);\n          }\n        }\n\n        return completed(true);\n      }\n\n      var elLastChild = lastChild(el, options.draggable);\n\n      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {\n        // If already at end of list: Do not insert\n        if (elLastChild === dragEl) {\n          return completed(false);\n        } // assign target only if condition is true\n\n\n        if (elLastChild && el === evt.target) {\n          target = elLastChild;\n        }\n\n        if (target) {\n          targetRect = getRect(target);\n        }\n\n        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\n          capture();\n          el.appendChild(dragEl);\n          parentEl = el; // actualization\n\n          changed();\n          return completed(true);\n        }\n      } else if (target.parentNode === el) {\n        targetRect = getRect(target);\n        var direction = 0,\n            targetBeforeFirstSwap,\n            differentLevel = dragEl.parentNode !== el,\n            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),\n            side1 = vertical ? 'top' : 'left',\n            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),\n            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\n\n        if (lastTarget !== target) {\n          targetBeforeFirstSwap = targetRect[side1];\n          pastFirstInvertThresh = false;\n          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;\n        }\n\n        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);\n        var sibling;\n\n        if (direction !== 0) {\n          // Check if target is beside dragEl in respective direction (ignoring hidden elements)\n          var dragIndex = index(dragEl);\n\n          do {\n            dragIndex -= direction;\n            sibling = parentEl.children[dragIndex];\n          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));\n        } // If dragEl is already beside target: Do not insert\n\n\n        if (direction === 0 || sibling === target) {\n          return completed(false);\n        }\n\n        lastTarget = target;\n        lastDirection = direction;\n        var nextSibling = target.nextElementSibling,\n            after = false;\n        after = direction === 1;\n\n        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\n\n        if (moveVector !== false) {\n          if (moveVector === 1 || moveVector === -1) {\n            after = moveVector === 1;\n          }\n\n          _silent = true;\n          setTimeout(_unsilent, 30);\n          capture();\n\n          if (after && !nextSibling) {\n            el.appendChild(dragEl);\n          } else {\n            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n          } // Undo chrome's scroll adjustment (has no effect on other browsers)\n\n\n          if (scrolledPastTop) {\n            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\n          }\n\n          parentEl = dragEl.parentNode; // actualization\n          // must be done before animation\n\n          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\n            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);\n          }\n\n          changed();\n          return completed(true);\n        }\n      }\n\n      if (el.contains(dragEl)) {\n        return completed(false);\n      }\n    }\n\n    return false;\n  },\n  _ignoreWhileAnimating: null,\n  _offMoveEvents: function _offMoveEvents() {\n    off(document, 'mousemove', this._onTouchMove);\n    off(document, 'touchmove', this._onTouchMove);\n    off(document, 'pointermove', this._onTouchMove);\n    off(document, 'dragover', nearestEmptyInsertDetectEvent);\n    off(document, 'mousemove', nearestEmptyInsertDetectEvent);\n    off(document, 'touchmove', nearestEmptyInsertDetectEvent);\n  },\n  _offUpEvents: function _offUpEvents() {\n    var ownerDocument = this.el.ownerDocument;\n    off(ownerDocument, 'mouseup', this._onDrop);\n    off(ownerDocument, 'touchend', this._onDrop);\n    off(ownerDocument, 'pointerup', this._onDrop);\n    off(ownerDocument, 'touchcancel', this._onDrop);\n    off(document, 'selectstart', this);\n  },\n  _onDrop: function _onDrop(\n  /**Event*/\n  evt) {\n    var el = this.el,\n        options = this.options; // Get the index of the dragged element within its parent\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n    pluginEvent('drop', this, {\n      evt: evt\n    });\n    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event\n\n    newIndex = index(dragEl);\n    newDraggableIndex = index(dragEl, options.draggable);\n\n    if (Sortable.eventCanceled) {\n      this._nulling();\n\n      return;\n    }\n\n    awaitingDragStarted = false;\n    isCircumstantialInvert = false;\n    pastFirstInvertThresh = false;\n    clearInterval(this._loopId);\n    clearTimeout(this._dragStartTimer);\n\n    _cancelNextTick(this.cloneId);\n\n    _cancelNextTick(this._dragStartId); // Unbind events\n\n\n    if (this.nativeDraggable) {\n      off(document, 'drop', this);\n      off(el, 'dragstart', this._onDragStart);\n    }\n\n    this._offMoveEvents();\n\n    this._offUpEvents();\n\n    if (Safari) {\n      css(document.body, 'user-select', '');\n    }\n\n    css(dragEl, 'transform', '');\n\n    if (evt) {\n      if (moved) {\n        evt.cancelable && evt.preventDefault();\n        !options.dropBubble && evt.stopPropagation();\n      }\n\n      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        // Remove clone(s)\n        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      if (dragEl) {\n        if (this.nativeDraggable) {\n          off(dragEl, 'dragend', this);\n        }\n\n        _disableDraggable(dragEl);\n\n        dragEl.style['will-change'] = ''; // Remove classes\n        // ghostClass is added in dragStarted\n\n        if (moved && !awaitingDragStarted) {\n          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\n        }\n\n        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event\n\n        _dispatchEvent({\n          sortable: this,\n          name: 'unchoose',\n          toEl: parentEl,\n          newIndex: null,\n          newDraggableIndex: null,\n          originalEvent: evt\n        });\n\n        if (rootEl !== parentEl) {\n          if (newIndex >= 0) {\n            // Add event\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'add',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            }); // Remove event\n\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'remove',\n              toEl: parentEl,\n              originalEvent: evt\n            }); // drag from one list and drop into another\n\n\n            _dispatchEvent({\n              rootEl: parentEl,\n              name: 'sort',\n              toEl: parentEl,\n              fromEl: rootEl,\n              originalEvent: evt\n            });\n\n            _dispatchEvent({\n              sortable: this,\n              name: 'sort',\n              toEl: parentEl,\n              originalEvent: evt\n            });\n          }\n\n          putSortable && putSortable.save();\n        } else {\n          if (newIndex !== oldIndex) {\n            if (newIndex >= 0) {\n              // drag & drop within the same list\n              _dispatchEvent({\n                sortable: this,\n                name: 'update',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n\n              _dispatchEvent({\n                sortable: this,\n                name: 'sort',\n                toEl: parentEl,\n                originalEvent: evt\n              });\n            }\n          }\n        }\n\n        if (Sortable.active) {\n          /* jshint eqnull:true */\n          if (newIndex == null || newIndex === -1) {\n            newIndex = oldIndex;\n            newDraggableIndex = oldDraggableIndex;\n          }\n\n          _dispatchEvent({\n            sortable: this,\n            name: 'end',\n            toEl: parentEl,\n            originalEvent: evt\n          }); // Save sorting\n\n\n          this.save();\n        }\n      }\n    }\n\n    this._nulling();\n  },\n  _nulling: function _nulling() {\n    pluginEvent('nulling', this);\n    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;\n    savedInputChecked.forEach(function (el) {\n      el.checked = true;\n    });\n    savedInputChecked.length = lastDx = lastDy = 0;\n  },\n  handleEvent: function handleEvent(\n  /**Event*/\n  evt) {\n    switch (evt.type) {\n      case 'drop':\n      case 'dragend':\n        this._onDrop(evt);\n\n        break;\n\n      case 'dragenter':\n      case 'dragover':\n        if (dragEl) {\n          this._onDragOver(evt);\n\n          _globalDragOver(evt);\n        }\n\n        break;\n\n      case 'selectstart':\n        evt.preventDefault();\n        break;\n    }\n  },\n\n  /**\n   * Serializes the item into an array of string.\n   * @returns {String[]}\n   */\n  toArray: function toArray() {\n    var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n\n    for (; i < n; i++) {\n      el = children[i];\n\n      if (closest(el, options.draggable, this.el, false)) {\n        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n      }\n    }\n\n    return order;\n  },\n\n  /**\n   * Sorts the elements according to the array.\n   * @param  {String[]}  order  order of the items\n   */\n  sort: function sort(order, useAnimation) {\n    var items = {},\n        rootEl = this.el;\n    this.toArray().forEach(function (id, i) {\n      var el = rootEl.children[i];\n\n      if (closest(el, this.options.draggable, rootEl, false)) {\n        items[id] = el;\n      }\n    }, this);\n    useAnimation && this.captureAnimationState();\n    order.forEach(function (id) {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n    useAnimation && this.animateAll();\n  },\n\n  /**\n   * Save the current sorting\n   */\n  save: function save() {\n    var store = this.options.store;\n    store && store.set && store.set(this);\n  },\n\n  /**\n   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n   * @param   {HTMLElement}  el\n   * @param   {String}       [selector]  default: `options.draggable`\n   * @returns {HTMLElement|null}\n   */\n  closest: function closest$1(el, selector) {\n    return closest(el, selector || this.options.draggable, this.el, false);\n  },\n\n  /**\n   * Set/get option\n   * @param   {string} name\n   * @param   {*}      [value]\n   * @returns {*}\n   */\n  option: function option(name, value) {\n    var options = this.options;\n\n    if (value === void 0) {\n      return options[name];\n    } else {\n      var modifiedValue = PluginManager.modifyOption(this, name, value);\n\n      if (typeof modifiedValue !== 'undefined') {\n        options[name] = modifiedValue;\n      } else {\n        options[name] = value;\n      }\n\n      if (name === 'group') {\n        _prepareGroup(options);\n      }\n    }\n  },\n\n  /**\n   * Destroy\n   */\n  destroy: function destroy() {\n    pluginEvent('destroy', this);\n    var el = this.el;\n    el[expando] = null;\n    off(el, 'mousedown', this._onTapStart);\n    off(el, 'touchstart', this._onTapStart);\n    off(el, 'pointerdown', this._onTapStart);\n\n    if (this.nativeDraggable) {\n      off(el, 'dragover', this);\n      off(el, 'dragenter', this);\n    } // Remove draggable attributes\n\n\n    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n      el.removeAttribute('draggable');\n    });\n\n    this._onDrop();\n\n    this._disableDelayedDragEvents();\n\n    sortables.splice(sortables.indexOf(this.el), 1);\n    this.el = el = null;\n  },\n  _hideClone: function _hideClone() {\n    if (!cloneHidden) {\n      pluginEvent('hideClone', this);\n      if (Sortable.eventCanceled) return;\n      css(cloneEl, 'display', 'none');\n\n      if (this.options.removeCloneOnHide && cloneEl.parentNode) {\n        cloneEl.parentNode.removeChild(cloneEl);\n      }\n\n      cloneHidden = true;\n    }\n  },\n  _showClone: function _showClone(putSortable) {\n    if (putSortable.lastPutMode !== 'clone') {\n      this._hideClone();\n\n      return;\n    }\n\n    if (cloneHidden) {\n      pluginEvent('showClone', this);\n      if (Sortable.eventCanceled) return; // show clone at dragEl or original position\n\n      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {\n        rootEl.insertBefore(cloneEl, dragEl);\n      } else if (nextEl) {\n        rootEl.insertBefore(cloneEl, nextEl);\n      } else {\n        rootEl.appendChild(cloneEl);\n      }\n\n      if (this.options.group.revertClone) {\n        this.animate(dragEl, cloneEl);\n      }\n\n      css(cloneEl, 'display', '');\n      cloneHidden = false;\n    }\n  }\n};\n\nfunction _globalDragOver(\n/**Event*/\nevt) {\n  if (evt.dataTransfer) {\n    evt.dataTransfer.dropEffect = 'move';\n  }\n\n  evt.cancelable && evt.preventDefault();\n}\n\nfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {\n  var evt,\n      sortable = fromEl[expando],\n      onMoveFn = sortable.options.onMove,\n      retVal; // Support for new CustomEvent feature\n\n  if (window.CustomEvent && !IE11OrLess && !Edge) {\n    evt = new CustomEvent('move', {\n      bubbles: true,\n      cancelable: true\n    });\n  } else {\n    evt = document.createEvent('Event');\n    evt.initEvent('move', true, true);\n  }\n\n  evt.to = toEl;\n  evt.from = fromEl;\n  evt.dragged = dragEl;\n  evt.draggedRect = dragRect;\n  evt.related = targetEl || toEl;\n  evt.relatedRect = targetRect || getRect(toEl);\n  evt.willInsertAfter = willInsertAfter;\n  evt.originalEvent = originalEvent;\n  fromEl.dispatchEvent(evt);\n\n  if (onMoveFn) {\n    retVal = onMoveFn.call(sortable, evt, originalEvent);\n  }\n\n  return retVal;\n}\n\nfunction _disableDraggable(el) {\n  el.draggable = false;\n}\n\nfunction _unsilent() {\n  _silent = false;\n}\n\nfunction _ghostIsLast(evt, vertical, sortable) {\n  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));\n  var spacer = 10;\n  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;\n}\n\nfunction _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\n  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,\n      targetLength = vertical ? targetRect.height : targetRect.width,\n      targetS1 = vertical ? targetRect.top : targetRect.left,\n      targetS2 = vertical ? targetRect.bottom : targetRect.right,\n      invert = false;\n\n  if (!invertSwap) {\n    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\n    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {\n      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\n      // check if past first invert threshold on side opposite of lastDirection\n      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {\n        // past first invert threshold, do not restrict inverted threshold to dragEl shadow\n        pastFirstInvertThresh = true;\n      }\n\n      if (!pastFirstInvertThresh) {\n        // dragEl shadow (target move distance shadow)\n        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\n        : mouseOnAxis > targetS2 - targetMoveDistance) {\n          return -lastDirection;\n        }\n      } else {\n        invert = true;\n      }\n    } else {\n      // Regular\n      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {\n        return _getInsertDirection(target);\n      }\n    }\n  }\n\n  invert = invert || invertSwap;\n\n  if (invert) {\n    // Invert of regular\n    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {\n      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;\n    }\n  }\n\n  return 0;\n}\n/**\n * Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped\n */\n\n\nfunction _getInsertDirection(target) {\n  if (index(dragEl) < index(target)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n/**\n * Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private\n */\n\n\nfunction _generateId(el) {\n  var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n\n  while (i--) {\n    sum += str.charCodeAt(i);\n  }\n\n  return sum.toString(36);\n}\n\nfunction _saveInputCheckedState(root) {\n  savedInputChecked.length = 0;\n  var inputs = root.getElementsByTagName('input');\n  var idx = inputs.length;\n\n  while (idx--) {\n    var el = inputs[idx];\n    el.checked && savedInputChecked.push(el);\n  }\n}\n\nfunction _nextTick(fn) {\n  return setTimeout(fn, 0);\n}\n\nfunction _cancelNextTick(id) {\n  return clearTimeout(id);\n} // Fixed #973:\n\n\nif (documentExists) {\n  on(document, 'touchmove', function (evt) {\n    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {\n      evt.preventDefault();\n    }\n  });\n} // Export utils\n\n\nSortable.utils = {\n  on: on,\n  off: off,\n  css: css,\n  find: find,\n  is: function is(el, selector) {\n    return !!closest(el, selector, el, false);\n  },\n  extend: extend,\n  throttle: throttle,\n  closest: closest,\n  toggleClass: toggleClass,\n  clone: clone,\n  index: index,\n  nextTick: _nextTick,\n  cancelNextTick: _cancelNextTick,\n  detectDirection: _detectDirection,\n  getChild: getChild\n};\n/**\n * Get the Sortable instance of an element\n * @param  {HTMLElement} element The element\n * @return {Sortable|undefined}         The instance of Sortable\n */\n\nSortable.get = function (element) {\n  return element[expando];\n};\n/**\n * Mount a plugin to Sortable\n * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted\n */\n\n\nSortable.mount = function () {\n  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n    plugins[_key] = arguments[_key];\n  }\n\n  if (plugins[0].constructor === Array) plugins = plugins[0];\n  plugins.forEach(function (plugin) {\n    if (!plugin.prototype || !plugin.prototype.constructor) {\n      throw \"Sortable: Mounted plugin must be a constructor function, not \".concat({}.toString.call(plugin));\n    }\n\n    if (plugin.utils) Sortable.utils = _objectSpread({}, Sortable.utils, plugin.utils);\n    PluginManager.mount(plugin);\n  });\n};\n/**\n * Create sortable instance\n * @param {HTMLElement}  el\n * @param {Object}      [options]\n */\n\n\nSortable.create = function (el, options) {\n  return new Sortable(el, options);\n}; // Export\n\n\nSortable.version = version;\nvar autoScrolls = [],\n    scrollEl,\n    scrollRootEl,\n    scrolling = false,\n    lastAutoScrollX,\n    lastAutoScrollY,\n    touchEvt$1,\n    pointerElemChangedInterval;\n\nfunction AutoScrollPlugin() {\n  function AutoScroll() {\n    this.defaults = {\n      scroll: true,\n      scrollSensitivity: 30,\n      scrollSpeed: 10,\n      bubbleScroll: true\n    }; // Bind all private methods\n\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n  }\n\n  AutoScroll.prototype = {\n    dragStarted: function dragStarted(_ref) {\n      var originalEvent = _ref.originalEvent;\n\n      if (this.sortable.nativeDraggable) {\n        on(document, 'dragover', this._handleAutoScroll);\n      } else {\n        if (this.options.supportPointer) {\n          on(document, 'pointermove', this._handleFallbackAutoScroll);\n        } else if (originalEvent.touches) {\n          on(document, 'touchmove', this._handleFallbackAutoScroll);\n        } else {\n          on(document, 'mousemove', this._handleFallbackAutoScroll);\n        }\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref2) {\n      var originalEvent = _ref2.originalEvent; // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)\n\n      if (!this.options.dragOverBubble && !originalEvent.rootEl) {\n        this._handleAutoScroll(originalEvent);\n      }\n    },\n    drop: function drop() {\n      if (this.sortable.nativeDraggable) {\n        off(document, 'dragover', this._handleAutoScroll);\n      } else {\n        off(document, 'pointermove', this._handleFallbackAutoScroll);\n        off(document, 'touchmove', this._handleFallbackAutoScroll);\n        off(document, 'mousemove', this._handleFallbackAutoScroll);\n      }\n\n      clearPointerElemChangedInterval();\n      clearAutoScrolls();\n      cancelThrottle();\n    },\n    nulling: function nulling() {\n      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;\n      autoScrolls.length = 0;\n    },\n    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {\n      this._handleAutoScroll(evt, true);\n    },\n    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {\n      var _this = this;\n\n      var x = (evt.touches ? evt.touches[0] : evt).clientX,\n          y = (evt.touches ? evt.touches[0] : evt).clientY,\n          elem = document.elementFromPoint(x, y);\n      touchEvt$1 = evt; // IE does not seem to have native autoscroll,\n      // Edge's autoscroll seems too conditional,\n      // MACOS Safari does not have autoscroll,\n      // Firefox and Chrome are good\n\n      if (fallback || Edge || IE11OrLess || Safari) {\n        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change\n\n        var ogElemScroller = getParentAutoScrollElement(elem, true);\n\n        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {\n          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour\n\n          pointerElemChangedInterval = setInterval(function () {\n            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);\n\n            if (newElem !== ogElemScroller) {\n              ogElemScroller = newElem;\n              clearAutoScrolls();\n            }\n\n            autoScroll(evt, _this.options, newElem, fallback);\n          }, 10);\n          lastAutoScrollX = x;\n          lastAutoScrollY = y;\n        }\n      } else {\n        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll\n        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {\n          clearAutoScrolls();\n          return;\n        }\n\n        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);\n      }\n    }\n  };\n  return _extends(AutoScroll, {\n    pluginName: 'scroll',\n    initializeByDefault: true\n  });\n}\n\nfunction clearAutoScrolls() {\n  autoScrolls.forEach(function (autoScroll) {\n    clearInterval(autoScroll.pid);\n  });\n  autoScrolls = [];\n}\n\nfunction clearPointerElemChangedInterval() {\n  clearInterval(pointerElemChangedInterval);\n}\n\nvar autoScroll = throttle(function (evt, options, rootEl, isFallback) {\n  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n  if (!options.scroll) return;\n  var x = (evt.touches ? evt.touches[0] : evt).clientX,\n      y = (evt.touches ? evt.touches[0] : evt).clientY,\n      sens = options.scrollSensitivity,\n      speed = options.scrollSpeed,\n      winScroller = getWindowScrollingElement();\n  var scrollThisInstance = false,\n      scrollCustomFn; // New scroll root, set scrollEl\n\n  if (scrollRootEl !== rootEl) {\n    scrollRootEl = rootEl;\n    clearAutoScrolls();\n    scrollEl = options.scroll;\n    scrollCustomFn = options.scrollFn;\n\n    if (scrollEl === true) {\n      scrollEl = getParentAutoScrollElement(rootEl, true);\n    }\n  }\n\n  var layersOut = 0;\n  var currentParent = scrollEl;\n\n  do {\n    var el = currentParent,\n        rect = getRect(el),\n        top = rect.top,\n        bottom = rect.bottom,\n        left = rect.left,\n        right = rect.right,\n        width = rect.width,\n        height = rect.height,\n        canScrollX = void 0,\n        canScrollY = void 0,\n        scrollWidth = el.scrollWidth,\n        scrollHeight = el.scrollHeight,\n        elCSS = css(el),\n        scrollPosX = el.scrollLeft,\n        scrollPosY = el.scrollTop;\n\n    if (el === winScroller) {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');\n    } else {\n      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');\n      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');\n    }\n\n    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);\n    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);\n\n    if (!autoScrolls[layersOut]) {\n      for (var i = 0; i <= layersOut; i++) {\n        if (!autoScrolls[i]) {\n          autoScrolls[i] = {};\n        }\n      }\n    }\n\n    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {\n      autoScrolls[layersOut].el = el;\n      autoScrolls[layersOut].vx = vx;\n      autoScrolls[layersOut].vy = vy;\n      clearInterval(autoScrolls[layersOut].pid);\n\n      if (vx != 0 || vy != 0) {\n        scrollThisInstance = true;\n        /* jshint loopfunc:true */\n\n        autoScrolls[layersOut].pid = setInterval(function () {\n          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour\n          if (isFallback && this.layer === 0) {\n            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely\n\n          }\n\n          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;\n          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;\n\n          if (typeof scrollCustomFn === 'function') {\n            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {\n              return;\n            }\n          }\n\n          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);\n        }.bind({\n          layer: layersOut\n        }), 24);\n      }\n    }\n\n    layersOut++;\n  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));\n\n  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not\n}, 30);\n\nvar drop = function drop(_ref) {\n  var originalEvent = _ref.originalEvent,\n      putSortable = _ref.putSortable,\n      dragEl = _ref.dragEl,\n      activeSortable = _ref.activeSortable,\n      dispatchSortableEvent = _ref.dispatchSortableEvent,\n      hideGhostForTarget = _ref.hideGhostForTarget,\n      unhideGhostForTarget = _ref.unhideGhostForTarget;\n  if (!originalEvent) return;\n  var toSortable = putSortable || activeSortable;\n  hideGhostForTarget();\n  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;\n  var target = document.elementFromPoint(touch.clientX, touch.clientY);\n  unhideGhostForTarget();\n\n  if (toSortable && !toSortable.el.contains(target)) {\n    dispatchSortableEvent('spill');\n    this.onSpill({\n      dragEl: dragEl,\n      putSortable: putSortable\n    });\n  }\n};\n\nfunction Revert() {}\n\nRevert.prototype = {\n  startIndex: null,\n  dragStart: function dragStart(_ref2) {\n    var oldDraggableIndex = _ref2.oldDraggableIndex;\n    this.startIndex = oldDraggableIndex;\n  },\n  onSpill: function onSpill(_ref3) {\n    var dragEl = _ref3.dragEl,\n        putSortable = _ref3.putSortable;\n    this.sortable.captureAnimationState();\n\n    if (putSortable) {\n      putSortable.captureAnimationState();\n    }\n\n    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);\n\n    if (nextSibling) {\n      this.sortable.el.insertBefore(dragEl, nextSibling);\n    } else {\n      this.sortable.el.appendChild(dragEl);\n    }\n\n    this.sortable.animateAll();\n\n    if (putSortable) {\n      putSortable.animateAll();\n    }\n  },\n  drop: drop\n};\n\n_extends(Revert, {\n  pluginName: 'revertOnSpill'\n});\n\nfunction Remove() {}\n\nRemove.prototype = {\n  onSpill: function onSpill(_ref4) {\n    var dragEl = _ref4.dragEl,\n        putSortable = _ref4.putSortable;\n    var parentSortable = putSortable || this.sortable;\n    parentSortable.captureAnimationState();\n    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);\n    parentSortable.animateAll();\n  },\n  drop: drop\n};\n\n_extends(Remove, {\n  pluginName: 'removeOnSpill'\n});\n\nvar lastSwapEl;\n\nfunction SwapPlugin() {\n  function Swap() {\n    this.defaults = {\n      swapClass: 'sortable-swap-highlight'\n    };\n  }\n\n  Swap.prototype = {\n    dragStart: function dragStart(_ref) {\n      var dragEl = _ref.dragEl;\n      lastSwapEl = dragEl;\n    },\n    dragOverValid: function dragOverValid(_ref2) {\n      var completed = _ref2.completed,\n          target = _ref2.target,\n          onMove = _ref2.onMove,\n          activeSortable = _ref2.activeSortable,\n          changed = _ref2.changed,\n          cancel = _ref2.cancel;\n      if (!activeSortable.options.swap) return;\n      var el = this.sortable.el,\n          options = this.options;\n\n      if (target && target !== el) {\n        var prevSwapEl = lastSwapEl;\n\n        if (onMove(target) !== false) {\n          toggleClass(target, options.swapClass, true);\n          lastSwapEl = target;\n        } else {\n          lastSwapEl = null;\n        }\n\n        if (prevSwapEl && prevSwapEl !== lastSwapEl) {\n          toggleClass(prevSwapEl, options.swapClass, false);\n        }\n      }\n\n      changed();\n      completed(true);\n      cancel();\n    },\n    drop: function drop(_ref3) {\n      var activeSortable = _ref3.activeSortable,\n          putSortable = _ref3.putSortable,\n          dragEl = _ref3.dragEl;\n      var toSortable = putSortable || this.sortable;\n      var options = this.options;\n      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);\n\n      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {\n        if (dragEl !== lastSwapEl) {\n          toSortable.captureAnimationState();\n          if (toSortable !== activeSortable) activeSortable.captureAnimationState();\n          swapNodes(dragEl, lastSwapEl);\n          toSortable.animateAll();\n          if (toSortable !== activeSortable) activeSortable.animateAll();\n        }\n      }\n    },\n    nulling: function nulling() {\n      lastSwapEl = null;\n    }\n  };\n  return _extends(Swap, {\n    pluginName: 'swap',\n    eventProperties: function eventProperties() {\n      return {\n        swapItem: lastSwapEl\n      };\n    }\n  });\n}\n\nfunction swapNodes(n1, n2) {\n  var p1 = n1.parentNode,\n      p2 = n2.parentNode,\n      i1,\n      i2;\n  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;\n  i1 = index(n1);\n  i2 = index(n2);\n\n  if (p1.isEqualNode(p2) && i1 < i2) {\n    i2++;\n  }\n\n  p1.insertBefore(n2, p1.children[i1]);\n  p2.insertBefore(n1, p2.children[i2]);\n}\n\nvar multiDragElements = (/* unused pure expression or super */ null && ([])),\n    multiDragClones = (/* unused pure expression or super */ null && ([])),\n    lastMultiDragSelect,\n    // for selection with modifier key down (SHIFT)\nmultiDragSortable,\n    initialFolding = false,\n    // Initial multi-drag fold when drag started\nfolding = false,\n    // Folding any other time\ndragStarted = false,\n    dragEl$1,\n    clonesFromRect,\n    clonesHidden;\n\nfunction MultiDragPlugin() {\n  function MultiDrag(sortable) {\n    // Bind all private methods\n    for (var fn in this) {\n      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {\n        this[fn] = this[fn].bind(this);\n      }\n    }\n\n    if (sortable.options.supportPointer) {\n      on(document, 'pointerup', this._deselectMultiDrag);\n    } else {\n      on(document, 'mouseup', this._deselectMultiDrag);\n      on(document, 'touchend', this._deselectMultiDrag);\n    }\n\n    on(document, 'keydown', this._checkKeyDown);\n    on(document, 'keyup', this._checkKeyUp);\n    this.defaults = {\n      selectedClass: 'sortable-selected',\n      multiDragKey: null,\n      setData: function setData(dataTransfer, dragEl) {\n        var data = '';\n\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          multiDragElements.forEach(function (multiDragElement, i) {\n            data += (!i ? '' : ', ') + multiDragElement.textContent;\n          });\n        } else {\n          data = dragEl.textContent;\n        }\n\n        dataTransfer.setData('Text', data);\n      }\n    };\n  }\n\n  MultiDrag.prototype = {\n    multiDragKeyDown: false,\n    isMultiDrag: false,\n    delayStartGlobal: function delayStartGlobal(_ref) {\n      var dragged = _ref.dragEl;\n      dragEl$1 = dragged;\n    },\n    delayEnded: function delayEnded() {\n      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);\n    },\n    setupClone: function setupClone(_ref2) {\n      var sortable = _ref2.sortable,\n          cancel = _ref2.cancel;\n      if (!this.isMultiDrag) return;\n\n      for (var i = 0; i < multiDragElements.length; i++) {\n        multiDragClones.push(clone(multiDragElements[i]));\n        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;\n        multiDragClones[i].draggable = false;\n        multiDragClones[i].style['will-change'] = '';\n        toggleClass(multiDragClones[i], this.options.selectedClass, false);\n        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);\n      }\n\n      sortable._hideClone();\n\n      cancel();\n    },\n    clone: function clone(_ref3) {\n      var sortable = _ref3.sortable,\n          rootEl = _ref3.rootEl,\n          dispatchSortableEvent = _ref3.dispatchSortableEvent,\n          cancel = _ref3.cancel;\n      if (!this.isMultiDrag) return;\n\n      if (!this.options.removeCloneOnHide) {\n        if (multiDragElements.length && multiDragSortable === sortable) {\n          insertMultiDragClones(true, rootEl);\n          dispatchSortableEvent('clone');\n          cancel();\n        }\n      }\n    },\n    showClone: function showClone(_ref4) {\n      var cloneNowShown = _ref4.cloneNowShown,\n          rootEl = _ref4.rootEl,\n          cancel = _ref4.cancel;\n      if (!this.isMultiDrag) return;\n      insertMultiDragClones(false, rootEl);\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', '');\n      });\n      cloneNowShown();\n      clonesHidden = false;\n      cancel();\n    },\n    hideClone: function hideClone(_ref5) {\n      var _this = this;\n\n      var sortable = _ref5.sortable,\n          cloneNowHidden = _ref5.cloneNowHidden,\n          cancel = _ref5.cancel;\n      if (!this.isMultiDrag) return;\n      multiDragClones.forEach(function (clone) {\n        css(clone, 'display', 'none');\n\n        if (_this.options.removeCloneOnHide && clone.parentNode) {\n          clone.parentNode.removeChild(clone);\n        }\n      });\n      cloneNowHidden();\n      clonesHidden = true;\n      cancel();\n    },\n    dragStartGlobal: function dragStartGlobal(_ref6) {\n      var sortable = _ref6.sortable;\n\n      if (!this.isMultiDrag && multiDragSortable) {\n        multiDragSortable.multiDrag._deselectMultiDrag();\n      }\n\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.sortableIndex = index(multiDragElement);\n      }); // Sort multi-drag elements\n\n      multiDragElements = multiDragElements.sort(function (a, b) {\n        return a.sortableIndex - b.sortableIndex;\n      });\n      dragStarted = true;\n    },\n    dragStarted: function dragStarted(_ref7) {\n      var _this2 = this;\n\n      var sortable = _ref7.sortable;\n      if (!this.isMultiDrag) return;\n\n      if (this.options.sort) {\n        // Capture rects,\n        // hide multi drag elements (by positioning them absolute),\n        // set multi drag elements rects to dragRect,\n        // show multi drag elements,\n        // animate to rects,\n        // unset rects & remove from DOM\n        sortable.captureAnimationState();\n\n        if (this.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            css(multiDragElement, 'position', 'absolute');\n          });\n          var dragRect = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRect);\n          });\n          folding = true;\n          initialFolding = true;\n        }\n      }\n\n      sortable.animateAll(function () {\n        folding = false;\n        initialFolding = false;\n\n        if (_this2.options.animation) {\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n        } // Remove all auxiliary multidrag items from el, if sorting enabled\n\n\n        if (_this2.options.sort) {\n          removeMultiDragElements();\n        }\n      });\n    },\n    dragOver: function dragOver(_ref8) {\n      var target = _ref8.target,\n          completed = _ref8.completed,\n          cancel = _ref8.cancel;\n\n      if (folding && ~multiDragElements.indexOf(target)) {\n        completed(false);\n        cancel();\n      }\n    },\n    revert: function revert(_ref9) {\n      var fromSortable = _ref9.fromSortable,\n          rootEl = _ref9.rootEl,\n          sortable = _ref9.sortable,\n          dragRect = _ref9.dragRect;\n\n      if (multiDragElements.length > 1) {\n        // Setup unfold animation\n        multiDragElements.forEach(function (multiDragElement) {\n          sortable.addAnimationState({\n            target: multiDragElement,\n            rect: folding ? getRect(multiDragElement) : dragRect\n          });\n          unsetRect(multiDragElement);\n          multiDragElement.fromRect = dragRect;\n          fromSortable.removeAnimationState(multiDragElement);\n        });\n        folding = false;\n        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);\n      }\n    },\n    dragOverCompleted: function dragOverCompleted(_ref10) {\n      var sortable = _ref10.sortable,\n          isOwner = _ref10.isOwner,\n          insertion = _ref10.insertion,\n          activeSortable = _ref10.activeSortable,\n          parentEl = _ref10.parentEl,\n          putSortable = _ref10.putSortable;\n      var options = this.options;\n\n      if (insertion) {\n        // Clones must be hidden before folding animation to capture dragRectAbsolute properly\n        if (isOwner) {\n          activeSortable._hideClone();\n        }\n\n        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location\n\n        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {\n          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible\n          var dragRectAbsolute = getRect(dragEl$1, false, true, true);\n          multiDragElements.forEach(function (multiDragElement) {\n            if (multiDragElement === dragEl$1) return;\n            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted\n            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable\n\n            parentEl.appendChild(multiDragElement);\n          });\n          folding = true;\n        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out\n\n\n        if (!isOwner) {\n          // Only remove if not folding (folding will remove them anyways)\n          if (!folding) {\n            removeMultiDragElements();\n          }\n\n          if (multiDragElements.length > 1) {\n            var clonesHiddenBefore = clonesHidden;\n\n            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden\n\n\n            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {\n              multiDragClones.forEach(function (clone) {\n                activeSortable.addAnimationState({\n                  target: clone,\n                  rect: clonesFromRect\n                });\n                clone.fromRect = clonesFromRect;\n                clone.thisAnimationDuration = null;\n              });\n            }\n          } else {\n            activeSortable._showClone(sortable);\n          }\n        }\n      }\n    },\n    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {\n      var dragRect = _ref11.dragRect,\n          isOwner = _ref11.isOwner,\n          activeSortable = _ref11.activeSortable;\n      multiDragElements.forEach(function (multiDragElement) {\n        multiDragElement.thisAnimationDuration = null;\n      });\n\n      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {\n        clonesFromRect = _extends({}, dragRect);\n        var dragMatrix = matrix(dragEl$1, true);\n        clonesFromRect.top -= dragMatrix.f;\n        clonesFromRect.left -= dragMatrix.e;\n      }\n    },\n    dragOverAnimationComplete: function dragOverAnimationComplete() {\n      if (folding) {\n        folding = false;\n        removeMultiDragElements();\n      }\n    },\n    drop: function drop(_ref12) {\n      var evt = _ref12.originalEvent,\n          rootEl = _ref12.rootEl,\n          parentEl = _ref12.parentEl,\n          sortable = _ref12.sortable,\n          dispatchSortableEvent = _ref12.dispatchSortableEvent,\n          oldIndex = _ref12.oldIndex,\n          putSortable = _ref12.putSortable;\n      var toSortable = putSortable || this.sortable;\n      if (!evt) return;\n      var options = this.options,\n          children = parentEl.children; // Multi-drag selection\n\n      if (!dragStarted) {\n        if (options.multiDragKey && !this.multiDragKeyDown) {\n          this._deselectMultiDrag();\n        }\n\n        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));\n\n        if (!~multiDragElements.indexOf(dragEl$1)) {\n          multiDragElements.push(dragEl$1);\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'select',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          }); // Modifier activated, select from last to dragEl\n\n          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {\n            var lastIndex = index(lastMultiDragSelect),\n                currentIndex = index(dragEl$1);\n\n            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {\n              // Must include lastMultiDragSelect (select it), in case modified selection from no selection\n              // (but previous selection existed)\n              var n, i;\n\n              if (currentIndex > lastIndex) {\n                i = lastIndex;\n                n = currentIndex;\n              } else {\n                i = currentIndex;\n                n = lastIndex + 1;\n              }\n\n              for (; i < n; i++) {\n                if (~multiDragElements.indexOf(children[i])) continue;\n                toggleClass(children[i], options.selectedClass, true);\n                multiDragElements.push(children[i]);\n                dispatchEvent({\n                  sortable: sortable,\n                  rootEl: rootEl,\n                  name: 'select',\n                  targetEl: children[i],\n                  originalEvt: evt\n                });\n              }\n            }\n          } else {\n            lastMultiDragSelect = dragEl$1;\n          }\n\n          multiDragSortable = toSortable;\n        } else {\n          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);\n          lastMultiDragSelect = null;\n          dispatchEvent({\n            sortable: sortable,\n            rootEl: rootEl,\n            name: 'deselect',\n            targetEl: dragEl$1,\n            originalEvt: evt\n          });\n        }\n      } // Multi-drag drop\n\n\n      if (dragStarted && this.isMultiDrag) {\n        // Do not \"unfold\" after around dragEl if reverted\n        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {\n          var dragRect = getRect(dragEl$1),\n              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');\n          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;\n          toSortable.captureAnimationState();\n\n          if (!initialFolding) {\n            if (options.animation) {\n              dragEl$1.fromRect = dragRect;\n              multiDragElements.forEach(function (multiDragElement) {\n                multiDragElement.thisAnimationDuration = null;\n\n                if (multiDragElement !== dragEl$1) {\n                  var rect = folding ? getRect(multiDragElement) : dragRect;\n                  multiDragElement.fromRect = rect; // Prepare unfold animation\n\n                  toSortable.addAnimationState({\n                    target: multiDragElement,\n                    rect: rect\n                  });\n                }\n              });\n            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert\n            // properly they must all be removed\n\n\n            removeMultiDragElements();\n            multiDragElements.forEach(function (multiDragElement) {\n              if (children[multiDragIndex]) {\n                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);\n              } else {\n                parentEl.appendChild(multiDragElement);\n              }\n\n              multiDragIndex++;\n            }); // If initial folding is done, the elements may have changed position because they are now\n            // unfolding around dragEl, even though dragEl may not have his index changed, so update event\n            // must be fired here as Sortable will not.\n\n            if (oldIndex === index(dragEl$1)) {\n              var update = false;\n              multiDragElements.forEach(function (multiDragElement) {\n                if (multiDragElement.sortableIndex !== index(multiDragElement)) {\n                  update = true;\n                  return;\n                }\n              });\n\n              if (update) {\n                dispatchSortableEvent('update');\n              }\n            }\n          } // Must be done after capturing individual rects (scroll bar)\n\n\n          multiDragElements.forEach(function (multiDragElement) {\n            unsetRect(multiDragElement);\n          });\n          toSortable.animateAll();\n        }\n\n        multiDragSortable = toSortable;\n      } // Remove clones if necessary\n\n\n      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {\n        multiDragClones.forEach(function (clone) {\n          clone.parentNode && clone.parentNode.removeChild(clone);\n        });\n      }\n    },\n    nullingGlobal: function nullingGlobal() {\n      this.isMultiDrag = dragStarted = false;\n      multiDragClones.length = 0;\n    },\n    destroyGlobal: function destroyGlobal() {\n      this._deselectMultiDrag();\n\n      off(document, 'pointerup', this._deselectMultiDrag);\n      off(document, 'mouseup', this._deselectMultiDrag);\n      off(document, 'touchend', this._deselectMultiDrag);\n      off(document, 'keydown', this._checkKeyDown);\n      off(document, 'keyup', this._checkKeyUp);\n    },\n    _deselectMultiDrag: function _deselectMultiDrag(evt) {\n      if (typeof dragStarted !== \"undefined\" && dragStarted) return; // Only deselect if selection is in this sortable\n\n      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable\n\n      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click\n\n      if (evt && evt.button !== 0) return;\n\n      while (multiDragElements.length) {\n        var el = multiDragElements[0];\n        toggleClass(el, this.options.selectedClass, false);\n        multiDragElements.shift();\n        dispatchEvent({\n          sortable: this.sortable,\n          rootEl: this.sortable.el,\n          name: 'deselect',\n          targetEl: el,\n          originalEvt: evt\n        });\n      }\n    },\n    _checkKeyDown: function _checkKeyDown(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = true;\n      }\n    },\n    _checkKeyUp: function _checkKeyUp(evt) {\n      if (evt.key === this.options.multiDragKey) {\n        this.multiDragKeyDown = false;\n      }\n    }\n  };\n  return _extends(MultiDrag, {\n    // Static methods & properties\n    pluginName: 'multiDrag',\n    utils: {\n      /**\r\n       * Selects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be selected\r\n       */\n      select: function select(el) {\n        var sortable = el.parentNode[expando];\n        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;\n\n        if (multiDragSortable && multiDragSortable !== sortable) {\n          multiDragSortable.multiDrag._deselectMultiDrag();\n\n          multiDragSortable = sortable;\n        }\n\n        toggleClass(el, sortable.options.selectedClass, true);\n        multiDragElements.push(el);\n      },\n\n      /**\r\n       * Deselects the provided multi-drag item\r\n       * @param  {HTMLElement} el    The element to be deselected\r\n       */\n      deselect: function deselect(el) {\n        var sortable = el.parentNode[expando],\n            index = multiDragElements.indexOf(el);\n        if (!sortable || !sortable.options.multiDrag || !~index) return;\n        toggleClass(el, sortable.options.selectedClass, false);\n        multiDragElements.splice(index, 1);\n      }\n    },\n    eventProperties: function eventProperties() {\n      var _this3 = this;\n\n      var oldIndicies = [],\n          newIndicies = [];\n      multiDragElements.forEach(function (multiDragElement) {\n        oldIndicies.push({\n          multiDragElement: multiDragElement,\n          index: multiDragElement.sortableIndex\n        }); // multiDragElements will already be sorted if folding\n\n        var newIndex;\n\n        if (folding && multiDragElement !== dragEl$1) {\n          newIndex = -1;\n        } else if (folding) {\n          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');\n        } else {\n          newIndex = index(multiDragElement);\n        }\n\n        newIndicies.push({\n          multiDragElement: multiDragElement,\n          index: newIndex\n        });\n      });\n      return {\n        items: _toConsumableArray(multiDragElements),\n        clones: [].concat(multiDragClones),\n        oldIndicies: oldIndicies,\n        newIndicies: newIndicies\n      };\n    },\n    optionListeners: {\n      multiDragKey: function multiDragKey(key) {\n        key = key.toLowerCase();\n\n        if (key === 'ctrl') {\n          key = 'Control';\n        } else if (key.length > 1) {\n          key = key.charAt(0).toUpperCase() + key.substr(1);\n        }\n\n        return key;\n      }\n    }\n  });\n}\n\nfunction insertMultiDragElements(clonesInserted, rootEl) {\n  multiDragElements.forEach(function (multiDragElement, i) {\n    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(multiDragElement, target);\n    } else {\n      rootEl.appendChild(multiDragElement);\n    }\n  });\n}\n/**\r\n * Insert multi-drag clones\r\n * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted\r\n * @param  {HTMLElement} rootEl\r\n */\n\n\nfunction insertMultiDragClones(elementsInserted, rootEl) {\n  multiDragClones.forEach(function (clone, i) {\n    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];\n\n    if (target) {\n      rootEl.insertBefore(clone, target);\n    } else {\n      rootEl.appendChild(clone);\n    }\n  });\n}\n\nfunction removeMultiDragElements() {\n  multiDragElements.forEach(function (multiDragElement) {\n    if (multiDragElement === dragEl$1) return;\n    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);\n  });\n}\n\nSortable.mount(new AutoScrollPlugin());\nSortable.mount(Remove, Revert);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvbW9kdWxhci9zb3J0YWJsZS5lc20uanM/YWE0NyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvckVhY2giLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyMiIsIml0ZXIiLCJ0b1N0cmluZyIsImZyb20iLCJUeXBlRXJyb3IiLCJ2ZXJzaW9uIiwidXNlckFnZW50IiwicGF0dGVybiIsIndpbmRvdyIsIm5hdmlnYXRvciIsIm1hdGNoIiwiSUUxMU9yTGVzcyIsIkVkZ2UiLCJGaXJlRm94IiwiU2FmYXJpIiwiSU9TIiwiQ2hyb21lRm9yQW5kcm9pZCIsImNhcHR1cmVNb2RlIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJvbiIsImVsIiwiZXZlbnQiLCJmbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvZmYiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibWF0Y2hlcyIsInNlbGVjdG9yIiwic3Vic3RyaW5nIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJfIiwiZ2V0UGFyZW50T3JIb3N0IiwiaG9zdCIsImRvY3VtZW50Iiwibm9kZVR5cGUiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsImN0eCIsImluY2x1ZGVDVFgiLCJSX1NQQUNFIiwidG9nZ2xlQ2xhc3MiLCJuYW1lIiwic3RhdGUiLCJjbGFzc0xpc3QiLCJjbGFzc05hbWUiLCJyZXBsYWNlIiwiY3NzIiwicHJvcCIsInZhbCIsInN0eWxlIiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwiY3VycmVudFN0eWxlIiwibWF0cml4Iiwic2VsZk9ubHkiLCJhcHBsaWVkVHJhbnNmb3JtcyIsInRyYW5zZm9ybSIsIm1hdHJpeEZuIiwiRE9NTWF0cml4IiwiV2ViS2l0Q1NTTWF0cml4IiwiQ1NTTWF0cml4IiwiTVNDU1NNYXRyaXgiLCJmaW5kIiwidGFnTmFtZSIsImxpc3QiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm4iLCJnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50Iiwic2Nyb2xsaW5nRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImdldFJlY3QiLCJyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIiwicmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCIsInVuZG9TY2FsZSIsImNvbnRhaW5lciIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsImhlaWdodCIsIndpZHRoIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiY29udGFpbmVyUmVjdCIsInBhcnNlSW50IiwiZWxNYXRyaXgiLCJzY2FsZVgiLCJhIiwic2NhbGVZIiwiZCIsImlzU2Nyb2xsZWRQYXN0IiwiZWxTaWRlIiwicGFyZW50U2lkZSIsInBhcmVudCIsImdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50IiwiZWxTaWRlVmFsIiwicGFyZW50U2lkZVZhbCIsInZpc2libGUiLCJnZXRDaGlsZCIsImNoaWxkTnVtIiwib3B0aW9ucyIsImN1cnJlbnRDaGlsZCIsImNoaWxkcmVuIiwiZGlzcGxheSIsIlNvcnRhYmxlIiwiZ2hvc3QiLCJkcmFnZ2VkIiwiZHJhZ2dhYmxlIiwibGFzdENoaWxkIiwibGFzdCIsImxhc3RFbGVtZW50Q2hpbGQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiaW5kZXgiLCJub2RlTmFtZSIsInRvVXBwZXJDYXNlIiwiY2xvbmUiLCJnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJ3aW5TY3JvbGxlciIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJpbmRleE9mT2JqZWN0IiwiTnVtYmVyIiwiaW5jbHVkZVNlbGYiLCJlbGVtIiwiZ290U2VsZiIsImNsaWVudFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJlbGVtQ1NTIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiYm9keSIsImV4dGVuZCIsImRzdCIsInNyYyIsImlzUmVjdEVxdWFsIiwicmVjdDEiLCJyZWN0MiIsIk1hdGgiLCJyb3VuZCIsIl90aHJvdHRsZVRpbWVvdXQiLCJ0aHJvdHRsZSIsImNhbGxiYWNrIiwibXMiLCJhcmdzIiwiX3RoaXMiLCJzZXRUaW1lb3V0IiwiY2FuY2VsVGhyb3R0bGUiLCJjbGVhclRpbWVvdXQiLCJzY3JvbGxCeSIsIngiLCJ5IiwiUG9seW1lciIsIiQiLCJqUXVlcnkiLCJaZXB0byIsImRvbSIsImNsb25lTm9kZSIsInNldFJlY3QiLCJyZWN0IiwidW5zZXRSZWN0IiwiZXhwYW5kbyIsIkRhdGUiLCJnZXRUaW1lIiwiQW5pbWF0aW9uU3RhdGVNYW5hZ2VyIiwiYW5pbWF0aW9uU3RhdGVzIiwiYW5pbWF0aW9uQ2FsbGJhY2tJZCIsImNhcHR1cmVBbmltYXRpb25TdGF0ZSIsImFuaW1hdGlvbiIsInNsaWNlIiwiY2hpbGQiLCJwdXNoIiwiZnJvbVJlY3QiLCJ0aGlzQW5pbWF0aW9uRHVyYXRpb24iLCJjaGlsZE1hdHJpeCIsImYiLCJlIiwiYWRkQW5pbWF0aW9uU3RhdGUiLCJyZW1vdmVBbmltYXRpb25TdGF0ZSIsInNwbGljZSIsImFuaW1hdGVBbGwiLCJhbmltYXRpbmciLCJhbmltYXRpb25UaW1lIiwidGltZSIsInRvUmVjdCIsInByZXZGcm9tUmVjdCIsInByZXZUb1JlY3QiLCJhbmltYXRpbmdSZWN0IiwidGFyZ2V0TWF0cml4IiwiY2FsY3VsYXRlUmVhbFRpbWUiLCJhbmltYXRlIiwibWF4IiwiYW5pbWF0aW9uUmVzZXRUaW1lciIsImN1cnJlbnRSZWN0IiwiZHVyYXRpb24iLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImFuaW1hdGluZ1giLCJhbmltYXRpbmdZIiwiZm9yUmVwYWludER1bW15IiwicmVwYWludCIsImVhc2luZyIsImFuaW1hdGVkIiwib2Zmc2V0V2lkdGgiLCJzcXJ0IiwicG93IiwicGx1Z2lucyIsImRlZmF1bHRzIiwiaW5pdGlhbGl6ZUJ5RGVmYXVsdCIsIlBsdWdpbk1hbmFnZXIiLCJtb3VudCIsInBsdWdpbiIsIm9wdGlvbiIsInAiLCJwbHVnaW5OYW1lIiwicGx1Z2luRXZlbnQiLCJldmVudE5hbWUiLCJzb3J0YWJsZSIsImV2dCIsImV2ZW50Q2FuY2VsZWQiLCJjYW5jZWwiLCJldmVudE5hbWVHbG9iYWwiLCJpbml0aWFsaXplUGx1Z2lucyIsImluaXRpYWxpemVkIiwibW9kaWZpZWQiLCJtb2RpZnlPcHRpb24iLCJnZXRFdmVudFByb3BlcnRpZXMiLCJldmVudFByb3BlcnRpZXMiLCJtb2RpZmllZFZhbHVlIiwib3B0aW9uTGlzdGVuZXJzIiwiZGlzcGF0Y2hFdmVudCIsIl9yZWYiLCJyb290RWwiLCJ0YXJnZXRFbCIsImNsb25lRWwiLCJ0b0VsIiwiZnJvbUVsIiwib2xkSW5kZXgiLCJuZXdJbmRleCIsIm9sZERyYWdnYWJsZUluZGV4IiwibmV3RHJhZ2dhYmxlSW5kZXgiLCJvcmlnaW5hbEV2ZW50IiwicHV0U29ydGFibGUiLCJleHRyYUV2ZW50UHJvcGVydGllcyIsIm9uTmFtZSIsImNoYXJBdCIsInN1YnN0ciIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsInRvIiwiaXRlbSIsInB1bGxNb2RlIiwibGFzdFB1dE1vZGUiLCJ1bmRlZmluZWQiLCJhbGxFdmVudFByb3BlcnRpZXMiLCJkYXRhIiwiYmluZCIsImRyYWdFbCIsInBhcmVudEVsIiwiZ2hvc3RFbCIsIm5leHRFbCIsImxhc3REb3duRWwiLCJjbG9uZUhpZGRlbiIsImRyYWdTdGFydGVkIiwibW92ZWQiLCJhY3RpdmVTb3J0YWJsZSIsImFjdGl2ZSIsImhpZGVHaG9zdEZvclRhcmdldCIsIl9oaWRlR2hvc3RGb3JUYXJnZXQiLCJ1bmhpZGVHaG9zdEZvclRhcmdldCIsIl91bmhpZGVHaG9zdEZvclRhcmdldCIsImNsb25lTm93SGlkZGVuIiwiY2xvbmVOb3dTaG93biIsImRpc3BhdGNoU29ydGFibGVFdmVudCIsIl9kaXNwYXRjaEV2ZW50IiwiaW5mbyIsImFjdGl2ZUdyb3VwIiwiYXdhaXRpbmdEcmFnU3RhcnRlZCIsImlnbm9yZU5leHRDbGljayIsInNvcnRhYmxlcyIsInRhcEV2dCIsInRvdWNoRXZ0IiwibGFzdER4IiwibGFzdER5IiwidGFwRGlzdGFuY2VMZWZ0IiwidGFwRGlzdGFuY2VUb3AiLCJsYXN0VGFyZ2V0IiwibGFzdERpcmVjdGlvbiIsInBhc3RGaXJzdEludmVydFRocmVzaCIsImlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQiLCJ0YXJnZXRNb3ZlRGlzdGFuY2UiLCJnaG9zdFJlbGF0aXZlUGFyZW50IiwiZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGwiLCJfc2lsZW50Iiwic2F2ZWRJbnB1dENoZWNrZWQiLCJkb2N1bWVudEV4aXN0cyIsIlBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5IiwiQ1NTRmxvYXRQcm9wZXJ0eSIsInN1cHBvcnREcmFnZ2FibGUiLCJjcmVhdGVFbGVtZW50Iiwic3VwcG9ydENzc1BvaW50ZXJFdmVudHMiLCJjc3NUZXh0IiwicG9pbnRlckV2ZW50cyIsIl9kZXRlY3REaXJlY3Rpb24iLCJlbENTUyIsImVsV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJjaGlsZDEiLCJjaGlsZDIiLCJmaXJzdENoaWxkQ1NTIiwic2Vjb25kQ2hpbGRDU1MiLCJmaXJzdENoaWxkV2lkdGgiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJzZWNvbmRDaGlsZFdpZHRoIiwiZmxleERpcmVjdGlvbiIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJzcGxpdCIsInRvdWNoaW5nU2lkZUNoaWxkMiIsImNsZWFyIiwiX2RyYWdFbEluUm93Q29sdW1uIiwiZHJhZ1JlY3QiLCJ0YXJnZXRSZWN0IiwidmVydGljYWwiLCJkcmFnRWxTMU9wcCIsImRyYWdFbFMyT3BwIiwiZHJhZ0VsT3BwTGVuZ3RoIiwidGFyZ2V0UzFPcHAiLCJ0YXJnZXRTMk9wcCIsInRhcmdldE9wcExlbmd0aCIsIl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSIsInJldCIsInNvbWUiLCJ0aHJlc2hvbGQiLCJlbXB0eUluc2VydFRocmVzaG9sZCIsImluc2lkZUhvcml6b250YWxseSIsImluc2lkZVZlcnRpY2FsbHkiLCJfcHJlcGFyZUdyb3VwIiwidG9GbiIsInB1bGwiLCJzYW1lR3JvdXAiLCJncm91cCIsIm90aGVyR3JvdXAiLCJqb2luIiwib3JpZ2luYWxHcm91cCIsImNoZWNrUHVsbCIsImNoZWNrUHV0IiwicHV0IiwicmV2ZXJ0Q2xvbmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIm5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50IiwidG91Y2hlcyIsIm5lYXJlc3QiLCJjbGllbnRYIiwiY2xpZW50WSIsIl9vbkRyYWdPdmVyIiwiX2NoZWNrT3V0c2lkZVRhcmdldEVsIiwiX2lzT3V0c2lkZVRoaXNFbCIsInNvcnQiLCJkaXNhYmxlZCIsInN0b3JlIiwiaGFuZGxlIiwidGVzdCIsInN3YXBUaHJlc2hvbGQiLCJpbnZlcnRTd2FwIiwiaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIiwicmVtb3ZlQ2xvbmVPbkhpZGUiLCJkaXJlY3Rpb24iLCJnaG9zdENsYXNzIiwiY2hvc2VuQ2xhc3MiLCJkcmFnQ2xhc3MiLCJpZ25vcmUiLCJwcmV2ZW50T25GaWx0ZXIiLCJzZXREYXRhIiwiZGF0YVRyYW5zZmVyIiwidGV4dENvbnRlbnQiLCJkcm9wQnViYmxlIiwiZHJhZ292ZXJCdWJibGUiLCJkYXRhSWRBdHRyIiwiZGVsYXkiLCJkZWxheU9uVG91Y2hPbmx5IiwidG91Y2hTdGFydFRocmVzaG9sZCIsImRldmljZVBpeGVsUmF0aW8iLCJmb3JjZUZhbGxiYWNrIiwiZmFsbGJhY2tDbGFzcyIsImZhbGxiYWNrT25Cb2R5IiwiZmFsbGJhY2tUb2xlcmFuY2UiLCJmYWxsYmFja09mZnNldCIsInN1cHBvcnRQb2ludGVyIiwibmF0aXZlRHJhZ2dhYmxlIiwiX29uVGFwU3RhcnQiLCJnZXQiLCJjb250YWlucyIsIl9nZXREaXJlY3Rpb24iLCJ0eXBlIiwidG91Y2giLCJwb2ludGVyVHlwZSIsIm9yaWdpbmFsVGFyZ2V0Iiwic2hhZG93Um9vdCIsInBhdGgiLCJjb21wb3NlZFBhdGgiLCJfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlIiwiYnV0dG9uIiwiaXNDb250ZW50RWRpdGFibGUiLCJjcml0ZXJpYSIsInRyaW0iLCJfcHJlcGFyZURyYWdTdGFydCIsIm93bmVyRG9jdW1lbnQiLCJkcmFnU3RhcnRGbiIsIm5leHRTaWJsaW5nIiwiX2xhc3RYIiwiX2xhc3RZIiwiX29uRHJvcCIsIl9kaXNhYmxlRGVsYXllZERyYWdFdmVudHMiLCJfdHJpZ2dlckRyYWdTdGFydCIsIl9kaXNhYmxlRHJhZ2dhYmxlIiwiX2Rpc2FibGVEZWxheWVkRHJhZyIsIl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIiLCJfZHJhZ1N0YXJ0VGltZXIiLCJhYnMiLCJmbG9vciIsIl9vblRvdWNoTW92ZSIsIl9vbkRyYWdTdGFydCIsInNlbGVjdGlvbiIsIl9uZXh0VGljayIsImVtcHR5IiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiZXJyIiwiX2RyYWdTdGFydGVkIiwiZmFsbGJhY2siLCJfYXBwZW5kR2hvc3QiLCJfbnVsbGluZyIsIl9lbXVsYXRlRHJhZ092ZXIiLCJlbGVtZW50RnJvbVBvaW50IiwiaW5zZXJ0ZWQiLCJnaG9zdE1hdHJpeCIsInJlbGF0aXZlU2Nyb2xsT2Zmc2V0IiwiZHgiLCJkeSIsImIiLCJjIiwiY3NzTWF0cml4IiwiYXBwZW5kQ2hpbGQiLCJfaGlkZUNsb25lIiwiY2xvbmVJZCIsImluc2VydEJlZm9yZSIsIl9sb29wSWQiLCJzZXRJbnRlcnZhbCIsImVmZmVjdEFsbG93ZWQiLCJfZHJhZ1N0YXJ0SWQiLCJyZXZlcnQiLCJpc093bmVyIiwiY2FuU29ydCIsImZyb21Tb3J0YWJsZSIsImNvbXBsZXRlZEZpcmVkIiwiZHJhZ092ZXJFdmVudCIsImV4dHJhIiwiYXhpcyIsImNvbXBsZXRlZCIsIm9uTW92ZSIsImFmdGVyIiwiX29uTW92ZSIsImNoYW5nZWQiLCJpbnNlcnRpb24iLCJfc2hvd0Nsb25lIiwiX2lnbm9yZVdoaWxlQW5pbWF0aW5nIiwiZWxMYXN0Q2hpbGQiLCJfZ2hvc3RJc0xhc3QiLCJ0YXJnZXRCZWZvcmVGaXJzdFN3YXAiLCJkaWZmZXJlbnRMZXZlbCIsImRpZmZlcmVudFJvd0NvbCIsInNpZGUxIiwic2Nyb2xsZWRQYXN0VG9wIiwic2Nyb2xsQmVmb3JlIiwiX2dldFN3YXBEaXJlY3Rpb24iLCJzaWJsaW5nIiwiZHJhZ0luZGV4IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibW92ZVZlY3RvciIsIl91bnNpbGVudCIsIl9vZmZNb3ZlRXZlbnRzIiwiX29mZlVwRXZlbnRzIiwiY2xlYXJJbnRlcnZhbCIsIl9jYW5jZWxOZXh0VGljayIsInJlbW92ZUNoaWxkIiwic2F2ZSIsImNoZWNrZWQiLCJoYW5kbGVFdmVudCIsIl9nbG9iYWxEcmFnT3ZlciIsInRvQXJyYXkiLCJvcmRlciIsImdldEF0dHJpYnV0ZSIsIl9nZW5lcmF0ZUlkIiwidXNlQW5pbWF0aW9uIiwiaXRlbXMiLCJpZCIsInNldCIsImNsb3Nlc3QkMSIsImRlc3Ryb3kiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVtb3ZlQXR0cmlidXRlIiwiZHJvcEVmZmVjdCIsIndpbGxJbnNlcnRBZnRlciIsIm9uTW92ZUZuIiwicmV0VmFsIiwiZHJhZ2dlZFJlY3QiLCJyZWxhdGVkIiwicmVsYXRlZFJlY3QiLCJzcGFjZXIiLCJpc0xhc3RUYXJnZXQiLCJtb3VzZU9uQXhpcyIsInRhcmdldExlbmd0aCIsInRhcmdldFMxIiwidGFyZ2V0UzIiLCJpbnZlcnQiLCJfZ2V0SW5zZXJ0RGlyZWN0aW9uIiwic3RyIiwiaHJlZiIsInN1bSIsImNoYXJDb2RlQXQiLCJyb290IiwiaW5wdXRzIiwiaWR4IiwidXRpbHMiLCJpcyIsIm5leHRUaWNrIiwiY2FuY2VsTmV4dFRpY2siLCJkZXRlY3REaXJlY3Rpb24iLCJlbGVtZW50IiwiX2xlbiIsIl9rZXkiLCJjcmVhdGUiLCJhdXRvU2Nyb2xscyIsInNjcm9sbEVsIiwic2Nyb2xsUm9vdEVsIiwic2Nyb2xsaW5nIiwibGFzdEF1dG9TY3JvbGxYIiwibGFzdEF1dG9TY3JvbGxZIiwidG91Y2hFdnQkMSIsInBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsIiwiQXV0b1Njcm9sbFBsdWdpbiIsIkF1dG9TY3JvbGwiLCJzY3JvbGwiLCJzY3JvbGxTZW5zaXRpdml0eSIsInNjcm9sbFNwZWVkIiwiYnViYmxlU2Nyb2xsIiwiX2hhbmRsZUF1dG9TY3JvbGwiLCJfaGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsIiwiZHJhZ092ZXJDb21wbGV0ZWQiLCJfcmVmMiIsImRyYWdPdmVyQnViYmxlIiwiZHJvcCIsImNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwiLCJjbGVhckF1dG9TY3JvbGxzIiwibnVsbGluZyIsImF1dG9TY3JvbGwiLCJvZ0VsZW1TY3JvbGxlciIsIm5ld0VsZW0iLCJwaWQiLCJpc0ZhbGxiYWNrIiwic2VucyIsInNwZWVkIiwic2Nyb2xsVGhpc0luc3RhbmNlIiwic2Nyb2xsQ3VzdG9tRm4iLCJzY3JvbGxGbiIsImxheWVyc091dCIsImN1cnJlbnRQYXJlbnQiLCJjYW5TY3JvbGxYIiwiY2FuU2Nyb2xsWSIsInNjcm9sbFBvc1giLCJzY3JvbGxQb3NZIiwidngiLCJ2eSIsImxheWVyIiwic2Nyb2xsT2Zmc2V0WSIsInNjcm9sbE9mZnNldFgiLCJ0b1NvcnRhYmxlIiwiY2hhbmdlZFRvdWNoZXMiLCJvblNwaWxsIiwiUmV2ZXJ0Iiwic3RhcnRJbmRleCIsImRyYWdTdGFydCIsIl9yZWYzIiwiUmVtb3ZlIiwiX3JlZjQiLCJwYXJlbnRTb3J0YWJsZSIsImxhc3RTd2FwRWwiLCJTd2FwUGx1Z2luIiwiU3dhcCIsInN3YXBDbGFzcyIsImRyYWdPdmVyVmFsaWQiLCJzd2FwIiwicHJldlN3YXBFbCIsInN3YXBOb2RlcyIsInN3YXBJdGVtIiwibjEiLCJuMiIsInAxIiwicDIiLCJpMSIsImkyIiwiaXNFcXVhbE5vZGUiLCJtdWx0aURyYWdFbGVtZW50cyIsIm11bHRpRHJhZ0Nsb25lcyIsImxhc3RNdWx0aURyYWdTZWxlY3QiLCJtdWx0aURyYWdTb3J0YWJsZSIsImluaXRpYWxGb2xkaW5nIiwiZm9sZGluZyIsImRyYWdFbCQxIiwiY2xvbmVzRnJvbVJlY3QiLCJjbG9uZXNIaWRkZW4iLCJNdWx0aURyYWdQbHVnaW4iLCJNdWx0aURyYWciLCJfZGVzZWxlY3RNdWx0aURyYWciLCJfY2hlY2tLZXlEb3duIiwiX2NoZWNrS2V5VXAiLCJzZWxlY3RlZENsYXNzIiwibXVsdGlEcmFnS2V5IiwibXVsdGlEcmFnRWxlbWVudCIsIm11bHRpRHJhZ0tleURvd24iLCJpc011bHRpRHJhZyIsImRlbGF5U3RhcnRHbG9iYWwiLCJkZWxheUVuZGVkIiwic2V0dXBDbG9uZSIsInNvcnRhYmxlSW5kZXgiLCJpbnNlcnRNdWx0aURyYWdDbG9uZXMiLCJzaG93Q2xvbmUiLCJoaWRlQ2xvbmUiLCJfcmVmNSIsImRyYWdTdGFydEdsb2JhbCIsIl9yZWY2IiwibXVsdGlEcmFnIiwiX3JlZjciLCJfdGhpczIiLCJyZW1vdmVNdWx0aURyYWdFbGVtZW50cyIsImRyYWdPdmVyIiwiX3JlZjgiLCJfcmVmOSIsImluc2VydE11bHRpRHJhZ0VsZW1lbnRzIiwiX3JlZjEwIiwiZHJhZ1JlY3RBYnNvbHV0ZSIsImNsb25lc0hpZGRlbkJlZm9yZSIsImRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZSIsIl9yZWYxMSIsImRyYWdNYXRyaXgiLCJkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlIiwiX3JlZjEyIiwib3JpZ2luYWxFdnQiLCJzaGlmdEtleSIsImxhc3RJbmRleCIsImN1cnJlbnRJbmRleCIsIm11bHRpRHJhZ0luZGV4IiwidXBkYXRlIiwibnVsbGluZ0dsb2JhbCIsImRlc3Ryb3lHbG9iYWwiLCJzaGlmdCIsInNlbGVjdCIsImRlc2VsZWN0IiwiX3RoaXMzIiwib2xkSW5kaWNpZXMiLCJuZXdJbmRpY2llcyIsImNsb25lcyIsInRvTG93ZXJDYXNlIiwiY2xvbmVzSW5zZXJ0ZWQiLCJlbGVtZW50c0luc2VydGVkIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEIsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQ0MsUUFBZCxLQUEyQixRQUEvRCxFQUF5RTtBQUN2RUgsV0FBTyxHQUFHLFVBQVVDLEdBQVYsRUFBZTtBQUN2QixhQUFPLE9BQU9BLEdB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dUJKLE1BQXZCO0FBRUEsaUVBQWV2ZSxRQUFmIiwiZmlsZSI6IjI4MTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBTb3J0YWJsZSAxLjEzLjBcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGF1dGhvclx0b3dlbm0gICAgPG93ZW4yMzM1NUBnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS4xMy4wXCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhXG4gICAgLypAX19QVVJFX18qL1xuICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gocGF0dGVybik7XG4gIH1cbn1cblxudmFyIElFMTFPckxlc3MgPSB1c2VyQWdlbnQoLyg/OlRyaWRlbnQuKnJ2WyA6XT8xMVxcLnxtc2llfGllbW9iaWxlfFdpbmRvd3MgUGhvbmUpL2kpO1xudmFyIEVkZ2UgPSB1c2VyQWdlbnQoL0VkZ2UvaSk7XG52YXIgRmlyZUZveCA9IHVzZXJBZ2VudCgvZmlyZWZveC9pKTtcbnZhciBTYWZhcmkgPSB1c2VyQWdlbnQoL3NhZmFyaS9pKSAmJiAhdXNlckFnZW50KC9jaHJvbWUvaSkgJiYgIXVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcbnZhciBJT1MgPSB1c2VyQWdlbnQoL2lQKGFkfG9kfGhvbmUpL2kpO1xudmFyIENocm9tZUZvckFuZHJvaWQgPSB1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiB1c2VyQWdlbnQoL2FuZHJvaWQvaSk7XG5cbnZhciBjYXB0dXJlTW9kZSA9IHtcbiAgY2FwdHVyZTogZmFsc2UsXG4gIHBhc3NpdmU6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcikge1xuICBpZiAoIXNlbGVjdG9yKSByZXR1cm47XG4gIHNlbGVjdG9yWzBdID09PSAnPicgJiYgKHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyaW5nKDEpKTtcblxuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50T3JIb3N0KGVsKSB7XG4gIHJldHVybiBlbC5ob3N0ICYmIGVsICE9PSBkb2N1bWVudCAmJiBlbC5ob3N0Lm5vZGVUeXBlID8gZWwuaG9zdCA6IGVsLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNsb3Nlc3QoXG4vKipIVE1MRWxlbWVudCovXG5lbCxcbi8qKlN0cmluZyovXG5zZWxlY3Rvcixcbi8qKkhUTUxFbGVtZW50Ki9cbmN0eCwgaW5jbHVkZUNUWCkge1xuICBpZiAoZWwpIHtcbiAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCAmJiAoc2VsZWN0b3JbMF0gPT09ICc+JyA/IGVsLnBhcmVudE5vZGUgPT09IGN0eCAmJiBtYXRjaGVzKGVsLCBzZWxlY3RvcikgOiBtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHx8IGluY2x1ZGVDVFggJiYgZWwgPT09IGN0eCkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCA9PT0gY3R4KSBicmVhaztcbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlIChlbCA9IGdldFBhcmVudE9ySG9zdChlbCkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSX1NQQUNFID0gL1xccysvZztcblxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWwsIG5hbWUsIHN0YXRlKSB7XG4gIGlmIChlbCAmJiBuYW1lKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKFJfU1BBQ0UsICcgJykucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuICAgICAgZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgICB2YWwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wID09PSB2b2lkIDAgPyB2YWwgOiB2YWxbcHJvcF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHByb3AgaW4gc3R5bGUpICYmIHByb3AuaW5kZXhPZignd2Via2l0JykgPT09IC0xKSB7XG4gICAgICAgIHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRyaXgoZWwsIHNlbGZPbmx5KSB7XG4gIHZhciBhcHBsaWVkVHJhbnNmb3JtcyA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBwbGllZFRyYW5zZm9ybXMgPSBlbDtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gY3NzKGVsLCAndHJhbnNmb3JtJyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICAgIH0gd2hpbGUgKCFzZWxmT25seSAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICB2YXIgbWF0cml4Rm4gPSB3aW5kb3cuRE9NTWF0cml4IHx8IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggfHwgd2luZG93LkNTU01hdHJpeCB8fCB3aW5kb3cuTVNDU1NNYXRyaXg7XG4gIC8qanNoaW50IC1XMDU2ICovXG5cbiAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG59XG5cbmZ1bmN0aW9uIGZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuICBpZiAoY3R4KSB7XG4gICAgdmFyIGxpc3QgPSBjdHguZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGxpc3RbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkge1xuICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG5cbiAgaWYgKHNjcm9sbGluZ0VsZW1lbnQpIHtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgICAgICAgICAgICAgICAgIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nQ2xpZW50UmVjdCBpcyB3YW50ZWRcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gcmVsYXRpdmVUb0NvbnRhaW5pbmdCbG9jayAgV2hldGhlciB0aGUgcmVjdCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcgYmxvY2sgb2YgKGluY2x1ZGluZykgdGhlIGNvbnRhaW5lclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gdW5kb1NjYWxlICAgICAgICAgICAgICAgICAgV2hldGhlciB0aGUgY29udGFpbmVyJ3Mgc2NhbGUoKSBzaG91bGQgYmUgdW5kb25lXG4gKiBAcGFyYW0gIHtbSFRNTEVsZW1lbnRdfSBjb250YWluZXIgICAgICAgICAgICAgIFRoZSBwYXJlbnQgdGhlIGVsZW1lbnQgd2lsbCBiZSBwbGFjZWQgaW5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFJlY3QoZWwsIHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2ssIHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQsIHVuZG9TY2FsZSwgY29udGFpbmVyKSB7XG4gIGlmICghZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsICE9PSB3aW5kb3cpIHJldHVybjtcbiAgdmFyIGVsUmVjdCwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBoZWlnaHQsIHdpZHRoO1xuXG4gIGlmIChlbCAhPT0gd2luZG93ICYmIGVsLnBhcmVudE5vZGUgJiYgZWwgIT09IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKSkge1xuICAgIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRvcCA9IGVsUmVjdC50b3A7XG4gICAgbGVmdCA9IGVsUmVjdC5sZWZ0O1xuICAgIGJvdHRvbSA9IGVsUmVjdC5ib3R0b207XG4gICAgcmlnaHQgPSBlbFJlY3QucmlnaHQ7XG4gICAgaGVpZ2h0ID0gZWxSZWN0LmhlaWdodDtcbiAgICB3aWR0aCA9IGVsUmVjdC53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAwO1xuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7IC8vIHNvbHZlcyAjMTEyMyAoc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc5NTM4MDYvNjA4ODMxMilcbiAgICAvLyBOb3QgbmVlZGVkIG9uIDw9IElFMTFcblxuICAgIGlmICghSUUxMU9yTGVzcykge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGNzcyhjb250YWluZXIsICd0cmFuc2Zvcm0nKSAhPT0gJ25vbmUnIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQgJiYgY3NzKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJykgIT09ICdzdGF0aWMnKSkge1xuICAgICAgICAgIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG5cbiAgICAgICAgICB0b3AgLT0gY29udGFpbmVyUmVjdC50b3AgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLXRvcC13aWR0aCcpKTtcbiAgICAgICAgICBsZWZ0IC09IGNvbnRhaW5lclJlY3QubGVmdCArIHBhcnNlSW50KGNzcyhjb250YWluZXIsICdib3JkZXItbGVmdC13aWR0aCcpKTtcbiAgICAgICAgICBib3R0b20gPSB0b3AgKyBlbFJlY3QuaGVpZ2h0O1xuICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIGVsUmVjdC53aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgYm9zczp0cnVlICovXG5cbiAgICAgIH0gd2hpbGUgKGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgICAgc2NhbGVYID0gZWxNYXRyaXggJiYgZWxNYXRyaXguYSxcbiAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZDtcblxuICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICByaWdodDogcmlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHNpZGUgb2YgYW4gZWxlbWVudCBpcyBzY3JvbGxlZCBwYXN0IGEgc2lkZSBvZiBpdHMgcGFyZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbCAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvJ3Mgc2lkZSBiZWluZyBzY3JvbGxlZCBvdXQgb2YgdmlldyBpcyBpbiBxdWVzdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIHBhcmVudFNpZGUgICBTaWRlIG9mIHRoZSBwYXJlbnQgaW4gcXVlc3Rpb24gKCd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nKVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgVGhlIHBhcmVudCBzY3JvbGwgZWxlbWVudCB0aGF0IHRoZSBlbCdzIHNpZGUgaXMgc2Nyb2xsZWQgcGFzdCwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBzdWNoIGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRQYXN0KGVsLCBlbFNpZGUsIHBhcmVudFNpZGUpIHtcbiAgdmFyIHBhcmVudCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCB0cnVlKSxcbiAgICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICAgIHZpc2libGUgPSB2b2lkIDA7XG5cbiAgICBpZiAocGFyZW50U2lkZSA9PT0gJ3RvcCcgfHwgcGFyZW50U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICB2aXNpYmxlID0gZWxTaWRlVmFsID49IHBhcmVudFNpZGVWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPD0gcGFyZW50U2lkZVZhbDtcbiAgICB9XG5cbiAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogR2V0cyBudGggY2hpbGQgb2YgZWwsIGlnbm9yaW5nIGhpZGRlbiBjaGlsZHJlbiwgc29ydGFibGUncyBlbGVtZW50cyAoZG9lcyBub3QgaWdub3JlIGNsb25lIGlmIGl0J3MgdmlzaWJsZSlcbiAqIGFuZCBub24tZHJhZ2dhYmxlIGVsZW1lbnRzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGNoaWxkTnVtICAgICAgVGhlIGluZGV4IG9mIHRoZSBjaGlsZFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zICAgICAgIFBhcmVudCBTb3J0YWJsZSdzIG9wdGlvbnNcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDaGlsZChlbCwgY2hpbGROdW0sIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRDaGlsZCA9IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG5cbiAgd2hpbGUgKGkgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpZiAoY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIGNoaWxkcmVuW2ldICE9PSBTb3J0YWJsZS5naG9zdCAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZHJhZ2dlZCAmJiBjbG9zZXN0KGNoaWxkcmVuW2ldLCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgaWYgKGN1cnJlbnRDaGlsZCA9PT0gY2hpbGROdW0pIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Q2hpbGQrKztcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgZWwsIGlnbm9yaW5nIGdob3N0RWwgb3IgaW52aXNpYmxlIGVsZW1lbnRzIChjbG9uZXMpXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgUGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSAge3NlbGVjdG9yfSBzZWxlY3RvciAgICBBbnkgb3RoZXIgZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgaWdub3JlZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBsYXN0IGNoaWxkLCBpZ25vcmluZyBnaG9zdEVsXG4gKi9cblxuXG5mdW5jdGlvbiBsYXN0Q2hpbGQoZWwsIHNlbGVjdG9yKSB7XG4gIHZhciBsYXN0ID0gZWwubGFzdEVsZW1lbnRDaGlsZDtcblxuICB3aGlsZSAobGFzdCAmJiAobGFzdCA9PT0gU29ydGFibGUuZ2hvc3QgfHwgY3NzKGxhc3QsICdkaXNwbGF5JykgPT09ICdub25lJyB8fCBzZWxlY3RvciAmJiAhbWF0Y2hlcyhsYXN0LCBzZWxlY3RvcikpKSB7XG4gICAgbGFzdCA9IGxhc3QucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0IHx8IG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIGFuIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnQgZm9yIGEgc2VsZWN0ZWQgc2V0IG9mXG4gKiBlbGVtZW50c1xuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3JcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4KGVsLCBzZWxlY3Rvcikge1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG5cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnICYmIGVsICE9PSBTb3J0YWJsZS5jbG9uZSAmJiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGwgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50LCBhZGRlZCB3aXRoIGFsbCB0aGUgc2Nyb2xsIG9mZnNldHMgb2YgcGFyZW50IGVsZW1lbnRzLlxuICogVGhlIHZhbHVlIGlzIHJldHVybmVkIGluIHJlYWwgcGl4ZWxzLlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgT2Zmc2V0cyBpbiB0aGUgZm9ybWF0IG9mIFtsZWZ0LCB0b3BdXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xuICB2YXIgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgd2luU2Nyb2xsZXIgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG5cbiAgaWYgKGVsKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGVsKSxcbiAgICAgICAgICBzY2FsZVggPSBlbE1hdHJpeC5hLFxuICAgICAgICAgIHNjYWxlWSA9IGVsTWF0cml4LmQ7XG4gICAgICBvZmZzZXRMZWZ0ICs9IGVsLnNjcm9sbExlZnQgKiBzY2FsZVg7XG4gICAgICBvZmZzZXRUb3AgKz0gZWwuc2Nyb2xsVG9wICogc2NhbGVZO1xuICAgIH0gd2hpbGUgKGVsICE9PSB3aW5TY3JvbGxlciAmJiAoZWwgPSBlbC5wYXJlbnROb2RlKSk7XG4gIH1cblxuICByZXR1cm4gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBvYmplY3Qgd2l0aGluIHRoZSBnaXZlbiBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IGFyciAgIEFycmF5IHRoYXQgbWF5IG9yIG1heSBub3QgaG9sZCB0aGUgb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgQW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5LXZhbHVlIHBhaXIgdW5pcXVlIHRvIGFuZCBpZGVudGljYWwgdG8gYSBrZXktdmFsdWUgcGFpciBpbiB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIGZpbmRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICBUaGUgaW5kZXggb2YgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXksIG9yIC0xXG4gKi9cblxuXG5mdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFyciwgb2JqKSB7XG4gIGZvciAodmFyIGkgaW4gYXJyKSB7XG4gICAgaWYgKCFhcnIuaGFzT3duUHJvcGVydHkoaSkpIGNvbnRpbnVlO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldID09PSBhcnJbaV1ba2V5XSkgcmV0dXJuIE51bWJlcihpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsLCBpbmNsdWRlU2VsZikge1xuICAvLyBza2lwIHRvIHdpbmRvd1xuICBpZiAoIWVsIHx8ICFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gIHZhciBlbGVtID0gZWw7XG4gIHZhciBnb3RTZWxmID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZ2V0IGVsZW0gY3NzIGlmIGl0IGlzbid0IGV2ZW4gb3ZlcmZsb3dpbmcgaW4gdGhlIGZpcnN0IHBsYWNlIChwZXJmb3JtYW5jZSlcbiAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCkge1xuICAgICAgdmFyIGVsZW1DU1MgPSBjc3MoZWxlbSk7XG5cbiAgICAgIGlmIChlbGVtLmNsaWVudFdpZHRoIDwgZWxlbS5zY3JvbGxXaWR0aCAmJiAoZWxlbUNTUy5vdmVyZmxvd1ggPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dYID09ICdzY3JvbGwnKSB8fCBlbGVtLmNsaWVudEhlaWdodCA8IGVsZW0uc2Nyb2xsSGVpZ2h0ICYmIChlbGVtQ1NTLm92ZXJmbG93WSA9PSAnYXV0bycgfHwgZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ3Njcm9sbCcpKSB7XG4gICAgICAgIGlmICghZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgfHwgZWxlbSA9PT0gZG9jdW1lbnQuYm9keSkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgaWYgKGdvdFNlbGYgfHwgaW5jbHVkZVNlbGYpIHJldHVybiBlbGVtO1xuICAgICAgICBnb3RTZWxmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuXG4gIH0gd2hpbGUgKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpO1xuXG4gIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChkc3QsIHNyYykge1xuICBpZiAoZHN0ICYmIHNyYykge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIGlzUmVjdEVxdWFsKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gTWF0aC5yb3VuZChyZWN0MS50b3ApID09PSBNYXRoLnJvdW5kKHJlY3QyLnRvcCkgJiYgTWF0aC5yb3VuZChyZWN0MS5sZWZ0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5sZWZ0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLmhlaWdodCkgPT09IE1hdGgucm91bmQocmVjdDIuaGVpZ2h0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLndpZHRoKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi53aWR0aCk7XG59XG5cbnZhciBfdGhyb3R0bGVUaW1lb3V0O1xuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaywgbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aHJvdHRsZVRpbWVvdXQpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoX3RoaXMsIGFyZ3NbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBfdGhyb3R0bGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB9LCBtcyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjYW5jZWxUaHJvdHRsZSgpIHtcbiAgY2xlYXJUaW1lb3V0KF90aHJvdHRsZVRpbWVvdXQpO1xuICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxCeShlbCwgeCwgeSkge1xuICBlbC5zY3JvbGxMZWZ0ICs9IHg7XG4gIGVsLnNjcm9sbFRvcCArPSB5O1xufVxuXG5mdW5jdGlvbiBjbG9uZShlbCkge1xuICB2YXIgUG9seW1lciA9IHdpbmRvdy5Qb2x5bWVyO1xuICB2YXIgJCA9IHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvO1xuXG4gIGlmIChQb2x5bWVyICYmIFBvbHltZXIuZG9tKSB7XG4gICAgcmV0dXJuIFBvbHltZXIuZG9tKGVsKS5jbG9uZU5vZGUodHJ1ZSk7XG4gIH0gZWxzZSBpZiAoJCkge1xuICAgIHJldHVybiAkKGVsKS5jbG9uZSh0cnVlKVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFJlY3QoZWwsIHJlY3QpIHtcbiAgY3NzKGVsLCAncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgY3NzKGVsLCAndG9wJywgcmVjdC50b3ApO1xuICBjc3MoZWwsICdsZWZ0JywgcmVjdC5sZWZ0KTtcbiAgY3NzKGVsLCAnd2lkdGgnLCByZWN0LndpZHRoKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQpO1xufVxuXG5mdW5jdGlvbiB1bnNldFJlY3QoZWwpIHtcbiAgY3NzKGVsLCAncG9zaXRpb24nLCAnJyk7XG4gIGNzcyhlbCwgJ3RvcCcsICcnKTtcbiAgY3NzKGVsLCAnbGVmdCcsICcnKTtcbiAgY3NzKGVsLCAnd2lkdGgnLCAnJyk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsICcnKTtcbn1cblxudmFyIGV4cGFuZG8gPSAnU29ydGFibGUnICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbmZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpIHtcbiAgdmFyIGFuaW1hdGlvblN0YXRlcyA9IFtdLFxuICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZDtcbiAgcmV0dXJuIHtcbiAgICBjYXB0dXJlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGNhcHR1cmVBbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSByZXR1cm47XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4pO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNzcyhjaGlsZCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IGNoaWxkID09PSBTb3J0YWJsZS5naG9zdCkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZCxcbiAgICAgICAgICByZWN0OiBnZXRSZWN0KGNoaWxkKVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZnJvbVJlY3QgPSBfb2JqZWN0U3ByZWFkKHt9LCBhbmltYXRpb25TdGF0ZXNbYW5pbWF0aW9uU3RhdGVzLmxlbmd0aCAtIDFdLnJlY3QpOyAvLyBJZiBhbmltYXRpbmc6IGNvbXBlbnNhdGUgZm9yIGN1cnJlbnQgYW5pbWF0aW9uXG5cblxuICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChjaGlsZE1hdHJpeCkge1xuICAgICAgICAgICAgZnJvbVJlY3QudG9wIC09IGNoaWxkTWF0cml4LmY7XG4gICAgICAgICAgICBmcm9tUmVjdC5sZWZ0IC09IGNoaWxkTWF0cml4LmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuZnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGFkZEFuaW1hdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgfSxcbiAgICByZW1vdmVBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gcmVtb3ZlQW5pbWF0aW9uU3RhdGUodGFyZ2V0KSB7XG4gICAgICBhbmltYXRpb25TdGF0ZXMuc3BsaWNlKGluZGV4T2ZPYmplY3QoYW5pbWF0aW9uU3RhdGVzLCB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KSwgMSk7XG4gICAgfSxcbiAgICBhbmltYXRlQWxsOiBmdW5jdGlvbiBhbmltYXRlQWxsKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmltYXRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBhbmltYXRpb25UaW1lID0gMDtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgICBmcm9tUmVjdCA9IHRhcmdldC5mcm9tUmVjdCxcbiAgICAgICAgICAgIHRvUmVjdCA9IGdldFJlY3QodGFyZ2V0KSxcbiAgICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgICBwcmV2VG9SZWN0ID0gdGFyZ2V0LnByZXZUb1JlY3QsXG4gICAgICAgICAgICBhbmltYXRpbmdSZWN0ID0gc3RhdGUucmVjdCxcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuXG4gICAgICAgIGlmICh0YXJnZXRNYXRyaXgpIHtcbiAgICAgICAgICAvLyBDb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICAgIHRvUmVjdC50b3AgLT0gdGFyZ2V0TWF0cml4LmY7XG4gICAgICAgICAgdG9SZWN0LmxlZnQgLT0gdGFyZ2V0TWF0cml4LmU7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQudG9SZWN0ID0gdG9SZWN0O1xuXG4gICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmIC8vIE1ha2Ugc3VyZSBhbmltYXRpbmdSZWN0IGlzIG9uIGxpbmUgYmV0d2VlbiB0b1JlY3QgJiBmcm9tUmVjdFxuICAgICAgICAgIChhbmltYXRpbmdSZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGFuaW1hdGluZ1JlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSA9PT0gKGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3ApIC8gKGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkpIHtcbiAgICAgICAgICAgIC8vIElmIHJldHVybmluZyB0byBzYW1lIHBsYWNlIGFzIHN0YXJ0ZWQgZnJvbSBhbmltYXRpb24gYW5kIG9uIHNhbWUgYXhpc1xuICAgICAgICAgICAgdGltZSA9IGNhbGN1bGF0ZVJlYWxUaW1lKGFuaW1hdGluZ1JlY3QsIHByZXZGcm9tUmVjdCwgcHJldlRvUmVjdCwgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIGZyb21SZWN0ICE9IHRvUmVjdDogYW5pbWF0ZVxuXG5cbiAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcblxuICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgdGltZSA9IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmFuaW1hdGUodGFyZ2V0LCBhbmltYXRpbmdSZWN0LCB0b1JlY3QsIHRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpb25DYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcbiAgICAgICAgfSwgYW5pbWF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSh0YXJnZXQsIGN1cnJlbnRSZWN0LCB0b1JlY3QsIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBlbE1hdHJpeCA9IG1hdHJpeCh0aGlzLmVsKSxcbiAgICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kLFxuICAgICAgICAgICAgdHJhbnNsYXRlWCA9IChjdXJyZW50UmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpIC8gKHNjYWxlWCB8fCAxKSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgdGhpcy5mb3JSZXBhaW50RHVtbXkgPSByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVwYWludCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5vZmZzZXRXaWR0aDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgZnJvbVJlY3QsIHRvUmVjdCwgb3B0aW9ucykge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIGFuaW1hdGluZ1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSBhbmltYXRpbmdSZWN0LmxlZnQsIDIpKSAvIE1hdGguc3FydChNYXRoLnBvdyhmcm9tUmVjdC50b3AgLSB0b1JlY3QudG9wLCAyKSArIE1hdGgucG93KGZyb21SZWN0LmxlZnQgLSB0b1JlY3QubGVmdCwgMikpICogb3B0aW9ucy5hbmltYXRpb247XG59XG5cbnZhciBwbHVnaW5zID0gW107XG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbn07XG52YXIgUGx1Z2luTWFuYWdlciA9IHtcbiAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KHBsdWdpbikge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgb3B0aW9uIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkob3B0aW9uKSAmJiAhKG9wdGlvbiBpbiBwbHVnaW4pKSB7XG4gICAgICAgIHBsdWdpbltvcHRpb25dID0gZGVmYXVsdHNbb3B0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwLnBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IENhbm5vdCBtb3VudCBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5wbHVnaW5OYW1lLCBcIiBtb3JlIHRoYW4gb25jZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmV2ZW50Q2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGV2dC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudENhbmNlbGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuOyAvLyBGaXJlIGdsb2JhbCBldmVudHMgaWYgaXQgZXhpc3RzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVHbG9iYWxdKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH0gLy8gT25seSBmaXJlIHBsdWdpbiBldmVudCBpZiBwbHVnaW4gaXMgZW5hYmxlZCBpbiB0aGlzIHNvcnRhYmxlLFxuICAgICAgLy8gYW5kIHBsdWdpbiBoYXMgZXZlbnQgZGVmaW5lZFxuXG5cbiAgICAgIGlmIChzb3J0YWJsZS5vcHRpb25zW3BsdWdpbi5wbHVnaW5OYW1lXSAmJiBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXSkge1xuICAgICAgICBzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV1bZXZlbnROYW1lXShfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkOyAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG5cbiAgICAgIF9leHRlbmRzKGRlZmF1bHRzLCBpbml0aWFsaXplZC5kZWZhdWx0cyk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gc29ydGFibGUub3B0aW9ucykge1xuICAgICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIGNvbnRpbnVlO1xuICAgICAgdmFyIG1vZGlmaWVkID0gdGhpcy5tb2RpZnlPcHRpb24oc29ydGFibGUsIG9wdGlvbiwgc29ydGFibGUub3B0aW9uc1tvcHRpb25dKTtcblxuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIF9leHRlbmRzKGV2ZW50UHJvcGVydGllcywgcGx1Z2luLmV2ZW50UHJvcGVydGllcy5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgbmFtZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBldmVudFByb3BlcnRpZXM7XG4gIH0sXG4gIG1vZGlmeU9wdGlvbjogZnVuY3Rpb24gbW9kaWZ5T3B0aW9uKHNvcnRhYmxlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBtb2RpZmllZFZhbHVlO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAvLyBQbHVnaW4gbXVzdCBleGlzdCBvbiB0aGUgU29ydGFibGVcbiAgICAgIGlmICghc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdKSByZXR1cm47IC8vIElmIHN0YXRpYyBvcHRpb24gbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIG9wdGlvbiwgY2FsbCBpbiB0aGUgY29udGV4dCBvZiB0aGUgU29ydGFibGUncyBpbnN0YW5jZSBvZiB0aGlzIHBsdWdpblxuXG4gICAgICBpZiAocGx1Z2luLm9wdGlvbkxpc3RlbmVycyAmJiB0eXBlb2YgcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb2RpZmllZFZhbHVlID0gcGx1Z2luLm9wdGlvbkxpc3RlbmVyc1tuYW1lXS5jYWxsKHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb2RpZmllZFZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KF9yZWYpIHtcbiAgdmFyIHNvcnRhYmxlID0gX3JlZi5zb3J0YWJsZSxcbiAgICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIHRhcmdldEVsID0gX3JlZi50YXJnZXRFbCxcbiAgICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgICB0b0VsID0gX3JlZi50b0VsLFxuICAgICAgZnJvbUVsID0gX3JlZi5mcm9tRWwsXG4gICAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgICBuZXdJbmRleCA9IF9yZWYubmV3SW5kZXgsXG4gICAgICBvbGREcmFnZ2FibGVJbmRleCA9IF9yZWYub2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50LFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmLnB1dFNvcnRhYmxlLFxuICAgICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgdmFyIGV2dCxcbiAgICAgIG9wdGlvbnMgPSBzb3J0YWJsZS5vcHRpb25zLFxuICAgICAgb25OYW1lID0gJ29uJyArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKTsgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcblxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWwgfHwgcm9vdEVsO1xuICBldnQuZnJvbSA9IGZyb21FbCB8fCByb290RWw7XG4gIGV2dC5pdGVtID0gdGFyZ2V0RWwgfHwgcm9vdEVsO1xuICBldnQuY2xvbmUgPSBjbG9uZUVsO1xuICBldnQub2xkSW5kZXggPSBvbGRJbmRleDtcbiAgZXZ0Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gIGV2dC5vbGREcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICBldnQubmV3RHJhZ2dhYmxlSW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICBldnQucHVsbE1vZGUgPSBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlIDogdW5kZWZpbmVkO1xuXG4gIHZhciBhbGxFdmVudFByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcywgUGx1Z2luTWFuYWdlci5nZXRFdmVudFByb3BlcnRpZXMobmFtZSwgc29ydGFibGUpKTtcblxuICBmb3IgKHZhciBvcHRpb24gaW4gYWxsRXZlbnRQcm9wZXJ0aWVzKSB7XG4gICAgZXZ0W29wdGlvbl0gPSBhbGxFdmVudFByb3BlcnRpZXNbb3B0aW9uXTtcbiAgfVxuXG4gIGlmIChyb290RWwpIHtcbiAgICByb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnNbb25OYW1lXSkge1xuICAgIG9wdGlvbnNbb25OYW1lXS5jYWxsKHNvcnRhYmxlLCBldnQpO1xuICB9XG59XG5cbnZhciBwbHVnaW5FdmVudCA9IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgb3JpZ2luYWxFdmVudCA9IF9yZWYuZXZ0LFxuICAgICAgZGF0YSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXCJldnRcIl0pO1xuXG4gIFBsdWdpbk1hbmFnZXIucGx1Z2luRXZlbnQuYmluZChTb3J0YWJsZSkoZXZlbnROYW1lLCBzb3J0YWJsZSwgX29iamVjdFNwcmVhZCh7XG4gICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBkYXRhKSk7XG59O1xuXG5mdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChpbmZvKSB7XG4gIGRpc3BhdGNoRXZlbnQoX29iamVjdFNwcmVhZCh7XG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGNsb25lRWw6IGNsb25lRWwsXG4gICAgdGFyZ2V0RWw6IGRyYWdFbCxcbiAgICByb290RWw6IHJvb3RFbCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXhcbiAgfSwgaW5mbykpO1xufVxuXG52YXIgZHJhZ0VsLFxuICAgIHBhcmVudEVsLFxuICAgIGdob3N0RWwsXG4gICAgcm9vdEVsLFxuICAgIG5leHRFbCxcbiAgICBsYXN0RG93bkVsLFxuICAgIGNsb25lRWwsXG4gICAgY2xvbmVIaWRkZW4sXG4gICAgb2xkSW5kZXgsXG4gICAgbmV3SW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgYWN0aXZlR3JvdXAsXG4gICAgcHV0U29ydGFibGUsXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICAgIHNvcnRhYmxlcyA9IFtdLFxuICAgIHRhcEV2dCxcbiAgICB0b3VjaEV2dCxcbiAgICBsYXN0RHgsXG4gICAgbGFzdER5LFxuICAgIHRhcERpc3RhbmNlTGVmdCxcbiAgICB0YXBEaXN0YW5jZVRvcCxcbiAgICBtb3ZlZCxcbiAgICBsYXN0VGFyZ2V0LFxuICAgIGxhc3REaXJlY3Rpb24sXG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2UsXG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICAgIHRhcmdldE1vdmVEaXN0YW5jZSxcbiAgICAvLyBGb3IgcG9zaXRpb25pbmcgZ2hvc3QgYWJzb2x1dGVseVxuZ2hvc3RSZWxhdGl2ZVBhcmVudCxcbiAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IFtdLFxuICAgIC8vIChsZWZ0LCB0b3ApXG5fc2lsZW50ID0gZmFsc2UsXG4gICAgc2F2ZWRJbnB1dENoZWNrZWQgPSBbXTtcbi8qKiBAY29uc3QgKi9cblxudmFyIGRvY3VtZW50RXhpc3RzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgICBDU1NGbG9hdFByb3BlcnR5ID0gRWRnZSB8fCBJRTExT3JMZXNzID8gJ2Nzc0Zsb2F0JyA6ICdmbG9hdCcsXG4gICAgLy8gVGhpcyB3aWxsIG5vdCBwYXNzIGZvciBJRTksIGJlY2F1c2UgSUU5IERuRCBvbmx5IHdvcmtzIG9uIGFuY2hvcnNcbnN1cHBvcnREcmFnZ2FibGUgPSBkb2N1bWVudEV4aXN0cyAmJiAhQ2hyb21lRm9yQW5kcm9pZCAmJiAhSU9TICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHN1cHBvcnRDc3NQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIWRvY3VtZW50RXhpc3RzKSByZXR1cm47IC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuXG4gIGlmIChJRTExT3JMZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICByZXR1cm4gZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9PT0gJ2F1dG8nO1xufSgpLFxuICAgIF9kZXRlY3REaXJlY3Rpb24gPSBmdW5jdGlvbiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCBvcHRpb25zKSB7XG4gIHZhciBlbENTUyA9IGNzcyhlbCksXG4gICAgICBlbFdpZHRoID0gcGFyc2VJbnQoZWxDU1Mud2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ0xlZnQpIC0gcGFyc2VJbnQoZWxDU1MucGFkZGluZ1JpZ2h0KSAtIHBhcnNlSW50KGVsQ1NTLmJvcmRlckxlZnRXaWR0aCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJSaWdodFdpZHRoKSxcbiAgICAgIGNoaWxkMSA9IGdldENoaWxkKGVsLCAwLCBvcHRpb25zKSxcbiAgICAgIGNoaWxkMiA9IGdldENoaWxkKGVsLCAxLCBvcHRpb25zKSxcbiAgICAgIGZpcnN0Q2hpbGRDU1MgPSBjaGlsZDEgJiYgY3NzKGNoaWxkMSksXG4gICAgICBzZWNvbmRDaGlsZENTUyA9IGNoaWxkMiAmJiBjc3MoY2hpbGQyKSxcbiAgICAgIGZpcnN0Q2hpbGRXaWR0aCA9IGZpcnN0Q2hpbGRDU1MgJiYgcGFyc2VJbnQoZmlyc3RDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDEpLndpZHRoLFxuICAgICAgc2Vjb25kQ2hpbGRXaWR0aCA9IHNlY29uZENoaWxkQ1NTICYmIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc2Vjb25kQ2hpbGRDU1MubWFyZ2luUmlnaHQpICsgZ2V0UmVjdChjaGlsZDIpLndpZHRoO1xuXG4gIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZmxleCcpIHtcbiAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2dyaWQnKSB7XG4gICAgcmV0dXJuIGVsQ1NTLmdyaWRUZW1wbGF0ZUNvbHVtbnMuc3BsaXQoJyAnKS5sZW5ndGggPD0gMSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgIHZhciB0b3VjaGluZ1NpZGVDaGlsZDIgPSBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gPT09ICdsZWZ0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgcmV0dXJuIGNoaWxkMiAmJiAoc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09ICdib3RoJyB8fCBzZWNvbmRDaGlsZENTUy5jbGVhciA9PT0gdG91Y2hpbmdTaWRlQ2hpbGQyKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gIH1cblxuICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbn0sXG4gICAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICB2YXIgZHJhZ0VsUzFPcHAgPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LmxlZnQgOiBkcmFnUmVjdC50b3AsXG4gICAgICBkcmFnRWxTMk9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QucmlnaHQgOiBkcmFnUmVjdC5ib3R0b20sXG4gICAgICBkcmFnRWxPcHBMZW5ndGggPSB2ZXJ0aWNhbCA/IGRyYWdSZWN0LndpZHRoIDogZHJhZ1JlY3QuaGVpZ2h0LFxuICAgICAgdGFyZ2V0UzFPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QubGVmdCA6IHRhcmdldFJlY3QudG9wLFxuICAgICAgdGFyZ2V0UzJPcHAgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QucmlnaHQgOiB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHRhcmdldE9wcExlbmd0aCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC53aWR0aCA6IHRhcmdldFJlY3QuaGVpZ2h0O1xuICByZXR1cm4gZHJhZ0VsUzFPcHAgPT09IHRhcmdldFMxT3BwIHx8IGRyYWdFbFMyT3BwID09PSB0YXJnZXRTMk9wcCB8fCBkcmFnRWxTMU9wcCArIGRyYWdFbE9wcExlbmd0aCAvIDIgPT09IHRhcmdldFMxT3BwICsgdGFyZ2V0T3BwTGVuZ3RoIC8gMjtcbn0sXG5cbi8qKlxuICogRGV0ZWN0cyBmaXJzdCBuZWFyZXN0IGVtcHR5IHNvcnRhYmxlIHRvIFggYW5kIFkgcG9zaXRpb24gdXNpbmcgZW1wdHlJbnNlcnRUaHJlc2hvbGQuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggICAgICBYIHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gICBFbGVtZW50IG9mIHRoZSBmaXJzdCBmb3VuZCBuZWFyZXN0IFNvcnRhYmxlXG4gKi9cbl9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSA9IGZ1bmN0aW9uIF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZSh4LCB5KSB7XG4gIHZhciByZXQ7XG4gIHNvcnRhYmxlcy5zb21lKGZ1bmN0aW9uIChzb3J0YWJsZSkge1xuICAgIGlmIChsYXN0Q2hpbGQoc29ydGFibGUpKSByZXR1cm47XG4gICAgdmFyIHJlY3QgPSBnZXRSZWN0KHNvcnRhYmxlKSxcbiAgICAgICAgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZCxcbiAgICAgICAgaW5zaWRlSG9yaXpvbnRhbGx5ID0geCA+PSByZWN0LmxlZnQgLSB0aHJlc2hvbGQgJiYgeCA8PSByZWN0LnJpZ2h0ICsgdGhyZXNob2xkLFxuICAgICAgICBpbnNpZGVWZXJ0aWNhbGx5ID0geSA+PSByZWN0LnRvcCAtIHRocmVzaG9sZCAmJiB5IDw9IHJlY3QuYm90dG9tICsgdGhyZXNob2xkO1xuXG4gICAgaWYgKHRocmVzaG9sZCAmJiBpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgcmV0dXJuIHJldCA9IHNvcnRhYmxlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59LFxuICAgIF9wcmVwYXJlR3JvdXAgPSBmdW5jdGlvbiBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gdG9Gbih2YWx1ZSwgcHVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICB2YXIgc2FtZUdyb3VwID0gdG8ub3B0aW9ucy5ncm91cC5uYW1lICYmIGZyb20ub3B0aW9ucy5ncm91cC5uYW1lICYmIHRvLm9wdGlvbnMuZ3JvdXAubmFtZSA9PT0gZnJvbS5vcHRpb25zLmdyb3VwLm5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIChwdWxsIHx8IHNhbWVHcm91cCkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBwdWxsIHZhbHVlXG4gICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocHVsbCAmJiB2YWx1ZSA9PT0gJ2Nsb25lJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdG9Gbih2YWx1ZSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpLCBwdWxsKSh0bywgZnJvbSwgZHJhZ0VsLCBldnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZSA9PT0gb3RoZXJHcm91cCB8fCB2YWx1ZS5qb2luICYmIHZhbHVlLmluZGV4T2Yob3RoZXJHcm91cCkgPiAtMTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGdyb3VwID0ge307XG4gIHZhciBvcmlnaW5hbEdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuICBpZiAoIW9yaWdpbmFsR3JvdXAgfHwgX3R5cGVvZihvcmlnaW5hbEdyb3VwKSAhPSAnb2JqZWN0Jykge1xuICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICBuYW1lOiBvcmlnaW5hbEdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gIGdyb3VwLmNoZWNrUHVsbCA9IHRvRm4ob3JpZ2luYWxHcm91cC5wdWxsLCB0cnVlKTtcbiAgZ3JvdXAuY2hlY2tQdXQgPSB0b0ZuKG9yaWdpbmFsR3JvdXAucHV0KTtcbiAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICBvcHRpb25zLmdyb3VwID0gZ3JvdXA7XG59LFxuICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQgPSBmdW5jdGlvbiBfaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICBpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzICYmIGdob3N0RWwpIHtcbiAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICB9XG59LFxuICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF91bmhpZGVHaG9zdEZvclRhcmdldCgpIHtcbiAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICB9XG59OyAvLyAjMTE4NCBmaXggLSBQcmV2ZW50IGNsaWNrIGV2ZW50IG9uIGZhbGxiYWNrIGlmIGRyYWdnZWQgYnV0IGl0ZW0gbm90IGNoYW5nZWQgcG9zaXRpb25cblxuXG5pZiAoZG9jdW1lbnRFeGlzdHMpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cblxudmFyIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50ID0gZnVuY3Rpb24gbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KSB7XG4gIGlmIChkcmFnRWwpIHtcbiAgICBldnQgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0O1xuXG4gICAgdmFyIG5lYXJlc3QgPSBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSBpbiBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIGV2ZW50W2ldID0gZXZ0W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnJvb3RFbCA9IG5lYXJlc3Q7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IHZvaWQgMDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IHZvaWQgMDtcblxuICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2NoZWNrT3V0c2lkZVRhcmdldEVsID0gZnVuY3Rpb24gX2NoZWNrT3V0c2lkZVRhcmdldEVsKGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTtcbiAgfVxufTtcbi8qKlxuICogQGNsYXNzICBTb3J0YWJsZVxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9ICBlbFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cbiAqL1xuXG5cbmZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XG4gIGlmICghKGVsICYmIGVsLm5vZGVUeXBlICYmIGVsLm5vZGVUeXBlID09PSAxKSkge1xuICAgIHRocm93IFwiU29ydGFibGU6IGBlbGAgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKGVsKSk7XG4gIH1cblxuICB0aGlzLmVsID0gZWw7IC8vIHJvb3QgZWxlbWVudFxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7IC8vIEV4cG9ydCBpbnN0YW5jZVxuXG4gIGVsW2V4cGFuZG9dID0gdGhpcztcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGdyb3VwOiBudWxsLFxuICAgIHNvcnQ6IHRydWUsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHN0b3JlOiBudWxsLFxuICAgIGhhbmRsZTogbnVsbCxcbiAgICBkcmFnZ2FibGU6IC9eW3VvXWwkL2kudGVzdChlbC5ub2RlTmFtZSkgPyAnPmxpJyA6ICc+KicsXG4gICAgc3dhcFRocmVzaG9sZDogMSxcbiAgICAvLyBwZXJjZW50YWdlOyAwIDw9IHggPD0gMVxuICAgIGludmVydFN3YXA6IGZhbHNlLFxuICAgIC8vIGludmVydCBhbHdheXNcbiAgICBpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgdG8gc2FtZSBhcyBzd2FwVGhyZXNob2xkIGlmIGRlZmF1bHRcbiAgICByZW1vdmVDbG9uZU9uSGlkZTogdHJ1ZSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcbiAgICBjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXG4gICAgZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXG4gICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgcHJldmVudE9uRmlsdGVyOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogMCxcbiAgICBlYXNpbmc6IG51bGwsXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkcmFnRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG4gICAgZHJvcEJ1YmJsZTogZmFsc2UsXG4gICAgZHJhZ292ZXJCdWJibGU6IGZhbHNlLFxuICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICBkZWxheTogMCxcbiAgICBkZWxheU9uVG91Y2hPbmx5OiBmYWxzZSxcbiAgICB0b3VjaFN0YXJ0VGhyZXNob2xkOiAoTnVtYmVyLnBhcnNlSW50ID8gTnVtYmVyIDogd2luZG93KS5wYXJzZUludCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMTApIHx8IDEsXG4gICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcbiAgICBmYWxsYmFja09uQm9keTogZmFsc2UsXG4gICAgZmFsbGJhY2tUb2xlcmFuY2U6IDAsXG4gICAgZmFsbGJhY2tPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICBzdXBwb3J0UG9pbnRlcjogU29ydGFibGUuc3VwcG9ydFBvaW50ZXIgIT09IGZhbHNlICYmICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdyAmJiAhU2FmYXJpLFxuICAgIGVtcHR5SW5zZXJ0VGhyZXNob2xkOiA1XG4gIH07XG4gIFBsdWdpbk1hbmFnZXIuaW5pdGlhbGl6ZVBsdWdpbnModGhpcywgZWwsIGRlZmF1bHRzKTsgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdHMpIHtcbiAgICAhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XG4gIH1cblxuICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpOyAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcblxuXG4gIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgfVxuICB9IC8vIFNldHVwIGRyYWcgbW9kZVxuXG5cbiAgdGhpcy5uYXRpdmVEcmFnZ2FibGUgPSBvcHRpb25zLmZvcmNlRmFsbGJhY2sgPyBmYWxzZSA6IHN1cHBvcnREcmFnZ2FibGU7XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgLy8gVG91Y2ggc3RhcnQgdGhyZXNob2xkIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG5hdGl2ZSBkcmFnc3RhcnQgdGhyZXNob2xkXG4gICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSAxO1xuICB9IC8vIEJpbmQgZXZlbnRzXG5cblxuICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgIG9uKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBvbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9XG5cbiAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgb24oZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgIG9uKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gIH1cblxuICBzb3J0YWJsZXMucHVzaCh0aGlzLmVsKTsgLy8gUmVzdG9yZSBzb3J0aW5nXG5cbiAgb3B0aW9ucy5zdG9yZSAmJiBvcHRpb25zLnN0b3JlLmdldCAmJiB0aGlzLnNvcnQob3B0aW9ucy5zdG9yZS5nZXQodGhpcykgfHwgW10pOyAvLyBBZGQgYW5pbWF0aW9uIHN0YXRlIG1hbmFnZXJcblxuICBfZXh0ZW5kcyh0aGlzLCBBbmltYXRpb25TdGF0ZU1hbmFnZXIoKSk7XG59XG5cblNvcnRhYmxlLnByb3RvdHlwZSA9XG4vKiogQGxlbmRzIFNvcnRhYmxlLnByb3RvdHlwZSAqL1xue1xuICBjb25zdHJ1Y3RvcjogU29ydGFibGUsXG4gIF9pc091dHNpZGVUaGlzRWw6IGZ1bmN0aW9uIF9pc091dHNpZGVUaGlzRWwodGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKHRhcmdldCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmVsKSB7XG4gICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIF9nZXREaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIGRyYWdFbCkgOiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB9LFxuICBfb25UYXBTdGFydDogZnVuY3Rpb24gX29uVGFwU3RhcnQoXG4gIC8qKiBFdmVudHxUb3VjaEV2ZW50ICovXG4gIGV2dCkge1xuICAgIGlmICghZXZ0LmNhbmNlbGFibGUpIHJldHVybjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcHJldmVudE9uRmlsdGVyID0gb3B0aW9ucy5wcmV2ZW50T25GaWx0ZXIsXG4gICAgICAgIHR5cGUgPSBldnQudHlwZSxcbiAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyAmJiBldnQudG91Y2hlc1swXSB8fCBldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlID09PSAndG91Y2gnICYmIGV2dCxcbiAgICAgICAgdGFyZ2V0ID0gKHRvdWNoIHx8IGV2dCkudGFyZ2V0LFxuICAgICAgICBvcmlnaW5hbFRhcmdldCA9IGV2dC50YXJnZXQuc2hhZG93Um9vdCAmJiAoZXZ0LnBhdGggJiYgZXZ0LnBhdGhbMF0gfHwgZXZ0LmNvbXBvc2VkUGF0aCAmJiBldnQuY29tcG9zZWRQYXRoKClbMF0pIHx8IHRhcmdldCxcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG5cbiAgICBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTsgLy8gRG9uJ3QgdHJpZ2dlciBzdGFydCBldmVudCB3aGVuIGFuIGVsZW1lbnQgaXMgYmVlbiBkcmFnZ2VkLCBvdGhlcndpc2UgdGhlIGV2dC5vbGRpbmRleCBhbHdheXMgd3Jvbmcgd2hlbiBzZXQgb3B0aW9uLmdyb3VwLlxuXG5cbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9tb3VzZWRvd258cG9pbnRlcmRvd24vLnRlc3QodHlwZSkgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47IC8vIG9ubHkgbGVmdCBidXR0b24gYW5kIGVuYWJsZWRcbiAgICB9IC8vIGNhbmNlbCBkbmQgaWYgb3JpZ2luYWwgdGFyZ2V0IGlzIGNvbnRlbnQgZWRpdGFibGVcblxuXG4gICAgaWYgKG9yaWdpbmFsVGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTYWZhcmkgaWdub3JlcyBmdXJ0aGVyIGV2ZW50IGhhbmRsaW5nIGFmdGVyIG1vdXNlZG93blxuXG5cbiAgICBpZiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlICYmIFNhZmFyaSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCBmYWxzZSk7XG5cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5hbmltYXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsYXN0RG93bkVsID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIElnbm9yaW5nIGR1cGxpY2F0ZSBgZG93bmBcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXG5cbiAgICBvbGRJbmRleCA9IGluZGV4KHRhcmdldCk7XG4gICAgb2xkRHJhZ2dhYmxlSW5kZXggPSBpbmRleCh0YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlKTsgLy8gQ2hlY2sgZmlsdGVyXG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIHJvb3RFbDogb3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgICBmcm9tRWw6IGVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBsdWdpbkV2ZW50KCdmaWx0ZXInLCBfdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LmNhbmNlbGFibGUgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgICBmaWx0ZXIgPSBmaWx0ZXIuc3BsaXQoJywnKS5zb21lKGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgICBjcml0ZXJpYSA9IGNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIGNyaXRlcmlhLnRyaW0oKSwgZWwsIGZhbHNlKTtcblxuICAgICAgICBpZiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgICAgICByb290RWw6IGNyaXRlcmlhLFxuICAgICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICB0YXJnZXRFbDogdGFyZ2V0LFxuICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgIHRvRWw6IGVsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgIHByZXZlbnRPbkZpbHRlciAmJiBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuOyAvLyBjYW5jZWwgZG5kXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlICYmICFjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBvcHRpb25zLmhhbmRsZSwgZWwsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUHJlcGFyZSBgZHJhZ3N0YXJ0YFxuXG5cbiAgICB0aGlzLl9wcmVwYXJlRHJhZ1N0YXJ0KGV2dCwgdG91Y2gsIHRhcmdldCk7XG4gIH0sXG4gIF9wcmVwYXJlRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfcHJlcGFyZURyYWdTdGFydChcbiAgLyoqIEV2ZW50ICovXG4gIGV2dCxcbiAgLyoqIFRvdWNoICovXG4gIHRvdWNoLFxuICAvKiogSFRNTEVsZW1lbnQgKi9cbiAgdGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgZWwgPSBfdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnMsXG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICBkcmFnU3RhcnRGbjtcblxuICAgIGlmICh0YXJnZXQgJiYgIWRyYWdFbCAmJiB0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpIHtcbiAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgIHJvb3RFbCA9IGVsO1xuICAgICAgZHJhZ0VsID0gdGFyZ2V0O1xuICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTtcbiAgICAgIG5leHRFbCA9IGRyYWdFbC5uZXh0U2libGluZztcbiAgICAgIGxhc3REb3duRWwgPSB0YXJnZXQ7XG4gICAgICBhY3RpdmVHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG4gICAgICBTb3J0YWJsZS5kcmFnZ2VkID0gZHJhZ0VsO1xuICAgICAgdGFwRXZ0ID0ge1xuICAgICAgICB0YXJnZXQ6IGRyYWdFbCxcbiAgICAgICAgY2xpZW50WDogKHRvdWNoIHx8IGV2dCkuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogKHRvdWNoIHx8IGV2dCkuY2xpZW50WVxuICAgICAgfTtcbiAgICAgIHRhcERpc3RhbmNlTGVmdCA9IHRhcEV2dC5jbGllbnRYIC0gZHJhZ1JlY3QubGVmdDtcbiAgICAgIHRhcERpc3RhbmNlVG9wID0gdGFwRXZ0LmNsaWVudFkgLSBkcmFnUmVjdC50b3A7XG4gICAgICB0aGlzLl9sYXN0WCA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFg7XG4gICAgICB0aGlzLl9sYXN0WSA9ICh0b3VjaCB8fCBldnQpLmNsaWVudFk7XG4gICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnYWxsJztcblxuICAgICAgZHJhZ1N0YXJ0Rm4gPSBmdW5jdGlvbiBkcmFnU3RhcnRGbigpIHtcbiAgICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5RW5kZWQnLCBfdGhpcywge1xuICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgX3RoaXMuX29uRHJvcCgpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERlbGF5ZWQgZHJhZyBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgICAgLy8gd2UgY2FuIHJlLWVuYWJsZSB0aGUgZXZlbnRzOiB0b3VjaG1vdmUvbW91c2Vtb3ZlXG5cblxuICAgICAgICBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKCFGaXJlRm94ICYmIF90aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIGRyYWdFbC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9IC8vIEJpbmQgdGhlIGV2ZW50czogZHJhZ3N0YXJ0L2RyYWdlbmRcblxuXG4gICAgICAgIF90aGlzLl90cmlnZ2VyRHJhZ1N0YXJ0KGV2dCwgdG91Y2gpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIG5hbWU6ICdjaG9vc2UnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTsgLy8gQ2hvc2VuIGl0ZW1cblxuXG4gICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5jaG9zZW5DbGFzcywgdHJ1ZSk7XG4gICAgICB9OyAvLyBEaXNhYmxlIFwiZHJhZ2dhYmxlXCJcblxuXG4gICAgICBvcHRpb25zLmlnbm9yZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTsgLy8gTWFrZSBkcmFnRWwgZHJhZ2dhYmxlIChtdXN0IGJlIGJlZm9yZSBkZWxheSBmb3IgRmlyZUZveClcblxuICAgICAgaWYgKEZpcmVGb3ggJiYgdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgPSA0O1xuICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGx1Z2luRXZlbnQoJ2RlbGF5U3RhcnQnLCB0aGlzLCB7XG4gICAgICAgIGV2dDogZXZ0XG4gICAgICB9KTsgLy8gRGVsYXkgaXMgaW1wb3NzaWJsZSBmb3IgbmF0aXZlIERuRCBpbiBFZGdlIG9yIElFXG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGF5ICYmICghb3B0aW9ucy5kZWxheU9uVG91Y2hPbmx5IHx8IHRvdWNoKSAmJiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8ICEoRWRnZSB8fCBJRTExT3JMZXNzKSkpIHtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZiB0aGUgdXNlciBtb3ZlcyB0aGUgcG9pbnRlciBvciBsZXQgZ28gdGhlIGNsaWNrIG9yIHRvdWNoXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGJlZW4gcmVhY2hlZDpcbiAgICAgICAgLy8gZGlzYWJsZSB0aGUgZGVsYXllZCBkcmFnXG5cblxuICAgICAgICBvbihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNobW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRQb2ludGVyICYmIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVybW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5fZHJhZ1N0YXJ0VGltZXIgPSBzZXRUaW1lb3V0KGRyYWdTdGFydEZuLCBvcHRpb25zLmRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdTdGFydEZuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyOiBmdW5jdGlvbiBfZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKFxuICAvKiogVG91Y2hFdmVudHxQb2ludGVyRXZlbnQgKiovXG4gIGUpIHtcbiAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xuXG4gICAgaWYgKE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpID49IE1hdGguZmxvb3IodGhpcy5vcHRpb25zLnRvdWNoU3RhcnRUaHJlc2hvbGQgLyAodGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcoKTtcbiAgICB9XG4gIH0sXG4gIF9kaXNhYmxlRGVsYXllZERyYWc6IGZ1bmN0aW9uIF9kaXNhYmxlRGVsYXllZERyYWcoKSB7XG4gICAgZHJhZ0VsICYmIF9kaXNhYmxlRHJhZ2dhYmxlKGRyYWdFbCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgfSxcbiAgX3RyaWdnZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIF90cmlnZ2VyRHJhZ1N0YXJ0KFxuICAvKiogRXZlbnQgKi9cbiAgZXZ0LFxuICAvKiogVG91Y2ggKi9cbiAgdG91Y2gpIHtcbiAgICB0b3VjaCA9IHRvdWNoIHx8IGV2dC5wb2ludGVyVHlwZSA9PSAndG91Y2gnICYmIGV2dDtcblxuICAgIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUgfHwgdG91Y2gpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSBpZiAodG91Y2gpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb24oZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIFRpbWVvdXQgbmVjY2Vzc2FyeSBmb3IgSUU5XG4gICAgICAgIF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfSxcbiAgX2RyYWdTdGFydGVkOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0ZWQoZmFsbGJhY2ssIGV2dCkge1xuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJvb3RFbCAmJiBkcmFnRWwpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnRlZCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja091dHNpZGVUYXJnZXRFbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBBcHBseSBlZmZlY3RcblxuICAgICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgIFNvcnRhYmxlLmFjdGl2ZSA9IHRoaXM7XG4gICAgICBmYWxsYmFjayAmJiB0aGlzLl9hcHBlbmRHaG9zdCgpOyAvLyBEcmFnIHN0YXJ0IGV2ZW50XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICB9XG4gIH0sXG4gIF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uIF9lbXVsYXRlRHJhZ092ZXIoKSB7XG4gICAgaWYgKHRvdWNoRXZ0KSB7XG4gICAgICB0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XG4gICAgICB0aGlzLl9sYXN0WSA9IHRvdWNoRXZ0LmNsaWVudFk7XG5cbiAgICAgIF9oaWRlR2hvc3RGb3JUYXJnZXQoKTtcblxuICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0O1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHBhcmVudCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbCh0YXJnZXQpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAocGFyZW50W2V4cGFuZG9dKSB7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHBhcmVudFtleHBhbmRvXS5fb25EcmFnT3Zlcih7XG4gICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoRXZ0LmNsaWVudFksXG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICByb290RWw6IHBhcmVudFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpbnNlcnRlZCAmJiAhdGhpcy5vcHRpb25zLmRyYWdvdmVyQnViYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICBfdW5oaWRlR2hvc3RGb3JUYXJnZXQoKTtcbiAgICB9XG4gIH0sXG4gIF9vblRvdWNoTW92ZTogZnVuY3Rpb24gX29uVG91Y2hNb3ZlKFxuICAvKipUb3VjaEV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgaWYgKHRhcEV2dCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgZmFsbGJhY2tUb2xlcmFuY2UgPSBvcHRpb25zLmZhbGxiYWNrVG9sZXJhbmNlLFxuICAgICAgICAgIGZhbGxiYWNrT2Zmc2V0ID0gb3B0aW9ucy5mYWxsYmFja09mZnNldCxcbiAgICAgICAgICB0b3VjaCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQsXG4gICAgICAgICAgZ2hvc3RNYXRyaXggPSBnaG9zdEVsICYmIG1hdHJpeChnaG9zdEVsLCB0cnVlKSxcbiAgICAgICAgICBzY2FsZVggPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZ2hvc3RFbCAmJiBnaG9zdE1hdHJpeCAmJiBnaG9zdE1hdHJpeC5kLFxuICAgICAgICAgIHJlbGF0aXZlU2Nyb2xsT2Zmc2V0ID0gUG9zaXRpb25HaG9zdEFic29sdXRlbHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAmJiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChnaG9zdFJlbGF0aXZlUGFyZW50KSxcbiAgICAgICAgICBkeCA9ICh0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFggKyBmYWxsYmFja09mZnNldC54KSAvIChzY2FsZVggfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFswXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzBdIDogMCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIGR5ID0gKHRvdWNoLmNsaWVudFkgLSB0YXBFdnQuY2xpZW50WSArIGZhbGxiYWNrT2Zmc2V0LnkpIC8gKHNjYWxlWSB8fCAxKSArIChyZWxhdGl2ZVNjcm9sbE9mZnNldCA/IHJlbGF0aXZlU2Nyb2xsT2Zmc2V0WzFdIC0gZ2hvc3RSZWxhdGl2ZVBhcmVudEluaXRpYWxTY3JvbGxbMV0gOiAwKSAvIChzY2FsZVkgfHwgMSk7IC8vIG9ubHkgc2V0IHRoZSBzdGF0dXMgdG8gZHJhZ2dpbmcsIHdoZW4gd2UgYXJlIGFjdHVhbGx5IGRyYWdnaW5nXG5cbiAgICAgIGlmICghU29ydGFibGUuYWN0aXZlICYmICFhd2FpdGluZ0RyYWdTdGFydGVkKSB7XG4gICAgICAgIGlmIChmYWxsYmFja1RvbGVyYW5jZSAmJiBNYXRoLm1heChNYXRoLmFicyh0b3VjaC5jbGllbnRYIC0gdGhpcy5fbGFzdFgpLCBNYXRoLmFicyh0b3VjaC5jbGllbnRZIC0gdGhpcy5fbGFzdFkpKSA8IGZhbGxiYWNrVG9sZXJhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZXZ0LCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdob3N0RWwpIHtcbiAgICAgICAgaWYgKGdob3N0TWF0cml4KSB7XG4gICAgICAgICAgZ2hvc3RNYXRyaXguZSArPSBkeCAtIChsYXN0RHggfHwgMCk7XG4gICAgICAgICAgZ2hvc3RNYXRyaXguZiArPSBkeSAtIChsYXN0RHkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RNYXRyaXggPSB7XG4gICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICBkOiAxLFxuICAgICAgICAgICAgZTogZHgsXG4gICAgICAgICAgICBmOiBkeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3NzTWF0cml4ID0gXCJtYXRyaXgoXCIuY29uY2F0KGdob3N0TWF0cml4LmEsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguYiwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5jLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmQsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5mLCBcIilcIik7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnd2Via2l0VHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICdtb3pUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21zVHJhbnNmb3JtJywgY3NzTWF0cml4KTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBsYXN0RHggPSBkeDtcbiAgICAgICAgbGFzdER5ID0gZHk7XG4gICAgICAgIHRvdWNoRXZ0ID0gdG91Y2g7XG4gICAgICB9XG5cbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgX2FwcGVuZEdob3N0OiBmdW5jdGlvbiBfYXBwZW5kR2hvc3QoKSB7XG4gICAgLy8gQnVnIGlmIHVzaW5nIHNjYWxlKCk6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MzcwNThcbiAgICAvLyBOb3QgYmVpbmcgYWRqdXN0ZWQgZm9yXG4gICAgaWYgKCFnaG9zdEVsKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmZhbGxiYWNrT25Cb2R5ID8gZG9jdW1lbnQuYm9keSA6IHJvb3RFbCxcbiAgICAgICAgICByZWN0ID0gZ2V0UmVjdChkcmFnRWwsIHRydWUsIFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5LCB0cnVlLCBjb250YWluZXIpLFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7IC8vIFBvc2l0aW9uIGFic29sdXRlbHlcblxuICAgICAgaWYgKFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSB7XG4gICAgICAgIC8vIEdldCByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgcGFyZW50XG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBjb250YWluZXI7XG5cbiAgICAgICAgd2hpbGUgKGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycgJiYgY3NzKGdob3N0UmVsYXRpdmVQYXJlbnQsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdob3N0UmVsYXRpdmVQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChnaG9zdFJlbGF0aXZlUGFyZW50ID09PSBkb2N1bWVudCkgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgICByZWN0LnRvcCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZWN0LmxlZnQgKz0gZ2hvc3RSZWxhdGl2ZVBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBnaG9zdEVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZ2hvc3RFbCwgb3B0aW9ucy5mYWxsYmFja0NsYXNzLCB0cnVlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgY3NzKGdob3N0RWwsICdib3gtc2l6aW5nJywgJ2JvcmRlci1ib3gnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnbWFyZ2luJywgMCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9zaXRpb24nLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA/ICdhYnNvbHV0ZScgOiAnZml4ZWQnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnekluZGV4JywgJzEwMDAwMCcpO1xuICAgICAgY3NzKGdob3N0RWwsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcbiAgICAgIFNvcnRhYmxlLmdob3N0ID0gZ2hvc3RFbDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChnaG9zdEVsKTsgLy8gU2V0IHRyYW5zZm9ybS1vcmlnaW5cblxuICAgICAgY3NzKGdob3N0RWwsICd0cmFuc2Zvcm0tb3JpZ2luJywgdGFwRGlzdGFuY2VMZWZ0IC8gcGFyc2VJbnQoZ2hvc3RFbC5zdHlsZS53aWR0aCkgKiAxMDAgKyAnJSAnICsgdGFwRGlzdGFuY2VUb3AgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLmhlaWdodCkgKiAxMDAgKyAnJScpO1xuICAgIH1cbiAgfSxcbiAgX29uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBfb25EcmFnU3RhcnQoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0LFxuICAvKipib29sZWFuKi9cbiAgZmFsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGRhdGFUcmFuc2ZlciA9IGV2dC5kYXRhVHJhbnNmZXI7XG4gICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zO1xuICAgIHBsdWdpbkV2ZW50KCdkcmFnU3RhcnQnLCB0aGlzLCB7XG4gICAgICBldnQ6IGV2dFxuICAgIH0pO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX29uRHJvcCgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2luRXZlbnQoJ3NldHVwQ2xvbmUnLCB0aGlzKTtcblxuICAgIGlmICghU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgY2xvbmVFbCA9IGNsb25lKGRyYWdFbCk7XG4gICAgICBjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgY2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuXG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgdG9nZ2xlQ2xhc3MoY2xvbmVFbCwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICBTb3J0YWJsZS5jbG9uZSA9IGNsb25lRWw7XG4gICAgfSAvLyAjMTE0MzogSUZyYW1lIHN1cHBvcnQgd29ya2Fyb3VuZFxuXG5cbiAgICBfdGhpcy5jbG9uZUlkID0gX25leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdjbG9uZScsIF90aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjbG9uZSdcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICFmYWxsYmFjayAmJiB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuZHJhZ0NsYXNzLCB0cnVlKTsgLy8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xuXG4gICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICBpZ25vcmVOZXh0Q2xpY2sgPSB0cnVlO1xuICAgICAgX3RoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKF90aGlzLl9lbXVsYXRlRHJhZ092ZXIsIDUwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB3aGF0IHdhcyBzZXQgaW4gX3ByZXBhcmVEcmFnU3RhcnQgYmVmb3JlIGRyYWcgc3RhcnRlZFxuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgb2ZmKGRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX29uRHJvcCk7XG5cbiAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAnbW92ZSc7XG4gICAgICAgIG9wdGlvbnMuc2V0RGF0YSAmJiBvcHRpb25zLnNldERhdGEuY2FsbChfdGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuICAgICAgfVxuXG4gICAgICBvbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7IC8vICMxMjc2IGZpeDpcblxuICAgICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVaKDApJyk7XG4gICAgfVxuXG4gICAgYXdhaXRpbmdEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgX3RoaXMuX2RyYWdTdGFydElkID0gX25leHRUaWNrKF90aGlzLl9kcmFnU3RhcnRlZC5iaW5kKF90aGlzLCBmYWxsYmFjaywgZXZ0KSk7XG4gICAgb24oZG9jdW1lbnQsICdzZWxlY3RzdGFydCcsIF90aGlzKTtcbiAgICBtb3ZlZCA9IHRydWU7XG5cbiAgICBpZiAoU2FmYXJpKSB7XG4gICAgICBjc3MoZG9jdW1lbnQuYm9keSwgJ3VzZXItc2VsZWN0JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gIC8vIFJldHVybnMgdHJ1ZSAtIGlmIG5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lZWRlZCAoZWl0aGVyIGluc2VydGVkIG9yIGFub3RoZXIgY29uZGl0aW9uKVxuICBfb25EcmFnT3ZlcjogZnVuY3Rpb24gX29uRHJhZ092ZXIoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgZHJhZ1JlY3QsXG4gICAgICAgIHRhcmdldFJlY3QsXG4gICAgICAgIHJldmVydCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IFNvcnRhYmxlLmFjdGl2ZSxcbiAgICAgICAgaXNPd25lciA9IGFjdGl2ZUdyb3VwID09PSBncm91cCxcbiAgICAgICAgY2FuU29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGUsXG4gICAgICAgIHZlcnRpY2FsLFxuICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGNvbXBsZXRlZEZpcmVkID0gZmFsc2U7XG5cbiAgICBpZiAoX3NpbGVudCkgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gZHJhZ092ZXJFdmVudChuYW1lLCBleHRyYSkge1xuICAgICAgcGx1Z2luRXZlbnQobmFtZSwgX3RoaXMsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgaXNPd25lcjogaXNPd25lcixcbiAgICAgICAgYXhpczogdmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICByZXZlcnQ6IHJldmVydCxcbiAgICAgICAgZHJhZ1JlY3Q6IGRyYWdSZWN0LFxuICAgICAgICB0YXJnZXRSZWN0OiB0YXJnZXRSZWN0LFxuICAgICAgICBjYW5Tb3J0OiBjYW5Tb3J0LFxuICAgICAgICBmcm9tU29ydGFibGU6IGZyb21Tb3J0YWJsZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGNvbXBsZXRlZDogY29tcGxldGVkLFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZSh0YXJnZXQsIGFmdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCBnZXRSZWN0KHRhcmdldCksIGV2dCwgYWZ0ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjaGFuZ2VkOiBjaGFuZ2VkXG4gICAgICB9LCBleHRyYSkpO1xuICAgIH0gLy8gQ2FwdHVyZSBhbmltYXRpb24gc3RhdGVcblxuXG4gICAgZnVuY3Rpb24gY2FwdHVyZSgpIHtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZScpO1xuXG4gICAgICBfdGhpcy5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIGludm9jYXRpb24gd2hlbiBkcmFnRWwgaXMgaW5zZXJ0ZWQgKG9yIGNvbXBsZXRlZClcblxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGluc2VydGlvbikge1xuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBoaWRkZW4gYmVmb3JlIGZvbGRpbmcgYW5pbWF0aW9uIHRvIGNhcHR1cmUgZHJhZ1JlY3RBYnNvbHV0ZSBwcm9wZXJseVxuICAgICAgICBpZiAoaXNPd25lcikge1xuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9oaWRlQ2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKF90aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgLy8gU2V0IGdob3N0IGNsYXNzIHRvIG5ldyBzb3J0YWJsZSdzIGdob3N0IGNsYXNzXG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBwdXRTb3J0YWJsZSA/IHB1dFNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcyA6IGFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5naG9zdENsYXNzLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgfSAvLyBBbmltYXRpb25cblxuXG4gICAgICAgIGlmIChmcm9tU29ydGFibGUgPT09IF90aGlzKSB7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gdGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZScpO1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG5cblxuICAgICAgaWYgKHRhcmdldCA9PT0gZHJhZ0VsICYmICFkcmFnRWwuYW5pbWF0ZWQgfHwgdGFyZ2V0ID09PSBlbCAmJiAhdGFyZ2V0LmFuaW1hdGVkKSB7XG4gICAgICAgIGxhc3RUYXJnZXQgPSBudWxsO1xuICAgICAgfSAvLyBubyBidWJibGluZyBhbmQgbm90IGZhbGxiYWNrXG5cblxuICAgICAgaWYgKCFvcHRpb25zLmRyYWdvdmVyQnViYmxlICYmICFldnQucm9vdEVsICYmIHRhcmdldCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgZHJhZ0VsLnBhcmVudE5vZGVbZXhwYW5kb10uX2lzT3V0c2lkZVRoaXNFbChldnQudGFyZ2V0KTsgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcblxuXG4gICAgICAgICFpbnNlcnRpb24gJiYgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQoZXZ0KTtcbiAgICAgIH1cblxuICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgIH0gLy8gQ2FsbCB3aGVuIGRyYWdFbCBoYXMgYmVlbiBpbnNlcnRlZFxuXG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICBzb3J0YWJsZTogX3RoaXMsXG4gICAgICAgIG5hbWU6ICdjaGFuZ2UnLFxuICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICBpZiAoZHJhZ0VsLmNvbnRhaW5zKGV2dC50YXJnZXQpIHx8IHRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQuYW5pbWF0aW5nWCAmJiB0YXJnZXQuYW5pbWF0aW5nWSB8fCBfdGhpcy5faWdub3JlV2hpbGVBbmltYXRpbmcgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgfVxuXG4gICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSAhcm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkpIC8vIFJldmVydGluZyBpdGVtIGludG8gdGhlIG9yaWdpbmFsIGxpc3RcbiAgICA6IHB1dFNvcnRhYmxlID09PSB0aGlzIHx8ICh0aGlzLmxhc3RQdXRNb2RlID0gYWN0aXZlR3JvdXAuY2hlY2tQdWxsKHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpICYmIGdyb3VwLmNoZWNrUHV0KHRoaXMsIGFjdGl2ZVNvcnRhYmxlLCBkcmFnRWwsIGV2dCkpKSB7XG4gICAgICB2ZXJ0aWNhbCA9IHRoaXMuX2dldERpcmVjdGlvbihldnQsIHRhcmdldCkgPT09ICd2ZXJ0aWNhbCc7XG4gICAgICBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsKTtcbiAgICAgIGRyYWdPdmVyRXZlbnQoJ2RyYWdPdmVyVmFsaWQnKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG5cbiAgICAgIGlmIChyZXZlcnQpIHtcbiAgICAgICAgcGFyZW50RWwgPSByb290RWw7IC8vIGFjdHVhbGl6YXRpb25cblxuICAgICAgICBjYXB0dXJlKCk7XG5cbiAgICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG5cbiAgICAgICAgZHJhZ092ZXJFdmVudCgncmV2ZXJ0Jyk7XG5cbiAgICAgICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbExhc3RDaGlsZCA9IGxhc3RDaGlsZChlbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgICBpZiAoIWVsTGFzdENoaWxkIHx8IF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCB0aGlzKSAmJiAhZWxMYXN0Q2hpbGQuYW5pbWF0ZWQpIHtcbiAgICAgICAgLy8gSWYgYWxyZWFkeSBhdCBlbmQgb2YgbGlzdDogRG8gbm90IGluc2VydFxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9IC8vIGFzc2lnbiB0YXJnZXQgb25seSBpZiBjb25kaXRpb24gaXMgdHJ1ZVxuXG5cbiAgICAgICAgaWYgKGVsTGFzdENoaWxkICYmIGVsID09PSBldnQudGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZWxMYXN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCAhIXRhcmdldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwLFxuICAgICAgICAgICAgZGlmZmVyZW50TGV2ZWwgPSBkcmFnRWwucGFyZW50Tm9kZSAhPT0gZWwsXG4gICAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgICBzaWRlMSA9IHZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICBzY3JvbGxlZFBhc3RUb3AgPSBpc1Njcm9sbGVkUGFzdCh0YXJnZXQsICd0b3AnLCAndG9wJykgfHwgaXNTY3JvbGxlZFBhc3QoZHJhZ0VsLCAndG9wJywgJ3RvcCcpLFxuICAgICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcblxuICAgICAgICBpZiAobGFzdFRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0QmVmb3JlRmlyc3RTd2FwID0gdGFyZ2V0UmVjdFtzaWRlMV07XG4gICAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgICAgICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9ICFkaWZmZXJlbnRSb3dDb2wgJiYgb3B0aW9ucy5pbnZlcnRTd2FwIHx8IGRpZmZlcmVudExldmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlyZWN0aW9uID0gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBkaWZmZXJlbnRSb3dDb2wgPyAxIDogb3B0aW9ucy5zd2FwVGhyZXNob2xkLCBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCA9PSBudWxsID8gb3B0aW9ucy5zd2FwVGhyZXNob2xkIDogb3B0aW9ucy5pbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQsIGxhc3RUYXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgIHZhciBzaWJsaW5nO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZHJhZ0luZGV4IC09IGRpcmVjdGlvbjtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnRFbC5jaGlsZHJlbltkcmFnSW5kZXhdO1xuICAgICAgICAgIH0gd2hpbGUgKHNpYmxpbmcgJiYgKGNzcyhzaWJsaW5nLCAnZGlzcGxheScpID09PSAnbm9uZScgfHwgc2libGluZyA9PT0gZ2hvc3RFbCkpO1xuICAgICAgICB9IC8vIElmIGRyYWdFbCBpcyBhbHJlYWR5IGJlc2lkZSB0YXJnZXQ6IERvIG5vdCBpbnNlcnRcblxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBsYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuICAgICAgICAgICAgYWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgYWZ0ZXIgPSBkaXJlY3Rpb24gPT09IDE7XG5cbiAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG5cbiAgICAgICAgaWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG1vdmVWZWN0b3IgPT09IDEgfHwgbW92ZVZlY3RvciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGFmdGVyID0gbW92ZVZlY3RvciA9PT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc2lsZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF91bnNpbGVudCwgMzApO1xuICAgICAgICAgIGNhcHR1cmUoKTtcblxuICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgIH0gLy8gVW5kbyBjaHJvbWUncyBzY3JvbGwgYWRqdXN0bWVudCAoaGFzIG5vIGVmZmVjdCBvbiBvdGhlciBicm93c2VycylcblxuXG4gICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlOyAvLyBhY3R1YWxpemF0aW9uXG4gICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cblxuICAgICAgICAgIGlmICh0YXJnZXRCZWZvcmVGaXJzdFN3YXAgIT09IHVuZGVmaW5lZCAmJiAhaXNDaXJjdW1zdGFudGlhbEludmVydCkge1xuICAgICAgICAgICAgdGFyZ2V0TW92ZURpc3RhbmNlID0gTWF0aC5hYnModGFyZ2V0QmVmb3JlRmlyc3RTd2FwIC0gZ2V0UmVjdCh0YXJnZXQpW3NpZGUxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBfaWdub3JlV2hpbGVBbmltYXRpbmc6IG51bGwsXG4gIF9vZmZNb3ZlRXZlbnRzOiBmdW5jdGlvbiBfb2ZmTW92ZUV2ZW50cygpIHtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gIH0sXG4gIF9vZmZVcEV2ZW50czogZnVuY3Rpb24gX29mZlVwRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uRHJvcCk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH0sXG4gIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoXG4gIC8qKkV2ZW50Ki9cbiAgZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG5cbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBwbHVnaW5FdmVudCgnZHJvcCcsIHRoaXMsIHtcbiAgICAgIGV2dDogZXZ0XG4gICAgfSk7XG4gICAgcGFyZW50RWwgPSBkcmFnRWwgJiYgZHJhZ0VsLnBhcmVudE5vZGU7IC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcblxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuXG4gICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpc0NpcmN1bXN0YW50aWFsSW52ZXJ0ID0gZmFsc2U7XG4gICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gZmFsc2U7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9sb29wSWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cbiAgICBfY2FuY2VsTmV4dFRpY2sodGhpcy5jbG9uZUlkKTtcblxuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7IC8vIFVuYmluZCBldmVudHNcblxuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2ZmTW92ZUV2ZW50cygpO1xuXG4gICAgdGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgfVxuXG4gICAgY3NzKGRyYWdFbCwgJ3RyYW5zZm9ybScsICcnKTtcblxuICAgIGlmIChldnQpIHtcbiAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICBldnQuY2FuY2VsYWJsZSAmJiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgIW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuICAgICAgaWYgKHJvb3RFbCA9PT0gcGFyZW50RWwgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNsb25lKHMpXG4gICAgICAgIGNsb25lRWwgJiYgY2xvbmVFbC5wYXJlbnROb2RlICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBvZmYoZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcblxuICAgICAgICBkcmFnRWwuc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJzsgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuXG4gICAgICAgIGlmIChtb3ZlZCAmJiAhYXdhaXRpbmdEcmFnU3RhcnRlZCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKGRyYWdFbCwgcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5vcHRpb25zLmdob3N0Q2xhc3MgOiB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTsgLy8gRHJhZyBzdG9wIGV2ZW50XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgIG5hbWU6ICd1bmNob29zZScsXG4gICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgbmV3SW5kZXg6IG51bGwsXG4gICAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pOyAvLyBSZW1vdmUgZXZlbnRcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7IC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblxuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICBzb3J0YWJsZTogdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTb3J0YWJsZS5hY3RpdmUpIHtcbiAgICAgICAgICAvKiBqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgICAgICAgICBpZiAobmV3SW5kZXggPT0gbnVsbCB8fCBuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gb2xkSW5kZXg7XG4gICAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pOyAvLyBTYXZlIHNvcnRpbmdcblxuXG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9udWxsaW5nKCk7XG4gIH0sXG4gIF9udWxsaW5nOiBmdW5jdGlvbiBfbnVsbGluZygpIHtcbiAgICBwbHVnaW5FdmVudCgnbnVsbGluZycsIHRoaXMpO1xuICAgIHJvb3RFbCA9IGRyYWdFbCA9IHBhcmVudEVsID0gZ2hvc3RFbCA9IG5leHRFbCA9IGNsb25lRWwgPSBsYXN0RG93bkVsID0gY2xvbmVIaWRkZW4gPSB0YXBFdnQgPSB0b3VjaEV2dCA9IG1vdmVkID0gbmV3SW5kZXggPSBuZXdEcmFnZ2FibGVJbmRleCA9IG9sZEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXggPSBsYXN0VGFyZ2V0ID0gbGFzdERpcmVjdGlvbiA9IHB1dFNvcnRhYmxlID0gYWN0aXZlR3JvdXAgPSBTb3J0YWJsZS5kcmFnZ2VkID0gU29ydGFibGUuZ2hvc3QgPSBTb3J0YWJsZS5jbG9uZSA9IFNvcnRhYmxlLmFjdGl2ZSA9IG51bGw7XG4gICAgc2F2ZWRJbnB1dENoZWNrZWQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IGxhc3REeCA9IGxhc3REeSA9IDA7XG4gIH0sXG4gIGhhbmRsZUV2ZW50OiBmdW5jdGlvbiBoYW5kbGVFdmVudChcbiAgLyoqRXZlbnQqL1xuICBldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICBjYXNlICdkcm9wJzpcbiAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZHJhZ2VudGVyJzpcbiAgICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICAgICAgaWYgKGRyYWdFbCkge1xuICAgICAgICAgIHRoaXMuX29uRHJhZ092ZXIoZXZ0KTtcblxuICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgICAgZWwsXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5lbC5jaGlsZHJlbixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgZWwgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSkpIHtcbiAgICAgICAgb3JkZXIucHVzaChlbC5nZXRBdHRyaWJ1dGUob3B0aW9ucy5kYXRhSWRBdHRyKSB8fCBfZ2VuZXJhdGVJZChlbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcmRlcjtcbiAgfSxcblxuICAvKipcbiAgICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSAgb3JkZXIgIG9yZGVyIG9mIHRoZSBpdGVtc1xuICAgKi9cbiAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlciwgdXNlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICAgIHJvb3RFbCA9IHRoaXMuZWw7XG4gICAgdGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgIHZhciBlbCA9IHJvb3RFbC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGNsb3Nlc3QoZWwsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHJvb3RFbCwgZmFsc2UpKSB7XG4gICAgICAgIGl0ZW1zW2lkXSA9IGVsO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoaXRlbXNbaWRdKSB7XG4gICAgICAgIHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgICByb290RWwuYXBwZW5kQ2hpbGQoaXRlbXNbaWRdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VBbmltYXRpb24gJiYgdGhpcy5hbmltYXRlQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgdGhlIGN1cnJlbnQgc29ydGluZ1xuICAgKi9cbiAgc2F2ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XG4gICAgc3RvcmUgJiYgc3RvcmUuc2V0ICYmIHN0b3JlLnNldCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbFxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICBbc2VsZWN0b3JdICBkZWZhdWx0OiBgb3B0aW9ucy5kcmFnZ2FibGVgXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBjbG9zZXN0KGVsLCBzZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldC9nZXQgb3B0aW9uXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICBpZiAodHlwZW9mIG1vZGlmaWVkVmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSBtb2RpZmllZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICBfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveVxuICAgKi9cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBwbHVnaW5FdmVudCgnZGVzdHJveScsIHRoaXMpO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgZWxbZXhwYW5kb10gPSBudWxsO1xuICAgIG9mZihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9mZihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICdwb2ludGVyZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuICAgICAgb2ZmKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG4gICAgfSAvLyBSZW1vdmUgZHJhZ2dhYmxlIGF0dHJpYnV0ZXNcblxuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dhYmxlJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vbkRyb3AoKTtcblxuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuXG4gICAgc29ydGFibGVzLnNwbGljZShzb3J0YWJsZXMuaW5kZXhPZih0aGlzLmVsKSwgMSk7XG4gICAgdGhpcy5lbCA9IGVsID0gbnVsbDtcbiAgfSxcbiAgX2hpZGVDbG9uZTogZnVuY3Rpb24gX2hpZGVDbG9uZSgpIHtcbiAgICBpZiAoIWNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnaGlkZUNsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2xvbmVFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuXG4gICAgICBjbG9uZUhpZGRlbiA9IHRydWU7XG4gICAgfVxuICB9LFxuICBfc2hvd0Nsb25lOiBmdW5jdGlvbiBfc2hvd0Nsb25lKHB1dFNvcnRhYmxlKSB7XG4gICAgaWYgKHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICB0aGlzLl9oaWRlQ2xvbmUoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjbG9uZUhpZGRlbikge1xuICAgICAgcGx1Z2luRXZlbnQoJ3Nob3dDbG9uZScsIHRoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjsgLy8gc2hvdyBjbG9uZSBhdCBkcmFnRWwgb3Igb3JpZ2luYWwgcG9zaXRpb25cblxuICAgICAgaWYgKGRyYWdFbC5wYXJlbnROb2RlID09IHJvb3RFbCAmJiAhdGhpcy5vcHRpb25zLmdyb3VwLnJldmVydENsb25lKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dEVsKSB7XG4gICAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgbmV4dEVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcbiAgICAgIH1cblxuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJycpO1xuICAgICAgY2xvbmVIaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9nbG9iYWxEcmFnT3Zlcihcbi8qKkV2ZW50Ki9cbmV2dCkge1xuICBpZiAoZXZ0LmRhdGFUcmFuc2Zlcikge1xuICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxuXG4gIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBfb25Nb3ZlKGZyb21FbCwgdG9FbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0RWwsIHRhcmdldFJlY3QsIG9yaWdpbmFsRXZlbnQsIHdpbGxJbnNlcnRBZnRlcikge1xuICB2YXIgZXZ0LFxuICAgICAgc29ydGFibGUgPSBmcm9tRWxbZXhwYW5kb10sXG4gICAgICBvbk1vdmVGbiA9IHNvcnRhYmxlLm9wdGlvbnMub25Nb3ZlLFxuICAgICAgcmV0VmFsOyAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuXG4gIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQgJiYgIUlFMTFPckxlc3MgJiYgIUVkZ2UpIHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vdmUnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQoJ21vdmUnLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGV2dC50byA9IHRvRWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsO1xuICBldnQuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgZXZ0LmRyYWdnZWRSZWN0ID0gZHJhZ1JlY3Q7XG4gIGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcbiAgZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBnZXRSZWN0KHRvRWwpO1xuICBldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGZyb21FbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgaWYgKG9uTW92ZUZuKSB7XG4gICAgcmV0VmFsID0gb25Nb3ZlRm4uY2FsbChzb3J0YWJsZSwgZXZ0LCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuXG4gIHJldHVybiByZXRWYWw7XG59XG5cbmZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG4gIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdW5zaWxlbnQoKSB7XG4gIF9zaWxlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX2dob3N0SXNMYXN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciByZWN0ID0gZ2V0UmVjdChsYXN0Q2hpbGQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMuZHJhZ2dhYmxlKSk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPiByZWN0LnJpZ2h0ICsgc3BhY2VyIHx8IGV2dC5jbGllbnRYIDw9IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LmJvdHRvbSAmJiBldnQuY2xpZW50WCA+PSByZWN0LmxlZnQgOiBldnQuY2xpZW50WCA+IHJlY3QucmlnaHQgJiYgZXZ0LmNsaWVudFkgPiByZWN0LnRvcCB8fCBldnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2dC5jbGllbnRZID4gcmVjdC5ib3R0b20gKyBzcGFjZXI7XG59XG5cbmZ1bmN0aW9uIF9nZXRTd2FwRGlyZWN0aW9uKGV2dCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCwgc3dhcFRocmVzaG9sZCwgaW52ZXJ0ZWRTd2FwVGhyZXNob2xkLCBpbnZlcnRTd2FwLCBpc0xhc3RUYXJnZXQpIHtcbiAgdmFyIG1vdXNlT25BeGlzID0gdmVydGljYWwgPyBldnQuY2xpZW50WSA6IGV2dC5jbGllbnRYLFxuICAgICAgdGFyZ2V0TGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgICB0YXJnZXRTMSA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC50b3AgOiB0YXJnZXRSZWN0LmxlZnQsXG4gICAgICB0YXJnZXRTMiA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5ib3R0b20gOiB0YXJnZXRSZWN0LnJpZ2h0LFxuICAgICAgaW52ZXJ0ID0gZmFsc2U7XG5cbiAgaWYgKCFpbnZlcnRTd2FwKSB7XG4gICAgLy8gTmV2ZXIgaW52ZXJ0IG9yIGNyZWF0ZSBkcmFnRWwgc2hhZG93IHdoZW4gdGFyZ2V0IG1vdmVtZW5ldCBjYXVzZXMgbW91c2UgdG8gbW92ZSBwYXN0IHRoZSBlbmQgb2YgcmVndWxhciBzd2FwVGhyZXNob2xkXG4gICAgaWYgKGlzTGFzdFRhcmdldCAmJiB0YXJnZXRNb3ZlRGlzdGFuY2UgPCB0YXJnZXRMZW5ndGggKiBzd2FwVGhyZXNob2xkKSB7XG4gICAgICAvLyBtdWx0aXBsaWVkIG9ubHkgYnkgc3dhcFRocmVzaG9sZCBiZWNhdXNlIG1vdXNlIHdpbGwgYWxyZWFkeSBiZSBpbnNpZGUgdGFyZ2V0IGJ5ICgxIC0gdGhyZXNob2xkKSAqIHRhcmdldExlbmd0aCAvIDJcbiAgICAgIC8vIGNoZWNrIGlmIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCBvbiBzaWRlIG9wcG9zaXRlIG9mIGxhc3REaXJlY3Rpb25cbiAgICAgIGlmICghcGFzdEZpcnN0SW52ZXJ0VGhyZXNoICYmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgOiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogaW52ZXJ0ZWRTd2FwVGhyZXNob2xkIC8gMikpIHtcbiAgICAgICAgLy8gcGFzdCBmaXJzdCBpbnZlcnQgdGhyZXNob2xkLCBkbyBub3QgcmVzdHJpY3QgaW52ZXJ0ZWQgdGhyZXNob2xkIHRvIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgcGFzdEZpcnN0SW52ZXJ0VGhyZXNoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXN0Rmlyc3RJbnZlcnRUaHJlc2gpIHtcbiAgICAgICAgLy8gZHJhZ0VsIHNoYWRvdyAodGFyZ2V0IG1vdmUgZGlzdGFuY2Ugc2hhZG93KVxuICAgICAgICBpZiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRNb3ZlRGlzdGFuY2UgLy8gb3ZlciBkcmFnRWwgc2hhZG93XG4gICAgICAgIDogbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldE1vdmVEaXN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiAtbGFzdERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52ZXJ0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhclxuICAgICAgaWYgKG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMiAmJiBtb3VzZU9uQXhpcyA8IHRhcmdldFMyIC0gdGFyZ2V0TGVuZ3RoICogKDEgLSBzd2FwVGhyZXNob2xkKSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnZlcnQgPSBpbnZlcnQgfHwgaW52ZXJ0U3dhcDtcblxuICBpZiAoaW52ZXJ0KSB7XG4gICAgLy8gSW52ZXJ0IG9mIHJlZ3VsYXJcbiAgICBpZiAobW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIgfHwgbW91c2VPbkF4aXMgPiB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpIHtcbiAgICAgIHJldHVybiBtb3VzZU9uQXhpcyA+IHRhcmdldFMxICsgdGFyZ2V0TGVuZ3RoIC8gMiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcbiAqIHNlZW0gdGhhdCBkcmFnRWwgaGFzIGJlZW4gXCJpbnNlcnRlZFwiIGludG8gdGhhdCBlbGVtZW50J3MgcG9zaXRpb25cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICAgICAgVGhlIHRhcmdldCB3aG9zZSBwb3NpdGlvbiBkcmFnRWwgaXMgYmVpbmcgaW5zZXJ0ZWQgYXRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIF9nZXRJbnNlcnREaXJlY3Rpb24odGFyZ2V0KSB7XG4gIGlmIChpbmRleChkcmFnRWwpIDwgaW5kZXgodGFyZ2V0KSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZSBpZFxuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSBlbFxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICAgIGkgPSBzdHIubGVuZ3RoLFxuICAgICAgc3VtID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIHN1bS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIF9zYXZlSW5wdXRDaGVja2VkU3RhdGUocm9vdCkge1xuICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSAwO1xuICB2YXIgaW5wdXRzID0gcm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5wdXQnKTtcbiAgdmFyIGlkeCA9IGlucHV0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbmV4dFRpY2soZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiBfY2FuY2VsTmV4dFRpY2soaWQpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59IC8vIEZpeGVkICM5NzM6XG5cblxuaWYgKGRvY3VtZW50RXhpc3RzKSB7XG4gIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmICgoU29ydGFibGUuYWN0aXZlIHx8IGF3YWl0aW5nRHJhZ1N0YXJ0ZWQpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufSAvLyBFeHBvcnQgdXRpbHNcblxuXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGRcbn07XG4vKipcbiAqIEdldCB0aGUgU29ydGFibGUgaW5zdGFuY2Ugb2YgYW4gZWxlbWVudFxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NvcnRhYmxlfHVuZGVmaW5lZH0gICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgU29ydGFibGVcbiAqL1xuXG5Tb3J0YWJsZS5nZXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudFtleHBhbmRvXTtcbn07XG4vKipcbiAqIE1vdW50IGEgcGx1Z2luIHRvIFNvcnRhYmxlXG4gKiBAcGFyYW0gIHsuLi5Tb3J0YWJsZVBsdWdpbnxTb3J0YWJsZVBsdWdpbltdfSBwbHVnaW5zICAgICAgIFBsdWdpbnMgYmVpbmcgbW91bnRlZFxuICovXG5cblxuU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocGx1Z2luc1swXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGlmICghcGx1Z2luLnByb3RvdHlwZSB8fCAhcGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgXCJTb3J0YWJsZTogTW91bnRlZCBwbHVnaW4gbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgXCIuY29uY2F0KHt9LnRvU3RyaW5nLmNhbGwocGx1Z2luKSk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbi51dGlscykgU29ydGFibGUudXRpbHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBTb3J0YWJsZS51dGlscywgcGx1Z2luLnV0aWxzKTtcbiAgICBQbHVnaW5NYW5hZ2VyLm1vdW50KHBsdWdpbik7XG4gIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxuICovXG5cblxuU29ydGFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xufTsgLy8gRXhwb3J0XG5cblxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICAgIHNjcm9sbEVsLFxuICAgIHNjcm9sbFJvb3RFbCxcbiAgICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgICBsYXN0QXV0b1Njcm9sbFgsXG4gICAgbGFzdEF1dG9TY3JvbGxZLFxuICAgIHRvdWNoRXZ0JDEsXG4gICAgcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIEF1dG9TY3JvbGxQbHVnaW4oKSB7XG4gIGZ1bmN0aW9uIEF1dG9TY3JvbGwoKSB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAzMCxcbiAgICAgIHNjcm9sbFNwZWVkOiAxMCxcbiAgICAgIGJ1YmJsZVNjcm9sbDogdHJ1ZVxuICAgIH07IC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZm9yICh2YXIgZm4gaW4gdGhpcykge1xuICAgICAgaWYgKGZuLmNoYXJBdCgwKSA9PT0gJ18nICYmIHR5cGVvZiB0aGlzW2ZuXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQXV0b1Njcm9sbC5wcm90b3R5cGUgPSB7XG4gICAgZHJhZ1N0YXJ0ZWQ6IGZ1bmN0aW9uIGRyYWdTdGFydGVkKF9yZWYpIHtcbiAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gX3JlZi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICAvLyBGb3Igd2hlbiBidWJibGluZyBpcyBjYW5jZWxlZCBhbmQgdXNpbmcgZmFsbGJhY2sgKGZhbGxiYWNrICd0b3VjaG1vdmUnIGFsd2F5cyByZWFjaGVkKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ092ZXJCdWJibGUgJiYgIW9yaWdpbmFsRXZlbnQucm9vdEVsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwob3JpZ2luYWxFdmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKCkge1xuICAgICAgaWYgKHRoaXMuc29ydGFibGUubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ2RyYWdvdmVyJywgdGhpcy5faGFuZGxlQXV0b1Njcm9sbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICB9XG5cbiAgICAgIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgIGNhbmNlbFRocm90dGxlKCk7XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgdG91Y2hFdnQkMSA9IHNjcm9sbFJvb3RFbCA9IHNjcm9sbEVsID0gc2Nyb2xsaW5nID0gcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgPSBsYXN0QXV0b1Njcm9sbFggPSBsYXN0QXV0b1Njcm9sbFkgPSBudWxsO1xuICAgICAgYXV0b1Njcm9sbHMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGw6IGZ1bmN0aW9uIF9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwoZXZ0KSB7XG4gICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKGV2dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfaGFuZGxlQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCBmYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICB0b3VjaEV2dCQxID0gZXZ0OyAvLyBJRSBkb2VzIG5vdCBzZWVtIHRvIGhhdmUgbmF0aXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBFZGdlJ3MgYXV0b3Njcm9sbCBzZWVtcyB0b28gY29uZGl0aW9uYWwsXG4gICAgICAvLyBNQUNPUyBTYWZhcmkgZG9lcyBub3QgaGF2ZSBhdXRvc2Nyb2xsLFxuICAgICAgLy8gRmlyZWZveCBhbmQgQ2hyb21lIGFyZSBnb29kXG5cbiAgICAgIGlmIChmYWxsYmFjayB8fCBFZGdlIHx8IElFMTFPckxlc3MgfHwgU2FmYXJpKSB7XG4gICAgICAgIGF1dG9TY3JvbGwoZXZ0LCB0aGlzLm9wdGlvbnMsIGVsZW0sIGZhbGxiYWNrKTsgLy8gTGlzdGVuZXIgZm9yIHBvaW50ZXIgZWxlbWVudCBjaGFuZ2VcblxuICAgICAgICB2YXIgb2dFbGVtU2Nyb2xsZXIgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKTtcblxuICAgICAgICBpZiAoc2Nyb2xsaW5nICYmICghcG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwgfHwgeCAhPT0gbGFzdEF1dG9TY3JvbGxYIHx8IHkgIT09IGxhc3RBdXRvU2Nyb2xsWSkpIHtcbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCAmJiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCk7IC8vIERldGVjdCBmb3IgcG9pbnRlciBlbGVtIGNoYW5nZSwgZW11bGF0aW5nIG5hdGl2ZSBEbkQgYmVoYXZpb3VyXG5cbiAgICAgICAgICBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbGVtID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdFbGVtICE9PSBvZ0VsZW1TY3JvbGxlcikge1xuICAgICAgICAgICAgICBvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XG4gICAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXV0b1Njcm9sbChldnQsIF90aGlzLm9wdGlvbnMsIG5ld0VsZW0sIGZhbGxiYWNrKTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxYID0geDtcbiAgICAgICAgICBsYXN0QXV0b1Njcm9sbFkgPSB5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBEbkQgaXMgZW5hYmxlZCAoYW5kIGJyb3dzZXIgaGFzIGdvb2QgYXV0b3Njcm9sbGluZyksIGZpcnN0IGF1dG9zY3JvbGwgd2lsbCBhbHJlYWR5IHNjcm9sbCwgc28gZ2V0IHBhcmVudCBhdXRvc2Nyb2xsIG9mIGZpcnN0IGF1dG9zY3JvbGxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYnViYmxlU2Nyb2xsIHx8IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KGVsZW0sIHRydWUpID09PSBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCkpIHtcbiAgICAgICAgICBjbGVhckF1dG9TY3JvbGxzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXV0b1Njcm9sbChldnQsIHRoaXMub3B0aW9ucywgZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoQXV0b1Njcm9sbCwge1xuICAgIHBsdWdpbk5hbWU6ICdzY3JvbGwnLFxuICAgIGluaXRpYWxpemVCeURlZmF1bHQ6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQXV0b1Njcm9sbHMoKSB7XG4gIGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24gKGF1dG9TY3JvbGwpIHtcbiAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGwucGlkKTtcbiAgfSk7XG4gIGF1dG9TY3JvbGxzID0gW107XG59XG5cbmZ1bmN0aW9uIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKSB7XG4gIGNsZWFySW50ZXJ2YWwocG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwpO1xufVxuXG52YXIgYXV0b1Njcm9sbCA9IHRocm90dGxlKGZ1bmN0aW9uIChldnQsIG9wdGlvbnMsIHJvb3RFbCwgaXNGYWxsYmFjaykge1xuICAvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuICBpZiAoIW9wdGlvbnMuc2Nyb2xsKSByZXR1cm47XG4gIHZhciB4ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFgsXG4gICAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgICBzZW5zID0gb3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eSxcbiAgICAgIHNwZWVkID0gb3B0aW9ucy5zY3JvbGxTcGVlZCxcbiAgICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgc2Nyb2xsVGhpc0luc3RhbmNlID0gZmFsc2UsXG4gICAgICBzY3JvbGxDdXN0b21GbjsgLy8gTmV3IHNjcm9sbCByb290LCBzZXQgc2Nyb2xsRWxcblxuICBpZiAoc2Nyb2xsUm9vdEVsICE9PSByb290RWwpIHtcbiAgICBzY3JvbGxSb290RWwgPSByb290RWw7XG4gICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgIHNjcm9sbEVsID0gb3B0aW9ucy5zY3JvbGw7XG4gICAgc2Nyb2xsQ3VzdG9tRm4gPSBvcHRpb25zLnNjcm9sbEZuO1xuXG4gICAgaWYgKHNjcm9sbEVsID09PSB0cnVlKSB7XG4gICAgICBzY3JvbGxFbCA9IGdldFBhcmVudEF1dG9TY3JvbGxFbGVtZW50KHJvb3RFbCwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxheWVyc091dCA9IDA7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gc2Nyb2xsRWw7XG5cbiAgZG8ge1xuICAgIHZhciBlbCA9IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIHJlY3QgPSBnZXRSZWN0KGVsKSxcbiAgICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tLFxuICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICByaWdodCA9IHJlY3QucmlnaHQsXG4gICAgICAgIHdpZHRoID0gcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICAgIGNhblNjcm9sbFggPSB2b2lkIDAsXG4gICAgICAgIGNhblNjcm9sbFkgPSB2b2lkIDAsXG4gICAgICAgIHNjcm9sbFdpZHRoID0gZWwuc2Nyb2xsV2lkdGgsXG4gICAgICAgIHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgICAgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgICBzY3JvbGxQb3NYID0gZWwuc2Nyb2xsTGVmdCxcbiAgICAgICAgc2Nyb2xsUG9zWSA9IGVsLnNjcm9sbFRvcDtcblxuICAgIGlmIChlbCA9PT0gd2luU2Nyb2xsZXIpIHtcbiAgICAgIGNhblNjcm9sbFggPSB3aWR0aCA8IHNjcm9sbFdpZHRoICYmIChlbENTUy5vdmVyZmxvd1ggPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Zpc2libGUnKTtcbiAgICAgIGNhblNjcm9sbFkgPSBoZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgKGVsQ1NTLm92ZXJmbG93WSA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Njcm9sbCcgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAndmlzaWJsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnKTtcbiAgICB9XG5cbiAgICB2YXIgdnggPSBjYW5TY3JvbGxYICYmIChNYXRoLmFicyhyaWdodCAtIHgpIDw9IHNlbnMgJiYgc2Nyb2xsUG9zWCArIHdpZHRoIDwgc2Nyb2xsV2lkdGgpIC0gKE1hdGguYWJzKGxlZnQgLSB4KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWCk7XG4gICAgdmFyIHZ5ID0gY2FuU2Nyb2xsWSAmJiAoTWF0aC5hYnMoYm90dG9tIC0geSkgPD0gc2VucyAmJiBzY3JvbGxQb3NZICsgaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0KSAtIChNYXRoLmFicyh0b3AgLSB5KSA8PSBzZW5zICYmICEhc2Nyb2xsUG9zWSk7XG5cbiAgICBpZiAoIWF1dG9TY3JvbGxzW2xheWVyc091dF0pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxheWVyc091dDsgaSsrKSB7XG4gICAgICAgIGlmICghYXV0b1Njcm9sbHNbaV0pIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsc1tpXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggIT0gdnggfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSAhPSB2eSB8fCBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLmVsICE9PSBlbCkge1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCA9IGVsO1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eCA9IHZ4O1xuICAgICAgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS52eSA9IHZ5O1xuICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCk7XG5cbiAgICAgIGlmICh2eCAhPSAwIHx8IHZ5ICE9IDApIHtcbiAgICAgICAgc2Nyb2xsVGhpc0luc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgLyoganNoaW50IGxvb3BmdW5jOnRydWUgKi9cblxuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICBpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICBTb3J0YWJsZS5hY3RpdmUuX29uVG91Y2hNb3ZlKHRvdWNoRXZ0JDEpOyAvLyBUbyBtb3ZlIGdob3N0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFkgPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eSA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ICogc3BlZWQgOiAwO1xuICAgICAgICAgIHZhciBzY3JvbGxPZmZzZXRYID0gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnggPyBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCAqIHNwZWVkIDogMDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsQ3VzdG9tRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxDdXN0b21Gbi5jYWxsKFNvcnRhYmxlLmRyYWdnZWQucGFyZW50Tm9kZVtleHBhbmRvXSwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCQxLCBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCkgIT09ICdjb250aW51ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjcm9sbEJ5KGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLmVsLCBzY3JvbGxPZmZzZXRYLCBzY3JvbGxPZmZzZXRZKTtcbiAgICAgICAgfS5iaW5kKHtcbiAgICAgICAgICBsYXllcjogbGF5ZXJzT3V0XG4gICAgICAgIH0pLCAyNCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGF5ZXJzT3V0Kys7XG4gIH0gd2hpbGUgKG9wdGlvbnMuYnViYmxlU2Nyb2xsICYmIGN1cnJlbnRQYXJlbnQgIT09IHdpblNjcm9sbGVyICYmIChjdXJyZW50UGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoY3VycmVudFBhcmVudCwgZmFsc2UpKSk7XG5cbiAgc2Nyb2xsaW5nID0gc2Nyb2xsVGhpc0luc3RhbmNlOyAvLyBpbiBjYXNlIGFub3RoZXIgZnVuY3Rpb24gY2F0Y2hlcyBzY3JvbGxpbmcgYXMgZmFsc2UgaW4gYmV0d2VlbiB3aGVuIGl0IGlzIG5vdFxufSwgMzApO1xuXG52YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoX3JlZikge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICAgIHB1dFNvcnRhYmxlID0gX3JlZi5wdXRTb3J0YWJsZSxcbiAgICAgIGRyYWdFbCA9IF9yZWYuZHJhZ0VsLFxuICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZi5kaXNwYXRjaFNvcnRhYmxlRXZlbnQsXG4gICAgICBoaWRlR2hvc3RGb3JUYXJnZXQgPSBfcmVmLmhpZGVHaG9zdEZvclRhcmdldCxcbiAgICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi51bmhpZGVHaG9zdEZvclRhcmdldDtcbiAgaWYgKCFvcmlnaW5hbEV2ZW50KSByZXR1cm47XG4gIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGU7XG4gIGhpZGVHaG9zdEZvclRhcmdldCgpO1xuICB2YXIgdG91Y2ggPSBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IG9yaWdpbmFsRXZlbnQ7XG4gIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICB1bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuXG4gIGlmICh0b1NvcnRhYmxlICYmICF0b1NvcnRhYmxlLmVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ3NwaWxsJyk7XG4gICAgdGhpcy5vblNwaWxsKHtcbiAgICAgIGRyYWdFbDogZHJhZ0VsLFxuICAgICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlXG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJldmVydCgpIHt9XG5cblJldmVydC5wcm90b3R5cGUgPSB7XG4gIHN0YXJ0SW5kZXg6IG51bGwsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgdmFyIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZjIub2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIH0sXG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjMpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlO1xuICAgIHRoaXMuc29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICBpZiAocHV0U29ydGFibGUpIHtcbiAgICAgIHB1dFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBuZXh0U2libGluZyA9IGdldENoaWxkKHRoaXMuc29ydGFibGUuZWwsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgdGhpcy5zb3J0YWJsZS5lbC5pbnNlcnRCZWZvcmUoZHJhZ0VsLCBuZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuYXBwZW5kQ2hpbGQoZHJhZ0VsKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcblxuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIH1cbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcblxuX2V4dGVuZHMoUmV2ZXJ0LCB7XG4gIHBsdWdpbk5hbWU6ICdyZXZlcnRPblNwaWxsJ1xufSk7XG5cbmZ1bmN0aW9uIFJlbW92ZSgpIHt9XG5cblJlbW92ZS5wcm90b3R5cGUgPSB7XG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjQpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjQuZHJhZ0VsLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWY0LnB1dFNvcnRhYmxlO1xuICAgIHZhciBwYXJlbnRTb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgcGFyZW50U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgZHJhZ0VsLnBhcmVudE5vZGUgJiYgZHJhZ0VsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJhZ0VsKTtcbiAgICBwYXJlbnRTb3J0YWJsZS5hbmltYXRlQWxsKCk7XG4gIH0sXG4gIGRyb3A6IGRyb3Bcbn07XG5cbl9leHRlbmRzKFJlbW92ZSwge1xuICBwbHVnaW5OYW1lOiAncmVtb3ZlT25TcGlsbCdcbn0pO1xuXG52YXIgbGFzdFN3YXBFbDtcblxuZnVuY3Rpb24gU3dhcFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gU3dhcCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc3dhcENsYXNzOiAnc29ydGFibGUtc3dhcC1oaWdobGlnaHQnXG4gICAgfTtcbiAgfVxuXG4gIFN3YXAucHJvdG90eXBlID0ge1xuICAgIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYpIHtcbiAgICAgIHZhciBkcmFnRWwgPSBfcmVmLmRyYWdFbDtcbiAgICAgIGxhc3RTd2FwRWwgPSBkcmFnRWw7XG4gICAgfSxcbiAgICBkcmFnT3ZlclZhbGlkOiBmdW5jdGlvbiBkcmFnT3ZlclZhbGlkKF9yZWYyKSB7XG4gICAgICB2YXIgY29tcGxldGVkID0gX3JlZjIuY29tcGxldGVkLFxuICAgICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgICBvbk1vdmUgPSBfcmVmMi5vbk1vdmUsXG4gICAgICAgICAgYWN0aXZlU29ydGFibGUgPSBfcmVmMi5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBjaGFuZ2VkID0gX3JlZjIuY2hhbmdlZCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc3dhcCkgcmV0dXJuO1xuICAgICAgdmFyIGVsID0gdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgdmFyIHByZXZTd2FwRWwgPSBsYXN0U3dhcEVsO1xuXG4gICAgICAgIGlmIChvbk1vdmUodGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIG9wdGlvbnMuc3dhcENsYXNzLCB0cnVlKTtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTd2FwRWwgJiYgcHJldlN3YXBFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHByZXZTd2FwRWwsIG9wdGlvbnMuc3dhcENsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hhbmdlZCgpO1xuICAgICAgY29tcGxldGVkKHRydWUpO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKF9yZWYzKSB7XG4gICAgICB2YXIgYWN0aXZlU29ydGFibGUgPSBfcmVmMy5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlLFxuICAgICAgICAgIGRyYWdFbCA9IF9yZWYzLmRyYWdFbDtcbiAgICAgIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgdGhpcy5zb3J0YWJsZTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgbGFzdFN3YXBFbCAmJiB0b2dnbGVDbGFzcyhsYXN0U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuXG4gICAgICBpZiAobGFzdFN3YXBFbCAmJiAob3B0aW9ucy5zd2FwIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLm9wdGlvbnMuc3dhcCkpIHtcbiAgICAgICAgaWYgKGRyYWdFbCAhPT0gbGFzdFN3YXBFbCkge1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKHRvU29ydGFibGUgIT09IGFjdGl2ZVNvcnRhYmxlKSBhY3RpdmVTb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBzd2FwTm9kZXMoZHJhZ0VsLCBsYXN0U3dhcEVsKTtcbiAgICAgICAgICB0b1NvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZzogZnVuY3Rpb24gbnVsbGluZygpIHtcbiAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKFN3YXAsIHtcbiAgICBwbHVnaW5OYW1lOiAnc3dhcCcsXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzd2FwSXRlbTogbGFzdFN3YXBFbFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzd2FwTm9kZXMobjEsIG4yKSB7XG4gIHZhciBwMSA9IG4xLnBhcmVudE5vZGUsXG4gICAgICBwMiA9IG4yLnBhcmVudE5vZGUsXG4gICAgICBpMSxcbiAgICAgIGkyO1xuICBpZiAoIXAxIHx8ICFwMiB8fCBwMS5pc0VxdWFsTm9kZShuMikgfHwgcDIuaXNFcXVhbE5vZGUobjEpKSByZXR1cm47XG4gIGkxID0gaW5kZXgobjEpO1xuICBpMiA9IGluZGV4KG4yKTtcblxuICBpZiAocDEuaXNFcXVhbE5vZGUocDIpICYmIGkxIDwgaTIpIHtcbiAgICBpMisrO1xuICB9XG5cbiAgcDEuaW5zZXJ0QmVmb3JlKG4yLCBwMS5jaGlsZHJlbltpMV0pO1xuICBwMi5pbnNlcnRCZWZvcmUobjEsIHAyLmNoaWxkcmVuW2kyXSk7XG59XG5cbnZhciBtdWx0aURyYWdFbGVtZW50cyA9IFtdLFxuICAgIG11bHRpRHJhZ0Nsb25lcyA9IFtdLFxuICAgIGxhc3RNdWx0aURyYWdTZWxlY3QsXG4gICAgLy8gZm9yIHNlbGVjdGlvbiB3aXRoIG1vZGlmaWVyIGtleSBkb3duIChTSElGVClcbm11bHRpRHJhZ1NvcnRhYmxlLFxuICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2UsXG4gICAgLy8gSW5pdGlhbCBtdWx0aS1kcmFnIGZvbGQgd2hlbiBkcmFnIHN0YXJ0ZWRcbmZvbGRpbmcgPSBmYWxzZSxcbiAgICAvLyBGb2xkaW5nIGFueSBvdGhlciB0aW1lXG5kcmFnU3RhcnRlZCA9IGZhbHNlLFxuICAgIGRyYWdFbCQxLFxuICAgIGNsb25lc0Zyb21SZWN0LFxuICAgIGNsb25lc0hpZGRlbjtcblxuZnVuY3Rpb24gTXVsdGlEcmFnUGx1Z2luKCkge1xuICBmdW5jdGlvbiBNdWx0aURyYWcoc29ydGFibGUpIHtcbiAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc29ydGFibGUub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgfVxuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fY2hlY2tLZXlEb3duKTtcbiAgICBvbihkb2N1bWVudCwgJ2tleXVwJywgdGhpcy5fY2hlY2tLZXlVcCk7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHNlbGVjdGVkQ2xhc3M6ICdzb3J0YWJsZS1zZWxlY3RlZCcsXG4gICAgICBtdWx0aURyYWdLZXk6IG51bGwsXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiBzZXREYXRhKGRhdGFUcmFuc2ZlciwgZHJhZ0VsKSB7XG4gICAgICAgIHZhciBkYXRhID0gJyc7XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBkYXRhICs9ICghaSA/ICcnIDogJywgJykgKyBtdWx0aURyYWdFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBkcmFnRWwudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBNdWx0aURyYWcucHJvdG90eXBlID0ge1xuICAgIG11bHRpRHJhZ0tleURvd246IGZhbHNlLFxuICAgIGlzTXVsdGlEcmFnOiBmYWxzZSxcbiAgICBkZWxheVN0YXJ0R2xvYmFsOiBmdW5jdGlvbiBkZWxheVN0YXJ0R2xvYmFsKF9yZWYpIHtcbiAgICAgIHZhciBkcmFnZ2VkID0gX3JlZi5kcmFnRWw7XG4gICAgICBkcmFnRWwkMSA9IGRyYWdnZWQ7XG4gICAgfSxcbiAgICBkZWxheUVuZGVkOiBmdW5jdGlvbiBkZWxheUVuZGVkKCkge1xuICAgICAgdGhpcy5pc011bHRpRHJhZyA9IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKTtcbiAgICB9LFxuICAgIHNldHVwQ2xvbmU6IGZ1bmN0aW9uIHNldHVwQ2xvbmUoX3JlZjIpIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYyLnNvcnRhYmxlLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5wdXNoKGNsb25lKG11bHRpRHJhZ0VsZW1lbnRzW2ldKSk7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5zb3J0YWJsZUluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHNbaV0uc29ydGFibGVJbmRleDtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc3R5bGVbJ3dpbGwtY2hhbmdlJ10gPSAnJztcbiAgICAgICAgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50c1tpXSA9PT0gZHJhZ0VsJDEgJiYgdG9nZ2xlQ2xhc3MobXVsdGlEcmFnQ2xvbmVzW2ldLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc29ydGFibGUuX2hpZGVDbG9uZSgpO1xuXG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShfcmVmMykge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjMuc29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjMucm9vdEVsLFxuICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYzLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmMy5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUpIHtcbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBpbnNlcnRNdWx0aURyYWdDbG9uZXModHJ1ZSwgcm9vdEVsKTtcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQoJ2Nsb25lJyk7XG4gICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dDbG9uZTogZnVuY3Rpb24gc2hvd0Nsb25lKF9yZWY0KSB7XG4gICAgICB2YXIgY2xvbmVOb3dTaG93biA9IF9yZWY0LmNsb25lTm93U2hvd24sXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjQucm9vdEVsLFxuICAgICAgICAgIGNhbmNlbCA9IF9yZWY0LmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGZhbHNlLCByb290RWwpO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93U2hvd24oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBoaWRlQ2xvbmU6IGZ1bmN0aW9uIGhpZGVDbG9uZShfcmVmNSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjUuc29ydGFibGUsXG4gICAgICAgICAgY2xvbmVOb3dIaWRkZW4gPSBfcmVmNS5jbG9uZU5vd0hpZGRlbixcbiAgICAgICAgICBjYW5jZWwgPSBfcmVmNS5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJ25vbmUnKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSAmJiBjbG9uZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xvbmVOb3dIaWRkZW4oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IHRydWU7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGRyYWdTdGFydEdsb2JhbDogZnVuY3Rpb24gZHJhZ1N0YXJ0R2xvYmFsKF9yZWY2KSB7XG4gICAgICB2YXIgc29ydGFibGUgPSBfcmVmNi5zb3J0YWJsZTtcblxuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnICYmIG11bHRpRHJhZ1NvcnRhYmxlKSB7XG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgIH1cblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgIH0pOyAvLyBTb3J0IG11bHRpLWRyYWcgZWxlbWVudHNcblxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMgPSBtdWx0aURyYWdFbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnNvcnRhYmxlSW5kZXggLSBiLnNvcnRhYmxlSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIGRyYWdTdGFydGVkOiBmdW5jdGlvbiBkcmFnU3RhcnRlZChfcmVmNykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY3LnNvcnRhYmxlO1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlEcmFnKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAvLyBDYXB0dXJlIHJlY3RzLFxuICAgICAgICAvLyBoaWRlIG11bHRpIGRyYWcgZWxlbWVudHMgKGJ5IHBvc2l0aW9uaW5nIHRoZW0gYWJzb2x1dGUpLFxuICAgICAgICAvLyBzZXQgbXVsdGkgZHJhZyBlbGVtZW50cyByZWN0cyB0byBkcmFnUmVjdCxcbiAgICAgICAgLy8gc2hvdyBtdWx0aSBkcmFnIGVsZW1lbnRzLFxuICAgICAgICAvLyBhbmltYXRlIHRvIHJlY3RzLFxuICAgICAgICAvLyB1bnNldCByZWN0cyAmIHJlbW92ZSBmcm9tIERPTVxuICAgICAgICBzb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgY3NzKG11bHRpRHJhZ0VsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzb3J0YWJsZS5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gUmVtb3ZlIGFsbCBhdXhpbGlhcnkgbXVsdGlkcmFnIGl0ZW1zIGZyb20gZWwsIGlmIHNvcnRpbmcgZW5hYmxlZFxuXG5cbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYWdPdmVyOiBmdW5jdGlvbiBkcmFnT3ZlcihfcmVmOCkge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWY4LnRhcmdldCxcbiAgICAgICAgICBjb21wbGV0ZWQgPSBfcmVmOC5jb21wbGV0ZWQsXG4gICAgICAgICAgY2FuY2VsID0gX3JlZjguY2FuY2VsO1xuXG4gICAgICBpZiAoZm9sZGluZyAmJiB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpKSB7XG4gICAgICAgIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoX3JlZjkpIHtcbiAgICAgIHZhciBmcm9tU29ydGFibGUgPSBfcmVmOS5mcm9tU29ydGFibGUsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjkucm9vdEVsLFxuICAgICAgICAgIHNvcnRhYmxlID0gX3JlZjkuc29ydGFibGUsXG4gICAgICAgICAgZHJhZ1JlY3QgPSBfcmVmOS5kcmFnUmVjdDtcblxuICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gU2V0dXAgdW5mb2xkIGFuaW1hdGlvblxuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgc29ydGFibGUuYWRkQW5pbWF0aW9uU3RhdGUoe1xuICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgcmVjdDogZm9sZGluZyA/IGdldFJlY3QobXVsdGlEcmFnRWxlbWVudCkgOiBkcmFnUmVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50LmZyb21SZWN0ID0gZHJhZ1JlY3Q7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLnJlbW92ZUFuaW1hdGlvblN0YXRlKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgICAgICBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlLCByb290RWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJDb21wbGV0ZWQ6IGZ1bmN0aW9uIGRyYWdPdmVyQ29tcGxldGVkKF9yZWYxMCkge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjEwLnNvcnRhYmxlLFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTAuaXNPd25lcixcbiAgICAgICAgICBpbnNlcnRpb24gPSBfcmVmMTAuaW5zZXJ0aW9uLFxuICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjEwLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICAgIHBhcmVudEVsID0gX3JlZjEwLnBhcmVudEVsLFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEwLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsRm9sZGluZyA9IGZhbHNlOyAvLyBJZiBsZWF2aW5nIHNvcnQ6ZmFsc2Ugcm9vdCwgb3IgYWxyZWFkeSBmb2xkaW5nIC0gRm9sZCB0byBuZXcgbG9jYXRpb25cblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSAmJiAoZm9sZGluZyB8fCAhaXNPd25lciAmJiAhYWN0aXZlU29ydGFibGUub3B0aW9ucy5zb3J0ICYmICFwdXRTb3J0YWJsZSkpIHtcbiAgICAgICAgICAvLyBGb2xkOiBTZXQgYWxsIG11bHRpIGRyYWcgZWxlbWVudHMncyByZWN0cyB0byBkcmFnRWwncyByZWN0IHdoZW4gbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW52aXNpYmxlXG4gICAgICAgICAgdmFyIGRyYWdSZWN0QWJzb2x1dGUgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0QWJzb2x1dGUpOyAvLyBNb3ZlIGVsZW1lbnQocykgdG8gZW5kIG9mIHBhcmVudEVsIHNvIHRoYXQgaXQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggbXVsdGktZHJhZyBjbG9uZXMgaW5zZXJ0aW9uIGlmIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAvLyB3aGlsZSBmb2xkaW5nLCBhbmQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSB0aGVtIGFnYWluIGJlY2F1c2Ugb2xkIHNvcnRhYmxlIHdpbGwgbm8gbG9uZ2VyIGJlIGZyb21Tb3J0YWJsZVxuXG4gICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBDbG9uZXMgbXVzdCBiZSBzaG93biAoYW5kIGNoZWNrIHRvIHJlbW92ZSBtdWx0aSBkcmFncykgYWZ0ZXIgZm9sZGluZyB3aGVuIGludGVyZmVyaW5nIG11bHRpRHJhZ0VsZW1lbnRzIGFyZSBtb3ZlZCBvdXRcblxuXG4gICAgICAgIGlmICghaXNPd25lcikge1xuICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIG5vdCBmb2xkaW5nIChmb2xkaW5nIHdpbGwgcmVtb3ZlIHRoZW0gYW55d2F5cylcbiAgICAgICAgICBpZiAoIWZvbGRpbmcpIHtcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZXNIaWRkZW5CZWZvcmUgPSBjbG9uZXNIaWRkZW47XG5cbiAgICAgICAgICAgIGFjdGl2ZVNvcnRhYmxlLl9zaG93Q2xvbmUoc29ydGFibGUpOyAvLyBVbmZvbGQgYW5pbWF0aW9uIGZvciBjbG9uZXMgaWYgc2hvd2luZyBmcm9tIGhpZGRlblxuXG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhY2xvbmVzSGlkZGVuICYmIGNsb25lc0hpZGRlbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNsb25lLFxuICAgICAgICAgICAgICAgICAgcmVjdDogY2xvbmVzRnJvbVJlY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbG9uZS5mcm9tUmVjdCA9IGNsb25lc0Zyb21SZWN0O1xuICAgICAgICAgICAgICAgIGNsb25lLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlKF9yZWYxMSkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gX3JlZjExLmRyYWdSZWN0LFxuICAgICAgICAgIGlzT3duZXIgPSBfcmVmMTEuaXNPd25lcixcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMS5hY3RpdmVTb3J0YWJsZTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhaXNPd25lciAmJiBhY3RpdmVTb3J0YWJsZS5tdWx0aURyYWcuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QgPSBfZXh0ZW5kcyh7fSwgZHJhZ1JlY3QpO1xuICAgICAgICB2YXIgZHJhZ01hdHJpeCA9IG1hdHJpeChkcmFnRWwkMSwgdHJ1ZSk7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LnRvcCAtPSBkcmFnTWF0cml4LmY7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LmxlZnQgLT0gZHJhZ01hdHJpeC5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjEyKSB7XG4gICAgICB2YXIgZXZ0ID0gX3JlZjEyLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgcm9vdEVsID0gX3JlZjEyLnJvb3RFbCxcbiAgICAgICAgICBwYXJlbnRFbCA9IF9yZWYxMi5wYXJlbnRFbCxcbiAgICAgICAgICBzb3J0YWJsZSA9IF9yZWYxMi5zb3J0YWJsZSxcbiAgICAgICAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQgPSBfcmVmMTIuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICAgIG9sZEluZGV4ID0gX3JlZjEyLm9sZEluZGV4LFxuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEyLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgaWYgKCFldnQpIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGNoaWxkcmVuID0gcGFyZW50RWwuY2hpbGRyZW47IC8vIE11bHRpLWRyYWcgc2VsZWN0aW9uXG5cbiAgICAgIGlmICghZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlEcmFnS2V5ICYmICF0aGlzLm11bHRpRHJhZ0tleURvd24pIHtcbiAgICAgICAgICB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsJDEsIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSk7XG5cbiAgICAgICAgaWYgKCF+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSkpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGRyYWdFbCQxKTtcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICB0YXJnZXRFbDogZHJhZ0VsJDEsXG4gICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgfSk7IC8vIE1vZGlmaWVyIGFjdGl2YXRlZCwgc2VsZWN0IGZyb20gbGFzdCB0byBkcmFnRWxcblxuICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgJiYgbGFzdE11bHRpRHJhZ1NlbGVjdCAmJiBzb3J0YWJsZS5lbC5jb250YWlucyhsYXN0TXVsdGlEcmFnU2VsZWN0KSkge1xuICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGluZGV4KGxhc3RNdWx0aURyYWdTZWxlY3QpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcblxuICAgICAgICAgICAgaWYgKH5sYXN0SW5kZXggJiYgfmN1cnJlbnRJbmRleCAmJiBsYXN0SW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgLy8gKGJ1dCBwcmV2aW91cyBzZWxlY3Rpb24gZXhpc3RlZClcbiAgICAgICAgICAgICAgdmFyIG4sIGk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgbiA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIG4gPSBsYXN0SW5kZXggKyAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAofm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoY2hpbGRyZW5baV0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RFbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2dDogZXZ0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE11bHRpRHJhZ1NlbGVjdCA9IGRyYWdFbCQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIE11bHRpLWRyYWcgZHJvcFxuXG5cbiAgICAgIGlmIChkcmFnU3RhcnRlZCAmJiB0aGlzLmlzTXVsdGlEcmFnKSB7XG4gICAgICAgIC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcbiAgICAgICAgaWYgKChwYXJlbnRFbFtleHBhbmRvXS5vcHRpb25zLnNvcnQgfHwgcGFyZW50RWwgIT09IHJvb3RFbCkgJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEpLFxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCA9IGluZGV4KGRyYWdFbCQxLCAnOm5vdCguJyArIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzICsgJyknKTtcbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nICYmIG9wdGlvbnMuYW5pbWF0aW9uKSBkcmFnRWwkMS50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgIHRvU29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoIWluaXRpYWxGb2xkaW5nKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgZHJhZ0VsJDEuZnJvbVJlY3QgPSBkcmFnUmVjdDtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IHJlY3Q7IC8vIFByZXBhcmUgdW5mb2xkIGFuaW1hdGlvblxuXG4gICAgICAgICAgICAgICAgICB0b1NvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0OiByZWN0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSAvLyBNdWx0aSBkcmFnIGVsZW1lbnRzIGFyZSBub3QgbmVjZXNzYXJpbHkgcmVtb3ZlZCBmcm9tIHRoZSBET00gb24gZHJvcCwgc28gdG8gcmVpbnNlcnRcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHRoZXkgbXVzdCBhbGwgYmUgcmVtb3ZlZFxuXG5cbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZHJlblttdWx0aURyYWdJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG11bHRpRHJhZ0luZGV4Kys7XG4gICAgICAgICAgICB9KTsgLy8gSWYgaW5pdGlhbCBmb2xkaW5nIGlzIGRvbmUsIHRoZSBlbGVtZW50cyBtYXkgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9uIGJlY2F1c2UgdGhleSBhcmUgbm93XG4gICAgICAgICAgICAvLyB1bmZvbGRpbmcgYXJvdW5kIGRyYWdFbCwgZXZlbiB0aG91Z2ggZHJhZ0VsIG1heSBub3QgaGF2ZSBoaXMgaW5kZXggY2hhbmdlZCwgc28gdXBkYXRlIGV2ZW50XG4gICAgICAgICAgICAvLyBtdXN0IGJlIGZpcmVkIGhlcmUgYXMgU29ydGFibGUgd2lsbCBub3QuXG5cbiAgICAgICAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgICAgIHZhciB1cGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggIT09IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgndXBkYXRlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE11c3QgYmUgZG9uZSBhZnRlciBjYXB0dXJpbmcgaW5kaXZpZHVhbCByZWN0cyAoc2Nyb2xsIGJhcilcblxuXG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbXVsdGlEcmFnU29ydGFibGUgPSB0b1NvcnRhYmxlO1xuICAgICAgfSAvLyBSZW1vdmUgY2xvbmVzIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUgJiYgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZ0dsb2JhbDogZnVuY3Rpb24gbnVsbGluZ0dsb2JhbCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBkZXN0cm95R2xvYmFsOiBmdW5jdGlvbiBkZXN0cm95R2xvYmFsKCkge1xuICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcpO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgICBvZmYoZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIH0sXG4gICAgX2Rlc2VsZWN0TXVsdGlEcmFnOiBmdW5jdGlvbiBfZGVzZWxlY3RNdWx0aURyYWcoZXZ0KSB7XG4gICAgICBpZiAodHlwZW9mIGRyYWdTdGFydGVkICE9PSBcInVuZGVmaW5lZFwiICYmIGRyYWdTdGFydGVkKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgc2VsZWN0aW9uIGlzIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICE9PSB0aGlzLnNvcnRhYmxlKSByZXR1cm47IC8vIE9ubHkgZGVzZWxlY3QgaWYgdGFyZ2V0IGlzIG5vdCBpdGVtIGluIHRoaXMgc29ydGFibGVcblxuICAgICAgaWYgKGV2dCAmJiBjbG9zZXN0KGV2dC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuc29ydGFibGUuZWwsIGZhbHNlKSkgcmV0dXJuOyAvLyBPbmx5IGRlc2VsZWN0IGlmIGxlZnQgY2xpY2tcblxuICAgICAgaWYgKGV2dCAmJiBldnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgIHdoaWxlIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGVsID0gbXVsdGlEcmFnRWxlbWVudHNbMF07XG4gICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICBzb3J0YWJsZTogdGhpcy5zb3J0YWJsZSxcbiAgICAgICAgICByb290RWw6IHRoaXMuc29ydGFibGUuZWwsXG4gICAgICAgICAgbmFtZTogJ2Rlc2VsZWN0JyxcbiAgICAgICAgICB0YXJnZXRFbDogZWwsXG4gICAgICAgICAgb3JpZ2luYWxFdnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleURvd246IGZ1bmN0aW9uIF9jaGVja0tleURvd24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmtleSA9PT0gdGhpcy5vcHRpb25zLm11bHRpRHJhZ0tleSkge1xuICAgICAgICB0aGlzLm11bHRpRHJhZ0tleURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2NoZWNrS2V5VXA6IGZ1bmN0aW9uIF9jaGVja0tleVVwKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoTXVsdGlEcmFnLCB7XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgJiBwcm9wZXJ0aWVzXG4gICAgcGx1Z2luTmFtZTogJ211bHRpRHJhZycsXG4gICAgdXRpbHM6IHtcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkXHJcbiAgICAgICAqL1xuICAgICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZWwpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXTtcbiAgICAgICAgaWYgKCFzb3J0YWJsZSB8fCAhc29ydGFibGUub3B0aW9ucy5tdWx0aURyYWcgfHwgfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZWwpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKG11bHRpRHJhZ1NvcnRhYmxlICYmIG11bHRpRHJhZ1NvcnRhYmxlICE9PSBzb3J0YWJsZSkge1xuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlLm11bHRpRHJhZy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcblxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc29ydGFibGUub3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChlbCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcclxuICAgICAgICogRGVzZWxlY3RzIHRoZSBwcm92aWRlZCBtdWx0aS1kcmFnIGl0ZW1cclxuICAgICAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsICAgIFRoZSBlbGVtZW50IHRvIGJlIGRlc2VsZWN0ZWRcclxuICAgICAgICovXG4gICAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QoZWwpIHtcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gZWwucGFyZW50Tm9kZVtleHBhbmRvXSxcbiAgICAgICAgICAgIGluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCk7XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8ICF+aW5kZXgpIHJldHVybjtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIG9sZEluZGljaWVzID0gW10sXG4gICAgICAgICAgbmV3SW5kaWNpZXMgPSBbXTtcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgb2xkSW5kaWNpZXMucHVzaCh7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICBpbmRleDogbXVsdGlEcmFnRWxlbWVudC5zb3J0YWJsZUluZGV4XG4gICAgICAgIH0pOyAvLyBtdWx0aURyYWdFbGVtZW50cyB3aWxsIGFscmVhZHkgYmUgc29ydGVkIGlmIGZvbGRpbmdcblxuICAgICAgICB2YXIgbmV3SW5kZXg7XG5cbiAgICAgICAgaWYgKGZvbGRpbmcgJiYgbXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQsICc6bm90KC4nICsgX3RoaXMzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0luZGljaWVzLnB1c2goe1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnQ6IG11bHRpRHJhZ0VsZW1lbnQsXG4gICAgICAgICAgaW5kZXg6IG5ld0luZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtczogX3RvQ29uc3VtYWJsZUFycmF5KG11bHRpRHJhZ0VsZW1lbnRzKSxcbiAgICAgICAgY2xvbmVzOiBbXS5jb25jYXQobXVsdGlEcmFnQ2xvbmVzKSxcbiAgICAgICAgb2xkSW5kaWNpZXM6IG9sZEluZGljaWVzLFxuICAgICAgICBuZXdJbmRpY2llczogbmV3SW5kaWNpZXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBvcHRpb25MaXN0ZW5lcnM6IHtcbiAgICAgIG11bHRpRHJhZ0tleTogZnVuY3Rpb24gbXVsdGlEcmFnS2V5KGtleSkge1xuICAgICAgICBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY3RybCcpIHtcbiAgICAgICAgICBrZXkgPSAnQ29udHJvbCc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdFbGVtZW50cyhjbG9uZXNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQsIGkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gcm9vdEVsLmNoaWxkcmVuW211bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCArIChjbG9uZXNJbnNlcnRlZCA/IE51bWJlcihpKSA6IDApXTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcclxuICogSW5zZXJ0IG11bHRpLWRyYWcgY2xvbmVzXHJcbiAqIEBwYXJhbSAge1tCb29sZWFuXX0gZWxlbWVudHNJbnNlcnRlZCAgV2hldGhlciB0aGUgbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW5zZXJ0ZWRcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHJvb3RFbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZWxlbWVudHNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bY2xvbmUuc29ydGFibGVJbmRleCArIChlbGVtZW50c0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZSwgdGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpIHtcbiAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZSAmJiBtdWx0aURyYWdFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gIH0pO1xufVxuXG5Tb3J0YWJsZS5tb3VudChuZXcgQXV0b1Njcm9sbFBsdWdpbigpKTtcblNvcnRhYmxlLm1vdW50KFJlbW92ZSwgUmV2ZXJ0KTtcblxuZXhwb3J0IGRlZmF1bHQgU29ydGFibGU7XG5leHBvcnQgeyBNdWx0aURyYWdQbHVnaW4gYXMgTXVsdGlEcmFnLCBTb3J0YWJsZSwgU3dhcFBsdWdpbiBhcyBTd2FwIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2819\n")}}]);