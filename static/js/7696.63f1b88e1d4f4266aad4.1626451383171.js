(self.webpackChunktemp=self.webpackChunktemp||[]).push([[7696],{7696:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"hi\": () => (/* binding */ toJpeg)\n});\n\n// UNUSED EXPORTS: getWebFontEmbedCss, toBlob, toCanvas, toPixelData, toPng, toSvg, toSvgDataURL\n\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/util.js\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n};\nconst uuid = (function uuid() {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nfunction getMimeType(url) {\n    const ext = getExtension(url).toLowerCase();\n    return mimes[ext] || '';\n}\nfunction delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(args);\n        }, ms);\n    });\n}\nfunction isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nfunction toDataURL(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nfunction getDataURLContent(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nfunction toBlob(canvas) {\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas.toDataURL().split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], { type: 'image/png' }));\n    });\n}\nfunction util_canvasToBlob(canvas) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => canvas.toBlob(resolve));\n    }\n    return toBlob(canvas);\n}\nfunction toArray(arrayLike) {\n    const result = [];\n    for (let i = 0, l = arrayLike.length; i < l; i += 1) {\n        result.push(arrayLike[i]);\n    }\n    return result;\n}\nfunction px(node, styleProperty) {\n    const val = window.getComputedStyle(node).getPropertyValue(styleProperty);\n    return parseFloat(val.replace('px', ''));\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nfunction getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) { }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\nfunction createImage(url) {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.onerror = reject;\n        image.crossOrigin = 'anonymous';\n        image.src = url;\n    });\n}\nfunction svgToDataURL(svg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return Promise.resolve()\n            .then(() => new XMLSerializer().serializeToString(svg))\n            .then(encodeURIComponent)\n            .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n    });\n}\nfunction getBlobFromImageURL(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return createImage(url).then((image) => {\n            const { width, height } = image;\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = getPixelRatio();\n            canvas.width = width * ratio;\n            canvas.height = height * ratio;\n            canvas.style.width = `${width}`;\n            canvas.style.height = `${height}`;\n            context.scale(ratio, ratio);\n            context.drawImage(image, 0, 0);\n            const dataURL = canvas.toDataURL(getMimeType(url));\n            return getDataURLContent(dataURL);\n        });\n    });\n}\n//# sourceMappingURL=util.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/clonePseudoElements.js\n\nfunction clonePseudoElements(nativeNode, clonedNode) {\n    const pseudos = [':before', ':after'];\n    pseudos.forEach((pseudo) => Pseudo.clonePseudoElement(nativeNode, clonedNode, pseudo));\n}\nvar Pseudo;\n(function (Pseudo) {\n    function clonePseudoElement(nativeNode, clonedNode, pseudo) {\n        const style = window.getComputedStyle(nativeNode, pseudo);\n        const content = style.getPropertyValue('content');\n        if (content === '' || content === 'none') {\n            return;\n        }\n        const className = uuid();\n        // fix: Cannot assign to read only property 'className' of object '#<â€¦\n        try {\n            clonedNode.className = `${clonedNode.className} ${className}`;\n        }\n        catch (err) {\n            return;\n        }\n        const styleElement = document.createElement('style');\n        styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n        clonedNode.appendChild(styleElement);\n    }\n    Pseudo.clonePseudoElement = clonePseudoElement;\n    function getPseudoElementStyle(className, pseudo, style) {\n        const selector = `.${className}:${pseudo}`;\n        const cssText = style.cssText\n            ? formatCssText(style)\n            : formatCssProperties(style);\n        return document.createTextNode(`${selector}{${cssText}}`);\n    }\n    function formatCssText(style) {\n        const content = style.getPropertyValue('content');\n        return `${style.cssText} content: ${content};`;\n    }\n    function formatCssProperties(style) {\n        return toArray(style)\n            .map((name) => {\n            const value = style.getPropertyValue(name);\n            const priority = style.getPropertyPriority(name);\n            return `${name}: ${value}${priority ? ' !important' : ''};`;\n        })\n            .join(' ');\n    }\n})(Pseudo || (Pseudo = {}));\n//# sourceMappingURL=clonePseudoElements.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/cloneNode.js\nvar cloneNode_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nfunction cloneSingleNode(node) {\n    return cloneNode_awaiter(this, void 0, void 0, function* () {\n        if (node instanceof HTMLCanvasElement) {\n            const dataURL = node.toDataURL();\n            if (dataURL === 'data:,') {\n                return Promise.resolve(node.cloneNode(false));\n            }\n            return createImage(dataURL);\n        }\n        // if (node.tagName && node.tagName.toLowerCase() === 'svg') {\n        //   return Promise.resolve(node as SVGElement)\n        //     .then((svg) => svgToDataURL(svg))\n        //     .then(createImage)\n        // }\n        return Promise.resolve(node.cloneNode(false));\n    });\n}\nfunction cloneChildren(nativeNode, clonedNode, filter) {\n    var _a;\n    return cloneNode_awaiter(this, void 0, void 0, function* () {\n        const children = toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);\n        if (children.length === 0) {\n            return Promise.resolve(clonedNode);\n        }\n        return children\n            .reduce((done, child) => done\n            .then(() => cloneNode(child, filter))\n            .then((clonedChild) => {\n            if (clonedChild) {\n                clonedNode.appendChild(clonedChild);\n            }\n        }), Promise.resolve())\n            .then(() => clonedNode);\n    });\n}\nfunction decorate(nativeNode, clonedNode) {\n    return cloneNode_awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return clonedNode;\n        }\n        return Promise.resolve()\n            .then(() => cloneCssStyle(nativeNode, clonedNode))\n            .then(() => clonePseudoElements(nativeNode, clonedNode))\n            .then(() => cloneInputValue(nativeNode, clonedNode))\n            .then(() => clonedNode);\n    });\n}\nfunction cloneCssStyle(nativeNode, clonedNode) {\n    const source = window.getComputedStyle(nativeNode);\n    const target = clonedNode.style;\n    if (!target)\n        return;\n    if (source.cssText) {\n        target.cssText = source.cssText;\n    }\n    else {\n        toArray(source).forEach((name) => {\n            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (nativeNode instanceof HTMLTextAreaElement) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (nativeNode instanceof HTMLInputElement) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneNode(nativeNode, filter, isRoot) {\n    return cloneNode_awaiter(this, void 0, void 0, function* () {\n        if (!isRoot && filter && !filter(nativeNode)) {\n            return Promise.resolve(null);\n        }\n        return Promise.resolve(nativeNode)\n            .then(cloneSingleNode)\n            .then((clonedNode) => cloneChildren(nativeNode, clonedNode, filter))\n            .then((clonedNode) => decorate(nativeNode, clonedNode));\n    });\n}\n//# sourceMappingURL=cloneNode.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/getBlobFromURL.js\n/* tslint:disable:max-line-length */\n\n// KNOWN ISSUE\n// -----------\n// Can not handle redirect-url, such as when access 'http://something.com/avatar.png'\n// will redirect to 'http://something.com/65fc2ffcc8aea7ba65a1d1feda173540'\nconst TIMEOUT = 30000;\nconst cache = {};\nfunction isFont(filename) {\n    return /ttf|otf|eot|woff2?/i.test(filename);\n}\nfunction getBlobFromURL(url, options) {\n    let href = url.replace(/\\?.*/, '');\n    if (isFont(href)) {\n        href = href.replace(/.*\\//, '');\n    }\n    if (cache[href]) {\n        return cache[href];\n    }\n    // cache bypass so we dont have CORS issues with cached images\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // tslint:disable-next-line\n        url += (/\\?/.test(url) ? '&' : '?') + new Date().getTime();\n    }\n    const failed = (reason) => {\n        let placeholder = '';\n        if (options.imagePlaceholder) {\n            const parts = options.imagePlaceholder.split(/,/);\n            if (parts && parts[1]) {\n                placeholder = parts[1];\n            }\n        }\n        let msg = `Failed to fetch resource: ${url}`;\n        if (reason) {\n            msg = typeof reason === 'string' ? reason : reason.message;\n        }\n        if (msg) {\n            console.error(msg);\n        }\n        return placeholder;\n    };\n    const deferred = window.fetch\n        ? window\n            .fetch(url)\n            .then((response) => {\n            return new Promise((res, rej) => {\n                response.blob().then((blob) => {\n                    res({\n                        blob,\n                        contentType: response.headers.get('Content-Type'),\n                    });\n                });\n            });\n        })\n            .then(({ blob, contentType }) => new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve({\n                contentType,\n                blob: reader.result,\n            });\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        }))\n            .then(({ blob, contentType }) => ({\n            contentType,\n            blob: getDataURLContent(blob),\n        }))\n            .catch(() => new Promise((resolve, reject) => reject()))\n        : new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n            const timeout = () => {\n                reject(new Error(`Timeout of ${TIMEOUT}ms occured while fetching resource: ${url}`));\n            };\n            const done = () => {\n                if (req.readyState !== 4) {\n                    return;\n                }\n                if (req.status !== 200) {\n                    reject(new Error(`Failed to fetch resource: ${url}, status: ${req.status}`));\n                    return;\n                }\n                const encoder = new FileReader();\n                encoder.onloadend = () => {\n                    resolve({\n                        blob: getDataURLContent(encoder.result),\n                        contentType: req.getResponseHeader('Content-Type') || '',\n                    });\n                };\n                encoder.readAsDataURL(req.response);\n            };\n            req.onreadystatechange = done;\n            req.ontimeout = timeout;\n            req.responseType = 'blob';\n            req.timeout = TIMEOUT;\n            req.open('GET', url, true);\n            req.send();\n        });\n    const promise = deferred.catch(failed);\n    cache[href] = promise;\n    return promise;\n}\n//# sourceMappingURL=getBlobFromURL.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/embedResources.js\n\n\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction shouldEmbed(string) {\n    return string.search(URL_REGEX) !== -1;\n}\nfunction embedResources(cssString, baseUrl, options) {\n    if (!shouldEmbed(cssString)) {\n        return Promise.resolve(cssString);\n    }\n    const filteredCssString = filterPreferredFontFormat(cssString, options);\n    return Promise.resolve(filteredCssString)\n        .then(parseURLs)\n        .then((urls) => urls.reduce((done, url) => done.then((ret) => embedResources_embed(ret, url, baseUrl, options)), Promise.resolve(filteredCssString)));\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nfunction parseURLs(str) {\n    const result = [];\n    str.replace(URL_REGEX, (raw, quotation, url) => {\n        result.push(url);\n        return raw;\n    });\n    return result.filter((url) => !isDataUrl(url));\n}\nfunction embedResources_embed(cssString, resourceURL, baseURL, options, get) {\n    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n    return Promise.resolve(resolvedURL)\n        .then((url) => get ? get(url) : getBlobFromURL(url, options))\n        .then((data) => {\n        if (typeof data === 'string') {\n            return toDataURL(data, getMimeType(resourceURL));\n        }\n        return toDataURL(data.blob, getMimeType(resourceURL) || data.contentType);\n    })\n        .then((dataURL) => cssString.replace(urlToRegex(resourceURL), `$1${dataURL}$3`))\n        .then((content) => content, () => resolvedURL);\n}\nfunction resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nfunction urlToRegex(url) {\n    return new RegExp(`(url\\\\(['\"]?)(${embedResources_escape(url)})(['\"]?\\\\))`, 'g');\n}\nfunction embedResources_escape(url) {\n    return url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n}\n//# sourceMappingURL=embedResources.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/embedImages.js\nvar embedImages_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nfunction embedImages(clonedNode, options) {\n    return embedImages_awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(clonedNode)\n            .then((node) => embedBackground(node, options))\n            .then((node) => embedImageNode(node, options))\n            .then((node) => embedChildren(node, options));\n    });\n}\nfunction embedBackground(clonedNode, options) {\n    var _a;\n    return embedImages_awaiter(this, void 0, void 0, function* () {\n        const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');\n        if (!background) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(background)\n            .then((cssString) => embedResources(cssString, null, options))\n            .then((cssString) => {\n            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));\n            return clonedNode;\n        });\n    });\n}\nfunction embedImageNode(clonedNode, options) {\n    if (!(clonedNode instanceof HTMLImageElement) || isDataUrl(clonedNode.src)) {\n        return Promise.resolve(clonedNode);\n    }\n    return Promise.resolve(clonedNode.src)\n        .then((url) => getBlobFromURL(url, options))\n        .then((data) => toDataURL(data.blob, getMimeType(clonedNode.src) || data.contentType))\n        .then((dataURL) => new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        clonedNode.src = dataURL;\n    }))\n        .then(() => clonedNode, () => clonedNode);\n}\nfunction embedChildren(clonedNode, options) {\n    return embedImages_awaiter(this, void 0, void 0, function* () {\n        const children = toArray(clonedNode.childNodes);\n        const deferreds = children.map((child) => embedImages(child, options));\n        return Promise.all(deferreds).then(() => clonedNode);\n    });\n}\n//# sourceMappingURL=embedImages.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/embedWebFonts.js\nvar embedWebFonts_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst cssFetchPromiseStore = {};\nfunction parseWebFontRules(clonedNode) {\n    return embedWebFonts_awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            if (!clonedNode.ownerDocument) {\n                reject(new Error('Provided element is not within a Document'));\n            }\n            resolve(toArray(clonedNode.ownerDocument.styleSheets));\n        })\n            .then((styleSheets) => getCssRules(styleSheets))\n            .then(getWebFontRules);\n    });\n}\nfunction embedWebFonts(clonedNode, options) {\n    return embedWebFonts_awaiter(this, void 0, void 0, function* () {\n        return (options.fontEmbedCss != null\n            ? Promise.resolve(options.fontEmbedCss)\n            : embedWebFonts_getWebFontCss(clonedNode, options)).then((cssString) => {\n            const styleNode = document.createElement('style');\n            const sytleContent = document.createTextNode(cssString);\n            styleNode.appendChild(sytleContent);\n            if (clonedNode.firstChild) {\n                clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n            }\n            else {\n                clonedNode.appendChild(styleNode);\n            }\n            return clonedNode;\n        });\n    });\n}\nfunction embedWebFonts_getWebFontCss(node, options) {\n    return embedWebFonts_awaiter(this, void 0, void 0, function* () {\n        return parseWebFontRules(node)\n            .then((rules) => Promise.all(rules.map((rule) => {\n            const baseUrl = rule.parentStyleSheet\n                ? rule.parentStyleSheet.href\n                : null;\n            return embedResources(rule.cssText, baseUrl, options);\n        })))\n            .then((cssStrings) => cssStrings.join('\\n'));\n    });\n}\nfunction getCssRules(styleSheets) {\n    return embedWebFonts_awaiter(this, void 0, void 0, function* () {\n        const ret = [];\n        const promises = [];\n        // First loop inlines imports\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules).forEach((item, index) => {\n                        if (item.type === CSSRule.IMPORT_RULE) {\n                            let importIndex = index + 1;\n                            promises.push(fetchCSS(item.href, sheet)\n                                .then(embedFonts)\n                                .then((cssText) => {\n                                const parsed = parseCSS(cssText);\n                                parsed.forEach((rule) => {\n                                    try {\n                                        sheet.insertRule(rule, rule.startsWith('@import')\n                                            ? (importIndex = importIndex + 1)\n                                            : sheet.cssRules.length);\n                                    }\n                                    catch (error) {\n                                        console.log('Error inserting rule from remote css', {\n                                            rule,\n                                            error,\n                                        });\n                                    }\n                                });\n                            })\n                                .catch((e) => {\n                                console.log('Error loading remote css', e.toString());\n                            }));\n                        }\n                    });\n                }\n                catch (e) {\n                    const inline = styleSheets.find((a) => a.href === null) || document.styleSheets[0];\n                    if (sheet.href != null) {\n                        promises.push(fetchCSS(sheet.href, inline)\n                            .then(embedFonts)\n                            .then((cssText) => {\n                            const parsed = parseCSS(cssText);\n                            parsed.forEach((rule) => {\n                                inline.insertRule(rule, sheet.cssRules.length);\n                            });\n                        })\n                            .catch((e) => {\n                            console.log('Error loading remote stylesheet', e.toString());\n                        }));\n                    }\n                    console.log('Error inlining remote css file', e.toString());\n                }\n            }\n        });\n        return Promise.all(promises).then(() => {\n            // Second loop parses rules\n            styleSheets.forEach((sheet) => {\n                if ('cssRules' in sheet) {\n                    try {\n                        toArray(sheet.cssRules).forEach((item) => {\n                            ret.push(item);\n                        });\n                    }\n                    catch (e) {\n                        console.log(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                    }\n                }\n            });\n            return ret;\n        });\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseCSS(source) {\n    if (source === undefined) {\n        return [];\n    }\n    let cssText = source;\n    const css = [];\n    const cssKeyframeRegex = '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})';\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // to match css & media queries together\n    const cssCommentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // strip out comments\n    cssText = cssText.replace(cssCommentsRegex, '');\n    const keyframesRegex = new RegExp(cssKeyframeRegex, 'gi');\n    let arr;\n    while (true) {\n        arr = keyframesRegex.exec(cssText);\n        if (arr === null) {\n            break;\n        }\n        css.push(arr[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    // unified regex\n    const unified = new RegExp(combinedCSSRegex, 'gi');\n    while (true) {\n        arr = importRegex.exec(cssText);\n        if (arr === null) {\n            arr = unified.exec(cssText);\n            if (arr === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unified.lastIndex;\n            }\n        }\n        else {\n            unified.lastIndex = importRegex.lastIndex;\n        }\n        css.push(arr[0]);\n    }\n    return css;\n}\nfunction fetchCSS(url, sheet) {\n    if (cssFetchPromiseStore[url]) {\n        return cssFetchPromiseStore[url];\n    }\n    const promise = fetch(url).then((res) => {\n        return {\n            url,\n            cssText: res.text(),\n        };\n    }, (e) => {\n        console.log('ERROR FETCHING CSS: ', e.toString());\n    });\n    cssFetchPromiseStore[url] = promise;\n    return promise;\n}\nfunction embedFonts(data) {\n    return embedWebFonts_awaiter(this, void 0, void 0, function* () {\n        return data.cssText.then((resolved) => {\n            let cssText = resolved;\n            const regexUrlFind = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n            const fontLocations = cssText.match(/url\\([^)]+\\)/g) || [];\n            const fontLoadedPromises = fontLocations.map((location) => {\n                let url = location.replace(regexUrlFind, '$1');\n                if (!url.startsWith('https://')) {\n                    const source = data.url;\n                    url = new URL(url, source).href;\n                }\n                return new Promise((resolve, reject) => {\n                    fetch(url)\n                        .then((res) => res.blob())\n                        .then((blob) => {\n                        const reader = new FileReader();\n                        reader.addEventListener('load', (res) => {\n                            // Side Effect\n                            cssText = cssText.replace(location, `url(${reader.result})`);\n                            resolve([location, reader.result]);\n                        });\n                        reader.readAsDataURL(blob);\n                    })\n                        .catch(reject);\n                });\n            });\n            return Promise.all(fontLoadedPromises).then(() => cssText);\n        });\n    });\n}\n//# sourceMappingURL=embedWebFonts.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/createSvgDataURL.js\n\nfunction createSvgDataURL(clonedNode, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttributeNS('', 'width', `${width}`);\n    svg.setAttributeNS('', 'height', `${height}`);\n    foreignObject.setAttributeNS('', 'width', '100%');\n    foreignObject.setAttributeNS('', 'height', '100%');\n    foreignObject.setAttributeNS('', 'x', '0');\n    foreignObject.setAttributeNS('', 'y', '0');\n    foreignObject.setAttributeNS('', 'externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(clonedNode);\n    return svgToDataURL(svg);\n}\n//# sourceMappingURL=createSvgDataURL.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/applyStyleWithOptions.js\nfunction applyStyleWithOptions(clonedNode, options) {\n    const { style } = clonedNode;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            // @ts-expect-error\n            style[key] = manual[key];\n        });\n    }\n    return clonedNode;\n}\n//# sourceMappingURL=applyStyleWithOptions.js.map\n;// CONCATENATED MODULE: ./node_modules/html-to-image/es/index.js\nvar es_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nfunction getImageSize(domNode, options = {}) {\n    const width = options.width || getNodeWidth(domNode);\n    const height = options.height || getNodeHeight(domNode);\n    return { width, height };\n}\nfunction toSvg(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(domNode, options);\n        return cloneNode(domNode, options.filter, true)\n            .then((clonedNode) => embedWebFonts(clonedNode, options))\n            .then((clonedNode) => embedImages(clonedNode, options))\n            .then((clonedNode) => applyStyleWithOptions(clonedNode, options))\n            .then((clonedNode) => createSvgDataURL(clonedNode, width, height));\n    });\n}\nconst toSvgDataURL = (/* unused pure expression or super */ null && (toSvg));\nfunction toCanvas(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        return toSvg(domNode, options)\n            .then(createImage)\n            .then(delay(100))\n            .then((image) => {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            const ratio = options.pixelRatio || getPixelRatio();\n            const { width, height } = getImageSize(domNode, options);\n            const canvasWidth = options.canvasWidth || width;\n            const canvasHeight = options.canvasHeight || height;\n            canvas.width = canvasWidth * ratio;\n            canvas.height = canvasHeight * ratio;\n            canvas.style.width = `${canvasWidth}`;\n            canvas.style.height = `${canvasHeight}`;\n            if (options.backgroundColor) {\n                context.fillStyle = options.backgroundColor;\n                context.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            context.drawImage(image, 0, 0, canvas.width, canvas.height);\n            return canvas;\n        });\n    });\n}\nfunction toPixelData(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        const { width, height } = getImageSize(domNode, options);\n        return toCanvas(domNode, options).then((canvas) => {\n            const ctx = canvas.getContext('2d');\n            return ctx.getImageData(0, 0, width, height).data;\n        });\n    });\n}\nfunction toPng(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then((canvas) => canvas.toDataURL());\n    });\n}\nfunction toJpeg(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then((canvas) => canvas.toDataURL('image/jpeg', options.quality || 1));\n    });\n}\nfunction es_toBlob(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        return toCanvas(domNode, options).then(canvasToBlob);\n    });\n}\nfunction getWebFontEmbedCss(domNode, options = {}) {\n    return es_awaiter(this, void 0, void 0, function* () {\n        return getWebFontCss(domNode, options);\n    });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvdXRpbC5qcz8wODgwIiwid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9jbG9uZVBzZXVkb0VsZW1lbnRzLmpzPzE5N2YiLCJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy9odG1sLXRvLWltYWdlL2VzL2Nsb25lTm9kZS5qcz9lZmZiIiwid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9nZXRCbG9iRnJvbVVSTC5qcz9lMGZkIiwid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9lbWJlZFJlc291cmNlcy5qcz9jMjFlIiwid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9lbWJlZEltYWdlcy5qcz9jN2U3Iiwid2VicGFjazovL3RlbXAvLi9ub2RlX21vZHVsZXMvaHRtbC10by1pbWFnZS9lcy9lbWJlZFdlYkZvbnRzLmpzPzI1MGYiLCJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy9odG1sLXRvLWltYWdlL2VzL2NyZWF0ZVN2Z0RhdGFVUkwuanM/YmQxMCIsIndlYnBhY2s6Ly90ZW1wLy4vbm9kZV9tb2R1bGVzL2h0bWwtdG8taW1hZ2UvZXMvYXBwbHlTdHlsZVdpdGhPcHRpb25zLmpzPzRhMjYiLCJ3ZWJwYWNrOi8vdGVtcC8uL25vZGVfbW9kdWxlcy9odG1sLXRvLWltYWdlL2VzL2luZGV4LmpzP2U3NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFp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QUN1QztBQUN2RywyQ0FBMkM7QUFDM0MsbUNBQW1DLFlBQVk7QUFDL0MscUNBQXFDLGFBQWE7QUFDbEQsWUFBWTtBQUNaO0FBQ08sb0NBQW9DO0FBQzNDLFdBQVcsVUFBUztBQUNwQixlQUFlLGdCQUFnQjtBQUMvQixlQUFlLFNBQVM7QUFDeEIsa0NBQWtDLGFBQWE7QUFDL0Msa0NBQWtDLFdBQVc7QUFDN0Msa0NBQWtDLHFCQUFxQjtBQUN2RCxrQ0FBa0MsZ0JBQWdCO0FBQ2xELEtBQUs7QUFDTDtBQUNPLHFCQUFxQixxREFBSztBQUMxQix1Q0FBdUM7QUFDOUMsV0FBVyxVQUFTO0FBQ3BCO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0QsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTywwQ0FBMEM7QUFDakQsV0FBVyxVQUFTO0FBQ3BCLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTyxvQ0FBb0M7QUFDM0MsV0FBVyxVQUFTO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ08scUNBQXFDO0FBQzVDLFdBQVcsVUFBUztBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNPLFNBQVMsU0FBTSxzQkFBc0I7QUFDNUMsV0FBVyxVQUFTO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ08saURBQWlEO0FBQ3hELFdBQVcsVUFBUztBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6Ijc2OTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNvbnN0IFdPRkYgPSAnYXBwbGljYXRpb24vZm9udC13b2ZmJztcbmNvbnN0IEpQRUcgPSAnaW1hZ2UvanBlZyc7XG5jb25zdCBtaW1lcyA9IHtcbiAgICB3b2ZmOiBXT0ZGLFxuICAgIHdvZmYyOiBXT0ZGLFxuICAgIHR0ZjogJ2FwcGxpY2F0aW9uL2ZvbnQtdHJ1ZXR5cGUnLFxuICAgIGVvdDogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0JyxcbiAgICBwbmc6ICdpbWFnZS9wbmcnLFxuICAgIGpwZzogSlBFRyxcbiAgICBqcGVnOiBKUEVHLFxuICAgIGdpZjogJ2ltYWdlL2dpZicsXG4gICAgdGlmZjogJ2ltYWdlL3RpZmYnLFxuICAgIHN2ZzogJ2ltYWdlL3N2Zyt4bWwnLFxufTtcbmV4cG9ydCBjb25zdCB1dWlkID0gKGZ1bmN0aW9uIHV1aWQoKSB7XG4gICAgLy8gZ2VuZXJhdGUgdXVpZCBmb3IgY2xhc3NOYW1lIG9mIHBzZXVkbyBlbGVtZW50cy5cbiAgICAvLyBXZSBzaG91bGQgbm90IHVzZSBHVUlEcywgb3RoZXJ3aXNlIHBzZXVkbyBlbGVtZW50cyBzb21ldGltZXMgY2Fubm90IGJlIGNhcHR1cmVkLlxuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAvLyByZWY6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyNDg3MjIvMjUxOTM3M1xuICAgIGNvbnN0IHJhbmRvbSA9ICgpID0+IGAwMDAwJHsoKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgNCkpIDw8IDApLnRvU3RyaW5nKDM2KX1gLnNsaWNlKC00KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgIHJldHVybiBgdSR7cmFuZG9tKCl9JHtjb3VudGVyfWA7XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHVybCkge1xuICAgIGNvbnN0IG1hdGNoID0gL1xcLihbXi4vXSo/KSQvZy5leGVjKHVybCk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW1lVHlwZSh1cmwpIHtcbiAgICBjb25zdCBleHQgPSBnZXRFeHRlbnNpb24odXJsKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBtaW1lc1tleHRdIHx8ICcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5KG1zKSB7XG4gICAgcmV0dXJuIChhcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH0sIG1zKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5zZWFyY2goL14oZGF0YTopLykgIT09IC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRGF0YVVSTChjb250ZW50LCBtaW1lVHlwZSkge1xuICAgIHJldHVybiBgZGF0YToke21pbWVUeXBlfTtiYXNlNjQsJHtjb250ZW50fWA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVVSTENvbnRlbnQoZGF0YVVSTCkge1xuICAgIHJldHVybiBkYXRhVVJMLnNwbGl0KC8sLylbMV07XG59XG5mdW5jdGlvbiB0b0Jsb2IoY2FudmFzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKGNhbnZhcy50b0RhdGFVUkwoKS5zcGxpdCgnLCcpWzFdKTtcbiAgICAgICAgY29uc3QgbGVuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmluYXJ5QXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBiaW5hcnlBcnJheVtpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUobmV3IEJsb2IoW2JpbmFyeUFycmF5XSwgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FudmFzVG9CbG9iKGNhbnZhcykge1xuICAgIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gY2FudmFzLnRvQmxvYihyZXNvbHZlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b0Jsb2IoY2FudmFzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJyYXlMaWtlLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICByZXN1bHQucHVzaChhcnJheUxpa2VbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHgobm9kZSwgc3R5bGVQcm9wZXJ0eSkge1xuICAgIGNvbnN0IHZhbCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsLnJlcGxhY2UoJ3B4JywgJycpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlV2lkdGgobm9kZSkge1xuICAgIGNvbnN0IGxlZnRCb3JkZXIgPSBweChub2RlLCAnYm9yZGVyLWxlZnQtd2lkdGgnKTtcbiAgICBjb25zdCByaWdodEJvcmRlciA9IHB4KG5vZGUsICdib3JkZXItcmlnaHQtd2lkdGgnKTtcbiAgICByZXR1cm4gbm9kZS5jbGllbnRXaWR0aCArIGxlZnRCb3JkZXIgKyByaWdodEJvcmRlcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlSGVpZ2h0KG5vZGUpIHtcbiAgICBjb25zdCB0b3BCb3JkZXIgPSBweChub2RlLCAnYm9yZGVyLXRvcC13aWR0aCcpO1xuICAgIGNvbnN0IGJvdHRvbUJvcmRlciA9IHB4KG5vZGUsICdib3JkZXItYm90dG9tLXdpZHRoJyk7XG4gICAgcmV0dXJuIG5vZGUuY2xpZW50SGVpZ2h0ICsgdG9wQm9yZGVyICsgYm90dG9tQm9yZGVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oKSB7XG4gICAgbGV0IHJhdGlvO1xuICAgIGxldCBGSU5BTF9QUk9DRVNTO1xuICAgIHRyeSB7XG4gICAgICAgIEZJTkFMX1BST0NFU1MgPSBwcm9jZXNzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgY29uc3QgdmFsID0gRklOQUxfUFJPQ0VTUyAmJiBGSU5BTF9QUk9DRVNTLmVudlxuICAgICAgICA/IEZJTkFMX1BST0NFU1MuZW52LmRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgOiBudWxsO1xuICAgIGlmICh2YWwpIHtcbiAgICAgICAgcmF0aW8gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKHJhdGlvKSkge1xuICAgICAgICAgICAgcmF0aW8gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUltYWdlKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICBpbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3ZnVG9EYXRhVVJMKHN2Zykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpKVxuICAgICAgICAgICAgLnRoZW4oZW5jb2RlVVJJQ29tcG9uZW50KVxuICAgICAgICAgICAgLnRoZW4oKGh0bWwpID0+IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwke2h0bWx9YCk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmxvYkZyb21JbWFnZVVSTCh1cmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2UodXJsKS50aGVuKChpbWFnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY29uc3QgcmF0aW8gPSBnZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9YDtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9YDtcbiAgICAgICAgICAgIGNvbnRleHQuc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKGdldE1pbWVUeXBlKHVybCkpO1xuICAgICAgICAgICAgcmV0dXJuIGdldERhdGFVUkxDb250ZW50KGRhdGFVUkwpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiaW1wb3J0IHsgdXVpZCwgdG9BcnJheSB9IGZyb20gJy4vdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gY2xvbmVQc2V1ZG9FbGVtZW50cyhuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSB7XG4gICAgY29uc3QgcHNldWRvcyA9IFsnOmJlZm9yZScsICc6YWZ0ZXInXTtcbiAgICBwc2V1ZG9zLmZvckVhY2goKHBzZXVkbykgPT4gUHNldWRvLmNsb25lUHNldWRvRWxlbWVudChuYXRpdmVOb2RlLCBjbG9uZWROb2RlLCBwc2V1ZG8pKTtcbn1cbnZhciBQc2V1ZG87XG4oZnVuY3Rpb24gKFBzZXVkbykge1xuICAgIGZ1bmN0aW9uIGNsb25lUHNldWRvRWxlbWVudChuYXRpdmVOb2RlLCBjbG9uZWROb2RlLCBwc2V1ZG8pIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVOb2RlLCBwc2V1ZG8pO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdXVpZCgpO1xuICAgICAgICAvLyBmaXg6IENhbm5vdCBhc3NpZ24gdG8gcmVhZCBvbmx5IHByb3BlcnR5ICdjbGFzc05hbWUnIG9mIG9iamVjdCAnIzzigKZcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNsb25lZE5vZGUuY2xhc3NOYW1lID0gYCR7Y2xvbmVkTm9kZS5jbGFzc05hbWV9ICR7Y2xhc3NOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChnZXRQc2V1ZG9FbGVtZW50U3R5bGUoY2xhc3NOYW1lLCBwc2V1ZG8sIHN0eWxlKSk7XG4gICAgICAgIGNsb25lZE5vZGUuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gICAgUHNldWRvLmNsb25lUHNldWRvRWxlbWVudCA9IGNsb25lUHNldWRvRWxlbWVudDtcbiAgICBmdW5jdGlvbiBnZXRQc2V1ZG9FbGVtZW50U3R5bGUoY2xhc3NOYW1lLCBwc2V1ZG8sIHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYC4ke2NsYXNzTmFtZX06JHtwc2V1ZG99YDtcbiAgICAgICAgY29uc3QgY3NzVGV4dCA9IHN0eWxlLmNzc1RleHRcbiAgICAgICAgICAgID8gZm9ybWF0Q3NzVGV4dChzdHlsZSlcbiAgICAgICAgICAgIDogZm9ybWF0Q3NzUHJvcGVydGllcyhzdHlsZSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgJHtzZWxlY3Rvcn17JHtjc3NUZXh0fX1gKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0Q3NzVGV4dChzdHlsZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpO1xuICAgICAgICByZXR1cm4gYCR7c3R5bGUuY3NzVGV4dH0gY29udGVudDogJHtjb250ZW50fTtgO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRDc3NQcm9wZXJ0aWVzKHN0eWxlKSB7XG4gICAgICAgIHJldHVybiB0b0FycmF5KHN0eWxlKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHkgPSBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9OiAke3ZhbHVlfSR7cHJpb3JpdHkgPyAnICFpbXBvcnRhbnQnIDogJyd9O2A7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn0pKFBzZXVkbyB8fCAoUHNldWRvID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lUHNldWRvRWxlbWVudHMuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBjbG9uZVBzZXVkb0VsZW1lbnRzIH0gZnJvbSAnLi9jbG9uZVBzZXVkb0VsZW1lbnRzJztcbmltcG9ydCB7IGNyZWF0ZUltYWdlLCB0b0FycmF5IH0gZnJvbSAnLi91dGlsJztcbmZ1bmN0aW9uIGNsb25lU2luZ2xlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YVVSTCA9IG5vZGUudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICBpZiAoZGF0YVVSTCA9PT0gJ2RhdGE6LCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vZGUuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2UoZGF0YVVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgLy8gICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vZGUgYXMgU1ZHRWxlbWVudClcbiAgICAgICAgLy8gICAgIC50aGVuKChzdmcpID0+IHN2Z1RvRGF0YVVSTChzdmcpKVxuICAgICAgICAvLyAgICAgLnRoZW4oY3JlYXRlSW1hZ2UpXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShub2RlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2xvbmVDaGlsZHJlbihuYXRpdmVOb2RlLCBjbG9uZWROb2RlLCBmaWx0ZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0b0FycmF5KCgoX2EgPSBuYXRpdmVOb2RlLnNoYWRvd1Jvb3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5hdGl2ZU5vZGUpLmNoaWxkTm9kZXMpO1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsb25lZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgICAgICAgLnJlZHVjZSgoZG9uZSwgY2hpbGQpID0+IGRvbmVcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGNsb25lTm9kZShjaGlsZCwgZmlsdGVyKSlcbiAgICAgICAgICAgIC50aGVuKChjbG9uZWRDaGlsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNsb25lZENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChjbG9uZWRDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGNsb25lZE5vZGUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjb3JhdGUobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghKGNsb25lZE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBjbG9uZUNzc1N0eWxlKG5hdGl2ZU5vZGUsIGNsb25lZE5vZGUpKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gY2xvbmVQc2V1ZG9FbGVtZW50cyhuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGNsb25lSW5wdXRWYWx1ZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGNsb25lZE5vZGUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2xvbmVDc3NTdHlsZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSB7XG4gICAgY29uc3Qgc291cmNlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobmF0aXZlTm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gY2xvbmVkTm9kZS5zdHlsZTtcbiAgICBpZiAoIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzb3VyY2UuY3NzVGV4dCkge1xuICAgICAgICB0YXJnZXQuY3NzVGV4dCA9IHNvdXJjZS5jc3NUZXh0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdG9BcnJheShzb3VyY2UpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRhcmdldC5zZXRQcm9wZXJ0eShuYW1lLCBzb3VyY2UuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSwgc291cmNlLmdldFByb3BlcnR5UHJpb3JpdHkobmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9uZUlucHV0VmFsdWUobmF0aXZlTm9kZSwgY2xvbmVkTm9kZSkge1xuICAgIGlmIChuYXRpdmVOb2RlIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCkge1xuICAgICAgICBjbG9uZWROb2RlLmlubmVySFRNTCA9IG5hdGl2ZU5vZGUudmFsdWU7XG4gICAgfVxuICAgIGlmIChuYXRpdmVOb2RlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xuICAgICAgICBjbG9uZWROb2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBuYXRpdmVOb2RlLnZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvbmVOb2RlKG5hdGl2ZU5vZGUsIGZpbHRlciwgaXNSb290KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFpc1Jvb3QgJiYgZmlsdGVyICYmICFmaWx0ZXIobmF0aXZlTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuYXRpdmVOb2RlKVxuICAgICAgICAgICAgLnRoZW4oY2xvbmVTaW5nbGVOb2RlKVxuICAgICAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGNsb25lQ2hpbGRyZW4obmF0aXZlTm9kZSwgY2xvbmVkTm9kZSwgZmlsdGVyKSlcbiAgICAgICAgICAgIC50aGVuKChjbG9uZWROb2RlKSA9PiBkZWNvcmF0ZShuYXRpdmVOb2RlLCBjbG9uZWROb2RlKSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9uZU5vZGUuanMubWFwIiwiLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5pbXBvcnQgeyBnZXREYXRhVVJMQ29udGVudCB9IGZyb20gJy4vdXRpbCc7XG4vLyBLTk9XTiBJU1NVRVxuLy8gLS0tLS0tLS0tLS1cbi8vIENhbiBub3QgaGFuZGxlIHJlZGlyZWN0LXVybCwgc3VjaCBhcyB3aGVuIGFjY2VzcyAnaHR0cDovL3NvbWV0aGluZy5jb20vYXZhdGFyLnBuZydcbi8vIHdpbGwgcmVkaXJlY3QgdG8gJ2h0dHA6Ly9zb21ldGhpbmcuY29tLzY1ZmMyZmZjYzhhZWE3YmE2NWExZDFmZWRhMTczNTQwJ1xuY29uc3QgVElNRU9VVCA9IDMwMDAwO1xuY29uc3QgY2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzRm9udChmaWxlbmFtZSkge1xuICAgIHJldHVybiAvdHRmfG90Znxlb3R8d29mZjI/L2kudGVzdChmaWxlbmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmxvYkZyb21VUkwodXJsLCBvcHRpb25zKSB7XG4gICAgbGV0IGhyZWYgPSB1cmwucmVwbGFjZSgvXFw/LiovLCAnJyk7XG4gICAgaWYgKGlzRm9udChocmVmKSkge1xuICAgICAgICBocmVmID0gaHJlZi5yZXBsYWNlKC8uKlxcLy8sICcnKTtcbiAgICB9XG4gICAgaWYgKGNhY2hlW2hyZWZdKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtocmVmXTtcbiAgICB9XG4gICAgLy8gY2FjaGUgYnlwYXNzIHNvIHdlIGRvbnQgaGF2ZSBDT1JTIGlzc3VlcyB3aXRoIGNhY2hlZCBpbWFnZXNcbiAgICAvLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdCNCeXBhc3NpbmdfdGhlX2NhY2hlXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVCdXN0KSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB1cmwgKz0gKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3QgZmFpbGVkID0gKHJlYXNvbikgPT4ge1xuICAgICAgICBsZXQgcGxhY2Vob2xkZXIgPSAnJztcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1hZ2VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBvcHRpb25zLmltYWdlUGxhY2Vob2xkZXIuc3BsaXQoLywvKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gcGFydHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1zZyA9IGBGYWlsZWQgdG8gZmV0Y2ggcmVzb3VyY2U6ICR7dXJsfWA7XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIG1zZyA9IHR5cGVvZiByZWFzb24gPT09ICdzdHJpbmcnID8gcmVhc29uIDogcmVhc29uLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9O1xuICAgIGNvbnN0IGRlZmVycmVkID0gd2luZG93LmZldGNoXG4gICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAuZmV0Y2godXJsKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYmxvYigpLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHsgYmxvYiwgY29udGVudFR5cGUgfSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBibG9iOiByZWFkZXIucmVzdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC50aGVuKCh7IGJsb2IsIGNvbnRlbnRUeXBlIH0pID0+ICh7XG4gICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgIGJsb2I6IGdldERhdGFVUkxDb250ZW50KGJsb2IpLFxuICAgICAgICB9KSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZWplY3QoKSkpXG4gICAgICAgIDogbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtUSU1FT1VUfW1zIG9jY3VyZWQgd2hpbGUgZmV0Y2hpbmcgcmVzb3VyY2U6ICR7dXJsfWApKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHJlc291cmNlOiAke3VybH0sIHN0YXR1czogJHtyZXEuc3RhdHVzfWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBlbmNvZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iOiBnZXREYXRhVVJMQ29udGVudChlbmNvZGVyLnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVxLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBlbmNvZGVyLnJlYWRBc0RhdGFVUkwocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZG9uZTtcbiAgICAgICAgICAgIHJlcS5vbnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gVElNRU9VVDtcbiAgICAgICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcHJvbWlzZSA9IGRlZmVycmVkLmNhdGNoKGZhaWxlZCk7XG4gICAgY2FjaGVbaHJlZl0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0QmxvYkZyb21VUkwuanMubWFwIiwiaW1wb3J0IHsgZ2V0QmxvYkZyb21VUkwgfSBmcm9tICcuL2dldEJsb2JGcm9tVVJMJztcbmltcG9ydCB7IGlzRGF0YVVybCwgdG9EYXRhVVJMLCBnZXRNaW1lVHlwZSB9IGZyb20gJy4vdXRpbCc7XG5jb25zdCBVUkxfUkVHRVggPSAvdXJsXFwoKFsnXCJdPykoW14nXCJdKz8pXFwxXFwpL2c7XG5jb25zdCBVUkxfV0lUSF9GT1JNQVRfUkVHRVggPSAvdXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoKFtcIiddKShbXlwiJ10rKVxcMVxcKS9nO1xuY29uc3QgRk9OVF9TUkNfUkVHRVggPSAvc3JjOlxccyooPzp1cmxcXChbXildK1xcKVxccypmb3JtYXRcXChbXildK1xcKVssO11cXHMqKSsvZztcbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRFbWJlZChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNlYXJjaChVUkxfUkVHRVgpICE9PSAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbWJlZFJlc291cmNlcyhjc3NTdHJpbmcsIGJhc2VVcmwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNob3VsZEVtYmVkKGNzc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjc3NTdHJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZENzc1N0cmluZyA9IGZpbHRlclByZWZlcnJlZEZvbnRGb3JtYXQoY3NzU3RyaW5nLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbHRlcmVkQ3NzU3RyaW5nKVxuICAgICAgICAudGhlbihwYXJzZVVSTHMpXG4gICAgICAgIC50aGVuKCh1cmxzKSA9PiB1cmxzLnJlZHVjZSgoZG9uZSwgdXJsKSA9PiBkb25lLnRoZW4oKHJldCkgPT4gZW1iZWQocmV0LCB1cmwsIGJhc2VVcmwsIG9wdGlvbnMpKSwgUHJvbWlzZS5yZXNvbHZlKGZpbHRlcmVkQ3NzU3RyaW5nKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclByZWZlcnJlZEZvbnRGb3JtYXQoc3RyLCB7IHByZWZlcnJlZEZvbnRGb3JtYXQgfSkge1xuICAgIHJldHVybiAhcHJlZmVycmVkRm9udEZvcm1hdFxuICAgICAgICA/IHN0clxuICAgICAgICA6IHN0ci5yZXBsYWNlKEZPTlRfU1JDX1JFR0VYLCAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NyYywgLCBmb3JtYXRdID0gVVJMX1dJVEhfRk9STUFUX1JFR0VYLmV4ZWMobWF0Y2gpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gcHJlZmVycmVkRm9udEZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHNyYzogJHtzcmN9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVSTHMoc3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgc3RyLnJlcGxhY2UoVVJMX1JFR0VYLCAocmF3LCBxdW90YXRpb24sIHVybCkgPT4ge1xuICAgICAgICByZXN1bHQucHVzaCh1cmwpO1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQuZmlsdGVyKCh1cmwpID0+ICFpc0RhdGFVcmwodXJsKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW1iZWQoY3NzU3RyaW5nLCByZXNvdXJjZVVSTCwgYmFzZVVSTCwgb3B0aW9ucywgZ2V0KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRVUkwgPSBiYXNlVVJMID8gcmVzb2x2ZVVybChyZXNvdXJjZVVSTCwgYmFzZVVSTCkgOiByZXNvdXJjZVVSTDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVkVVJMKVxuICAgICAgICAudGhlbigodXJsKSA9PiBnZXQgPyBnZXQodXJsKSA6IGdldEJsb2JGcm9tVVJMKHVybCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0RhdGFVUkwoZGF0YSwgZ2V0TWltZVR5cGUocmVzb3VyY2VVUkwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9EYXRhVVJMKGRhdGEuYmxvYiwgZ2V0TWltZVR5cGUocmVzb3VyY2VVUkwpIHx8IGRhdGEuY29udGVudFR5cGUpO1xuICAgIH0pXG4gICAgICAgIC50aGVuKChkYXRhVVJMKSA9PiBjc3NTdHJpbmcucmVwbGFjZSh1cmxUb1JlZ2V4KHJlc291cmNlVVJMKSwgYCQxJHtkYXRhVVJMfSQzYCkpXG4gICAgICAgIC50aGVuKChjb250ZW50KSA9PiBjb250ZW50LCAoKSA9PiByZXNvbHZlZFVSTCk7XG59XG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVybCkge1xuICAgIC8vIHVybCBpcyBhYnNvbHV0ZSBhbHJlYWR5XG4gICAgaWYgKHVybC5tYXRjaCgvXlthLXpdKzpcXC9cXC8vaSkpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgLy8gdXJsIGlzIGFic29sdXRlIGFscmVhZHksIHdpdGhvdXQgcHJvdG9jb2xcbiAgICBpZiAodXJsLm1hdGNoKC9eXFwvXFwvLykpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgICB9XG4gICAgLy8gZGF0YVVSSSwgbWFpbHRvOiwgdGVsOiwgZXRjLlxuICAgIGlmICh1cmwubWF0Y2goL15bYS16XSs6L2kpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgIGNvbnN0IGJhc2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgIGNvbnN0IGEgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgIGlmIChiYXNlVXJsKSB7XG4gICAgICAgIGJhc2UuaHJlZiA9IGJhc2VVcmw7XG4gICAgfVxuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5ocmVmO1xufVxuZnVuY3Rpb24gdXJsVG9SZWdleCh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgKHVybFxcXFwoWydcIl0/KSgke2VzY2FwZSh1cmwpfSkoWydcIl0/XFxcXCkpYCwgJ2cnKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhbLiorP14ke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1iZWRSZXNvdXJjZXMuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBnZXRCbG9iRnJvbVVSTCB9IGZyb20gJy4vZ2V0QmxvYkZyb21VUkwnO1xuaW1wb3J0IHsgZW1iZWRSZXNvdXJjZXMgfSBmcm9tICcuL2VtYmVkUmVzb3VyY2VzJztcbmltcG9ydCB7IHRvQXJyYXksIGlzRGF0YVVybCwgdG9EYXRhVVJMLCBnZXRNaW1lVHlwZSB9IGZyb20gJy4vdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gZW1iZWRJbWFnZXMoY2xvbmVkTm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICghKGNsb25lZE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbG9uZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsb25lZE5vZGUpXG4gICAgICAgICAgICAudGhlbigobm9kZSkgPT4gZW1iZWRCYWNrZ3JvdW5kKG5vZGUsIG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRoZW4oKG5vZGUpID0+IGVtYmVkSW1hZ2VOb2RlKG5vZGUsIG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRoZW4oKG5vZGUpID0+IGVtYmVkQ2hpbGRyZW4obm9kZSwgb3B0aW9ucykpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW1iZWRCYWNrZ3JvdW5kKGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IChfYSA9IGNsb25lZE5vZGUuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kJyk7XG4gICAgICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbG9uZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJhY2tncm91bmQpXG4gICAgICAgICAgICAudGhlbigoY3NzU3RyaW5nKSA9PiBlbWJlZFJlc291cmNlcyhjc3NTdHJpbmcsIG51bGwsIG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRoZW4oKGNzc1N0cmluZykgPT4ge1xuICAgICAgICAgICAgY2xvbmVkTm9kZS5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZCcsIGNzc1N0cmluZywgY2xvbmVkTm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdiYWNrZ3JvdW5kJykpO1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW1iZWRJbWFnZU5vZGUoY2xvbmVkTm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghKGNsb25lZE5vZGUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB8fCBpc0RhdGFVcmwoY2xvbmVkTm9kZS5zcmMpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2xvbmVkTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2xvbmVkTm9kZS5zcmMpXG4gICAgICAgIC50aGVuKCh1cmwpID0+IGdldEJsb2JGcm9tVVJMKHVybCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKChkYXRhKSA9PiB0b0RhdGFVUkwoZGF0YS5ibG9iLCBnZXRNaW1lVHlwZShjbG9uZWROb2RlLnNyYykgfHwgZGF0YS5jb250ZW50VHlwZSkpXG4gICAgICAgIC50aGVuKChkYXRhVVJMKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNsb25lZE5vZGUub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgY2xvbmVkTm9kZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBjbG9uZWROb2RlLnNyYyA9IGRhdGFVUkw7XG4gICAgfSkpXG4gICAgICAgIC50aGVuKCgpID0+IGNsb25lZE5vZGUsICgpID0+IGNsb25lZE5vZGUpO1xufVxuZnVuY3Rpb24gZW1iZWRDaGlsZHJlbihjbG9uZWROb2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0b0FycmF5KGNsb25lZE5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkcyA9IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGVtYmVkSW1hZ2VzKGNoaWxkLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChkZWZlcnJlZHMpLnRoZW4oKCkgPT4gY2xvbmVkTm9kZSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZEltYWdlcy5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IHRvQXJyYXkgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgc2hvdWxkRW1iZWQsIGVtYmVkUmVzb3VyY2VzIH0gZnJvbSAnLi9lbWJlZFJlc291cmNlcyc7XG5jb25zdCBjc3NGZXRjaFByb21pc2VTdG9yZSA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlV2ViRm9udFJ1bGVzKGNsb25lZE5vZGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbG9uZWROb2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQcm92aWRlZCBlbGVtZW50IGlzIG5vdCB3aXRoaW4gYSBEb2N1bWVudCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodG9BcnJheShjbG9uZWROb2RlLm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHMpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChzdHlsZVNoZWV0cykgPT4gZ2V0Q3NzUnVsZXMoc3R5bGVTaGVldHMpKVxuICAgICAgICAgICAgLnRoZW4oZ2V0V2ViRm9udFJ1bGVzKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbWJlZFdlYkZvbnRzKGNsb25lZE5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuZm9udEVtYmVkQ3NzICE9IG51bGxcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMuZm9udEVtYmVkQ3NzKVxuICAgICAgICAgICAgOiBnZXRXZWJGb250Q3NzKGNsb25lZE5vZGUsIG9wdGlvbnMpKS50aGVuKChjc3NTdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBjb25zdCBzeXRsZUNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NTdHJpbmcpO1xuICAgICAgICAgICAgc3R5bGVOb2RlLmFwcGVuZENoaWxkKHN5dGxlQ29udGVudCk7XG4gICAgICAgICAgICBpZiAoY2xvbmVkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVOb2RlLCBjbG9uZWROb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkTm9kZS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFdlYkZvbnRDc3Mobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVdlYkZvbnRSdWxlcyhub2RlKVxuICAgICAgICAgICAgLnRoZW4oKHJ1bGVzKSA9PiBQcm9taXNlLmFsbChydWxlcy5tYXAoKHJ1bGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSBydWxlLnBhcmVudFN0eWxlU2hlZXRcbiAgICAgICAgICAgICAgICA/IHJ1bGUucGFyZW50U3R5bGVTaGVldC5ocmVmXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGVtYmVkUmVzb3VyY2VzKHJ1bGUuY3NzVGV4dCwgYmFzZVVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0pKSlcbiAgICAgICAgICAgIC50aGVuKChjc3NTdHJpbmdzKSA9PiBjc3NTdHJpbmdzLmpvaW4oJ1xcbicpKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDc3NSdWxlcyhzdHlsZVNoZWV0cykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAvLyBGaXJzdCBsb29wIGlubGluZXMgaW1wb3J0c1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKChzaGVldCkgPT4ge1xuICAgICAgICAgICAgaWYgKCdjc3NSdWxlcycgaW4gc2hlZXQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0b0FycmF5KHNoZWV0LmNzc1J1bGVzKS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gQ1NTUnVsZS5JTVBPUlRfUlVMRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbXBvcnRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGZldGNoQ1NTKGl0ZW0uaHJlZiwgc2hlZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGVtYmVkRm9udHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjc3NUZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ1NTKGNzc1RleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHJ1bGUuc3RhcnRzV2l0aCgnQGltcG9ydCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGltcG9ydEluZGV4ID0gaW1wb3J0SW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgaW5zZXJ0aW5nIHJ1bGUgZnJvbSByZW1vdGUgY3NzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBsb2FkaW5nIHJlbW90ZSBjc3MnLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IHN0eWxlU2hlZXRzLmZpbmQoKGEpID0+IGEuaHJlZiA9PT0gbnVsbCkgfHwgZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGVldC5ocmVmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZmV0Y2hDU1Moc2hlZXQuaHJlZiwgaW5saW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGVtYmVkRm9udHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGNzc1RleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNTUyhjc3NUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmxpbmUuaW5zZXJ0UnVsZShydWxlLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgbG9hZGluZyByZW1vdGUgc3R5bGVzaGVldCcsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGlubGluaW5nIHJlbW90ZSBjc3MgZmlsZScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNlY29uZCBsb29wIHBhcnNlcyBydWxlc1xuICAgICAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoc2hlZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoJ2Nzc1J1bGVzJyBpbiBzaGVldCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9BcnJheShzaGVldC5jc3NSdWxlcykuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGlsZSByZWFkaW5nIENTUyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn1gLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFdlYkZvbnRSdWxlcyhjc3NSdWxlcykge1xuICAgIHJldHVybiBjc3NSdWxlc1xuICAgICAgICAuZmlsdGVyKChydWxlKSA9PiBydWxlLnR5cGUgPT09IENTU1J1bGUuRk9OVF9GQUNFX1JVTEUpXG4gICAgICAgIC5maWx0ZXIoKHJ1bGUpID0+IHNob3VsZEVtYmVkKHJ1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnc3JjJykpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ1NTKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBjc3NUZXh0ID0gc291cmNlO1xuICAgIGNvbnN0IGNzcyA9IFtdO1xuICAgIGNvbnN0IGNzc0tleWZyYW1lUmVnZXggPSAnKChALio/a2V5ZnJhbWVzIFtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj99XFxcXHMqPyl9KSc7XG4gICAgY29uc3QgY29tYmluZWRDU1NSZWdleCA9ICcoKFxcXFxzKj8oPzpcXFxcL1xcXFwqW1xcXFxzXFxcXFNdKj9cXFxcKlxcXFwvKT9cXFxccyo/QG1lZGlhW1xcXFxzXFxcXFNdJyArXG4gICAgICAgICcqPyl7KFtcXFxcc1xcXFxTXSo/KX1cXFxccyo/fSl8KChbXFxcXHNcXFxcU10qPyl7KFtcXFxcc1xcXFxTXSo/KX0pJzsgLy8gdG8gbWF0Y2ggY3NzICYgbWVkaWEgcXVlcmllcyB0b2dldGhlclxuICAgIGNvbnN0IGNzc0NvbW1lbnRzUmVnZXggPSAvKFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pL2dpO1xuICAgIGNvbnN0IGltcG9ydFJlZ2V4ID0gL0BpbXBvcnRbXFxzXFxTXSo/dXJsXFwoW14pXSpcXClbXFxzXFxTXSo/Oy9naTtcbiAgICAvLyBzdHJpcCBvdXQgY29tbWVudHNcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKGNzc0NvbW1lbnRzUmVnZXgsICcnKTtcbiAgICBjb25zdCBrZXlmcmFtZXNSZWdleCA9IG5ldyBSZWdFeHAoY3NzS2V5ZnJhbWVSZWdleCwgJ2dpJyk7XG4gICAgbGV0IGFycjtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBhcnIgPSBrZXlmcmFtZXNSZWdleC5leGVjKGNzc1RleHQpO1xuICAgICAgICBpZiAoYXJyID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjc3MucHVzaChhcnJbMF0pO1xuICAgIH1cbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKGtleWZyYW1lc1JlZ2V4LCAnJyk7XG4gICAgLy8gdW5pZmllZCByZWdleFxuICAgIGNvbnN0IHVuaWZpZWQgPSBuZXcgUmVnRXhwKGNvbWJpbmVkQ1NTUmVnZXgsICdnaScpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGFyciA9IGltcG9ydFJlZ2V4LmV4ZWMoY3NzVGV4dCk7XG4gICAgICAgIGlmIChhcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFyciA9IHVuaWZpZWQuZXhlYyhjc3NUZXh0KTtcbiAgICAgICAgICAgIGlmIChhcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcG9ydFJlZ2V4Lmxhc3RJbmRleCA9IHVuaWZpZWQubGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5pZmllZC5sYXN0SW5kZXggPSBpbXBvcnRSZWdleC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY3NzLnB1c2goYXJyWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNzcztcbn1cbmZ1bmN0aW9uIGZldGNoQ1NTKHVybCwgc2hlZXQpIHtcbiAgICBpZiAoY3NzRmV0Y2hQcm9taXNlU3RvcmVbdXJsXSkge1xuICAgICAgICByZXR1cm4gY3NzRmV0Y2hQcm9taXNlU3RvcmVbdXJsXTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IGZldGNoKHVybCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBjc3NUZXh0OiByZXMudGV4dCgpLFxuICAgICAgICB9O1xuICAgIH0sIChlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFUlJPUiBGRVRDSElORyBDU1M6ICcsIGUudG9TdHJpbmcoKSk7XG4gICAgfSk7XG4gICAgY3NzRmV0Y2hQcm9taXNlU3RvcmVbdXJsXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBlbWJlZEZvbnRzKGRhdGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gZGF0YS5jc3NUZXh0LnRoZW4oKHJlc29sdmVkKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3NzVGV4dCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgY29uc3QgcmVnZXhVcmxGaW5kID0gL3VybFxcKFtcIiddPyhbXlwiJyldKylbXCInXT9cXCkvZztcbiAgICAgICAgICAgIGNvbnN0IGZvbnRMb2NhdGlvbnMgPSBjc3NUZXh0Lm1hdGNoKC91cmxcXChbXildK1xcKS9nKSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRMb2FkZWRQcm9taXNlcyA9IGZvbnRMb2NhdGlvbnMubWFwKChsb2NhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5yZXBsYWNlKHJlZ2V4VXJsRmluZCwgJyQxJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBkYXRhLnVybDtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwsIHNvdXJjZSkuaHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2godXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmJsb2IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChibG9iKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2lkZSBFZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKGxvY2F0aW9uLCBgdXJsKCR7cmVhZGVyLnJlc3VsdH0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbbG9jYXRpb24sIHJlYWRlci5yZXN1bHRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZvbnRMb2FkZWRQcm9taXNlcykudGhlbigoKSA9PiBjc3NUZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbWJlZFdlYkZvbnRzLmpzLm1hcCIsImltcG9ydCB7IHN2Z1RvRGF0YVVSTCB9IGZyb20gJy4vdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3ZnRGF0YVVSTChjbG9uZWROb2RlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgJ3N2ZycpO1xuICAgIGNvbnN0IGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsICdmb3JlaWduT2JqZWN0Jyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZU5TKCcnLCAnd2lkdGgnLCBgJHt3aWR0aH1gKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlTlMoJycsICdoZWlnaHQnLCBgJHtoZWlnaHR9YCk7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUygnJywgJ3dpZHRoJywgJzEwMCUnKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKCcnLCAnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKCcnLCAneCcsICcwJyk7XG4gICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUygnJywgJ3knLCAnMCcpO1xuICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlTlMoJycsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ3RydWUnKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChjbG9uZWROb2RlKTtcbiAgICByZXR1cm4gc3ZnVG9EYXRhVVJMKHN2Zyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVTdmdEYXRhVVJMLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlV2l0aE9wdGlvbnMoY2xvbmVkTm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IGNsb25lZE5vZGU7XG4gICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aWR0aCkge1xuICAgICAgICBzdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7b3B0aW9ucy5oZWlnaHR9cHhgO1xuICAgIH1cbiAgICBjb25zdCBtYW51YWwgPSBvcHRpb25zLnN0eWxlO1xuICAgIGlmIChtYW51YWwgIT0gbnVsbCkge1xuICAgICAgICBPYmplY3Qua2V5cyhtYW51YWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgc3R5bGVba2V5XSA9IG1hbnVhbFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZE5vZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseVN0eWxlV2l0aE9wdGlvbnMuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBjbG9uZU5vZGUgfSBmcm9tICcuL2Nsb25lTm9kZSc7XG5pbXBvcnQgeyBlbWJlZEltYWdlcyB9IGZyb20gJy4vZW1iZWRJbWFnZXMnO1xuaW1wb3J0IHsgZW1iZWRXZWJGb250cywgZ2V0V2ViRm9udENzcyB9IGZyb20gJy4vZW1iZWRXZWJGb250cyc7XG5pbXBvcnQgeyBjcmVhdGVTdmdEYXRhVVJMIH0gZnJvbSAnLi9jcmVhdGVTdmdEYXRhVVJMJztcbmltcG9ydCB7IGFwcGx5U3R5bGVXaXRoT3B0aW9ucyB9IGZyb20gJy4vYXBwbHlTdHlsZVdpdGhPcHRpb25zJztcbmltcG9ydCB7IGRlbGF5LCBjcmVhdGVJbWFnZSwgY2FudmFzVG9CbG9iLCBnZXROb2RlV2lkdGgsIGdldE5vZGVIZWlnaHQsIGdldFBpeGVsUmF0aW8sIH0gZnJvbSAnLi91dGlsJztcbmZ1bmN0aW9uIGdldEltYWdlU2l6ZShkb21Ob2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgZ2V0Tm9kZVdpZHRoKGRvbU5vZGUpO1xuICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGdldE5vZGVIZWlnaHQoZG9tTm9kZSk7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvU3ZnKGRvbU5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0SW1hZ2VTaXplKGRvbU5vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGRvbU5vZGUsIG9wdGlvbnMuZmlsdGVyLCB0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGVtYmVkV2ViRm9udHMoY2xvbmVkTm9kZSwgb3B0aW9ucykpXG4gICAgICAgICAgICAudGhlbigoY2xvbmVkTm9kZSkgPT4gZW1iZWRJbWFnZXMoY2xvbmVkTm9kZSwgb3B0aW9ucykpXG4gICAgICAgICAgICAudGhlbigoY2xvbmVkTm9kZSkgPT4gYXBwbHlTdHlsZVdpdGhPcHRpb25zKGNsb25lZE5vZGUsIG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRoZW4oKGNsb25lZE5vZGUpID0+IGNyZWF0ZVN2Z0RhdGFVUkwoY2xvbmVkTm9kZSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IHRvU3ZnRGF0YVVSTCA9IHRvU3ZnO1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2FudmFzKGRvbU5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB0b1N2Zyhkb21Ob2RlLCBvcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oY3JlYXRlSW1hZ2UpXG4gICAgICAgICAgICAudGhlbihkZWxheSgxMDApKVxuICAgICAgICAgICAgLnRoZW4oKGltYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gb3B0aW9ucy5waXhlbFJhdGlvIHx8IGdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0SW1hZ2VTaXplKGRvbU5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBvcHRpb25zLmNhbnZhc1dpZHRoIHx8IHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gb3B0aW9ucy5jYW52YXNIZWlnaHQgfHwgaGVpZ2h0O1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NhbnZhc1dpZHRofWA7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2FudmFzSGVpZ2h0fWA7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9QaXhlbERhdGEoZG9tTm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXRJbWFnZVNpemUoZG9tTm9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0b0NhbnZhcyhkb21Ob2RlLCBvcHRpb25zKS50aGVuKChjYW52YXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9QbmcoZG9tTm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHRvQ2FudmFzKGRvbU5vZGUsIG9wdGlvbnMpLnRoZW4oKGNhbnZhcykgPT4gY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0pwZWcoZG9tTm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHRvQ2FudmFzKGRvbU5vZGUsIG9wdGlvbnMpLnRoZW4oKGNhbnZhcykgPT4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIG9wdGlvbnMucXVhbGl0eSB8fCAxKSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9CbG9iKGRvbU5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB0b0NhbnZhcyhkb21Ob2RlLCBvcHRpb25zKS50aGVuKGNhbnZhc1RvQmxvYik7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0V2ViRm9udEVtYmVkQ3NzKGRvbU5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRXZWJGb250Q3NzKGRvbU5vZGUsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7696\n")}}]);